<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#1a0a05">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Knights Ransom">
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 192 192'%3E%3Crect width='192' height='192' fill='%231a0a05'/%3E%3Cpath d='M96 20 L160 40 L160 100 Q160 160 96 175 Q32 160 32 100 L32 40 Z' fill='%238b2500'/%3E%3Cpath d='M96 30 L145 47 L145 95 Q145 145 96 158 Q47 145 47 95 L47 47 Z' fill='%23a63000'/%3E%3Cline x1='45' y1='140' x2='75' y2='60' stroke='%23ffd700' stroke-width='4'/%3E%3Cline x1='147' y1='140' x2='117' y2='60' stroke='%23ffd700' stroke-width='4'/%3E%3Cpath d='M70 70 L122 70 L122 110 Q122 130 96 135 Q70 130 70 110 Z' fill='%23c0c0c0'/%3E%3Cpath d='M70 70 Q96 45 122 70 Z' fill='%23a0a0a0'/%3E%3Crect x='75' y='85' width='42' height='8' fill='%231a1a1a'/%3E%3Crect x='78' y='98' width='36' height='5' fill='%231a1a1a'/%3E%3Cpath d='M86 50 L96 35 L106 50 L96 55 Z' fill='%23ffd700'/%3E%3C/svg%3E">
    <link rel="apple-touch-icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 192 192'%3E%3Crect width='192' height='192' fill='%231a0a05'/%3E%3Cpath d='M96 20 L160 40 L160 100 Q160 160 96 175 Q32 160 32 100 L32 40 Z' fill='%238b2500'/%3E%3Cpath d='M96 30 L145 47 L145 95 Q145 145 96 158 Q47 145 47 95 L47 47 Z' fill='%23a63000'/%3E%3Cline x1='45' y1='140' x2='75' y2='60' stroke='%23ffd700' stroke-width='4'/%3E%3Cline x1='147' y1='140' x2='117' y2='60' stroke='%23ffd700' stroke-width='4'/%3E%3Cpath d='M70 70 L122 70 L122 110 Q122 130 96 135 Q70 130 70 110 Z' fill='%23c0c0c0'/%3E%3Cpath d='M70 70 Q96 45 122 70 Z' fill='%23a0a0a0'/%3E%3Crect x='75' y='85' width='42' height='8' fill='%231a1a1a'/%3E%3Crect x='78' y='98' width='36' height='5' fill='%231a1a1a'/%3E%3Cpath d='M86 50 L96 35 L106 50 L96 55 Z' fill='%23ffd700'/%3E%3C/svg%3E">
    <title>Knight's Ransom</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rye&family=IM+Fell+English:ital@0;1&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --dust: #d4a574;
            --blood: #8b2500;
            --gold: #ffd700;
            --leather: #8b4513;
            --night: #1a0a05;
            --parchment: #f4e4bc;
            --rust: #b7410e;
        }

        body {
            background: var(--night);
            font-family: 'IM Fell English', serif;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            position: fixed;
            inset: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            background: 
                radial-gradient(ellipse at 50% 100%, rgba(139, 69, 19, 0.3) 0%, transparent 50%),
                linear-gradient(180deg, #2d1810 0%, #1a0a05 100%);
        }

        canvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        #ui-overlay {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 10;
        }

        #hud {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            background: linear-gradient(180deg, rgba(0,0,0,0.7) 0%, transparent 100%);
        }

        .hud-section {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .stat-bar {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .stat-label {
            font-family: 'Rye', cursive;
            color: var(--dust);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 2px;
            min-width: 60px;
        }

        .bar-container {
            width: 150px;
            height: 16px;
            background: rgba(0,0,0,0.6);
            border: 2px solid var(--leather);
            border-radius: 2px;
            overflow: hidden;
            position: relative;
        }

        .bar-fill {
            height: 100%;
            transition: width 0.3s ease;
        }

        .health-fill {
            background: linear-gradient(90deg, var(--blood), #c41e3a);
            box-shadow: inset 0 -2px 4px rgba(0,0,0,0.3), 0 0 10px rgba(139, 37, 0, 0.5);
        }

        .xp-fill {
            background: linear-gradient(90deg, var(--gold), #ffed4a);
            box-shadow: inset 0 -2px 4px rgba(0,0,0,0.3), 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .armor-fill {
            background: linear-gradient(90deg, #4a90d9, #87ceeb);
            box-shadow: inset 0 -2px 4px rgba(0,0,0,0.3), 0 0 10px rgba(74, 144, 217, 0.5);
        }

        #bounty-display {
            font-family: 'Rye', cursive;
            color: var(--gold);
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8), 0 0 20px rgba(255, 215, 0, 0.3);
        }

        #wave-display {
            font-family: 'Rye', cursive;
            color: var(--dust);
            font-size: 14px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }

        #weapon-display {
            display: flex;
            flex-direction: column;
            gap: 4px;
            padding: 8px 12px;
            background: rgba(0,0,0,0.6);
            border: 2px solid var(--leather);
            border-radius: 4px;
            min-width: 140px;
        }

        #armor-slots-display {
            display: flex;
            gap: 4px;
            margin-top: 8px;
            padding: 6px 8px;
            background: rgba(0,0,0,0.4);
            border-radius: 4px;
        }

        .armor-slot {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            background: rgba(60,40,20,0.6);
            border: 2px solid #3a2a1a;
            border-radius: 4px;
            opacity: 0.4;
            transition: all 0.2s ease;
        }

        .armor-slot.equipped {
            opacity: 1;
            border-color: var(--leather);
        }

        .armor-slot.grade-common { border-color: #9ca3af; }
        .armor-slot.grade-uncommon { border-color: #22c55e; box-shadow: 0 0 5px rgba(34,197,94,0.5); }
        .armor-slot.grade-rare { border-color: #3b82f6; box-shadow: 0 0 5px rgba(59,130,246,0.5); }
        .armor-slot.grade-epic { border-color: #a855f7; box-shadow: 0 0 8px rgba(168,85,247,0.6); }
        .armor-slot.grade-legendary { border-color: #ffd700; box-shadow: 0 0 10px rgba(255,215,0,0.7); }

        #weapons-container {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .weapon-slot {
            display: flex;
            flex-direction: column;
            gap: 2px;
            padding: 6px 10px;
            background: rgba(0,0,0,0.5);
            border: 2px solid #3a2a1a;
            border-radius: 4px;
            min-width: 120px;
            opacity: 0.6;
            transition: all 0.2s ease;
        }

        .weapon-slot.active {
            opacity: 1;
            border-color: var(--gold);
            background: rgba(0,0,0,0.7);
            box-shadow: 0 0 8px rgba(255,215,0,0.3);
        }

        .weapon-slot-icon {
            font-size: 16px;
        }

        .weapon-slot-name {
            font-family: 'Rye', cursive;
            color: var(--parchment);
            font-size: 11px;
        }

        .weapon-slot-stats {
            font-family: 'IM Fell English', serif;
            color: var(--dust);
            font-size: 10px;
        }

        .weapon-header {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #weapon-icon {
            font-size: 20px;
        }

        #weapon-name {
            font-family: 'Rye', cursive;
            color: var(--parchment);
            font-size: 13px;
        }

        #weapon-stats {
            font-family: 'IM Fell English', serif;
            color: var(--dust);
            font-size: 11px;
        }

        #menu-screen, #game-over-screen {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: 
                radial-gradient(ellipse at 50% 30%, rgba(139, 69, 19, 0.2) 0%, transparent 50%),
                linear-gradient(180deg, #2d1810 0%, #1a0a05 100%);
            z-index: 100;
            pointer-events: auto;
        }

        .title {
            font-family: 'Rye', cursive;
            font-size: clamp(36px, 10vw, 72px);
            color: var(--gold);
            text-shadow: 
                3px 3px 0 var(--blood),
                6px 6px 0 rgba(0,0,0,0.5),
                0 0 40px rgba(255, 215, 0, 0.3);
            letter-spacing: 4px;
            text-align: center;
            margin-bottom: 10px;
        }

        .subtitle {
            font-family: 'IM Fell English', serif;
            font-size: clamp(14px, 3vw, 20px);
            color: var(--dust);
            font-style: italic;
            margin-bottom: 40px;
            text-align: center;
            padding: 0 20px;
        }

        .menu-btn {
            font-family: 'Rye', cursive;
            font-size: 18px;
            color: var(--parchment);
            background: linear-gradient(180deg, var(--leather) 0%, #5c2c0a 100%);
            border: 3px solid var(--dust);
            padding: 15px 40px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 3px;
            transition: all 0.2s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            margin: 10px;
        }

        .menu-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.6), 0 0 20px rgba(255, 215, 0, 0.2);
            border-color: var(--gold);
        }

        .menu-btn:active {
            transform: translateY(0);
        }

        .stats-display {
            margin-top: 30px;
            text-align: center;
        }

        .stat-line {
            font-family: 'IM Fell English', serif;
            font-size: 18px;
            color: var(--dust);
            margin: 8px 0;
        }

        .stat-value {
            color: var(--gold);
            font-family: 'Rye', cursive;
        }

        .instructions {
            position: absolute;
            bottom: 30px;
            font-family: 'IM Fell English', serif;
            font-size: 14px;
            color: rgba(212, 165, 116, 0.6);
            text-align: center;
        }

        .hidden {
            display: none !important;
        }

        #mobile-controls {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 200px;
            pointer-events: none;
            z-index: 20;
        }

        .joystick-area {
            position: absolute;
            bottom: 30px;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: rgba(0,0,0,0.3);
            border: 2px solid rgba(212, 165, 116, 0.3);
            pointer-events: auto;
        }

        #joystick-left {
            left: 30px;
        }

        #joystick-right {
            right: 30px;
        }

        .joystick-inner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(212, 165, 116, 0.5);
            border: 2px solid var(--dust);
        }

        #pickup-prompt {
            position: fixed;
            bottom: 220px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Rye', cursive;
            font-size: 16px;
            color: var(--gold);
            background: rgba(0,0,0,0.8);
            padding: 10px 20px;
            border: 2px solid var(--gold);
            border-radius: 4px;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        #pickup-prompt.visible {
            opacity: 1;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        #install-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            font-family: 'Rye', cursive;
            font-size: 12px;
            color: var(--dust);
            background: rgba(0,0,0,0.6);
            border: 1px solid var(--leather);
            padding: 8px 16px;
            cursor: pointer;
            z-index: 200;
            display: none;
        }

        #install-btn:hover {
            border-color: var(--gold);
            color: var(--gold);
        }

        #build-btn {
            position: fixed;
            bottom: 120px;
            right: 20px;
            font-family: 'Rye', cursive;
            font-size: 14px;
            color: var(--dust);
            background: rgba(0,0,0,0.8);
            border: 2px solid var(--leather);
            padding: 10px 20px;
            cursor: pointer;
            z-index: 100;
        }

        #build-btn:hover, #build-btn.active {
            border-color: var(--gold);
            color: var(--gold);
            background: rgba(50, 30, 10, 0.9);
        }

        #build-phase-ui {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(20, 10, 5, 0.95);
            border: 2px solid var(--gold);
            border-radius: 8px;
            padding: 15px 25px;
            z-index: 100;
            text-align: center;
            transition: all 0.3s ease;
        }

        #build-phase-ui.minimized {
            padding: 10px 20px;
        }

        #build-phase-ui.minimized .build-phase-content {
            display: none;
        }

        #build-phase-ui.minimized .build-phase-header {
            margin-bottom: 0;
        }

        .build-phase-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }

        .build-phase-title {
            font-family: 'Rye', cursive;
            font-size: 20px;
            color: var(--gold);
            margin: 0;
        }

        .minimize-btn {
            background: rgba(45, 24, 16, 0.8);
            border: 2px solid var(--leather);
            color: var(--dust);
            font-size: 16px;
            width: 28px;
            height: 28px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            margin-left: 15px;
        }

        .minimize-btn:hover {
            border-color: var(--gold);
            color: var(--gold);
        }

        .minimized-controls {
            display: none;
            flex-direction: row;
            gap: 10px;
            align-items: center;
            margin-top: 10px;
        }

        #build-phase-ui.minimized .minimized-controls {
            display: flex;
        }

        .minimized-controls .build-done-btn {
            margin: 0;
            padding: 8px 15px;
            font-size: 12px;
        }

        .build-phase-subtitle {
            font-family: 'IM Fell English', serif;
            font-size: 14px;
            color: var(--dust);
            margin-bottom: 10px;
        }

        .build-tabs {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .build-tab {
            font-family: 'Rye', cursive;
            font-size: 12px;
            color: var(--dust);
            background: rgba(45, 24, 16, 0.8);
            border: 2px solid var(--leather);
            padding: 8px 16px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .build-tab:hover {
            border-color: var(--gold);
            color: var(--gold);
        }

        .build-tab.active {
            background: rgba(80, 50, 25, 0.9);
            border-color: var(--gold);
            color: var(--gold);
        }

        .build-options {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .siege-info {
            font-family: 'IM Fell English', serif;
            font-size: 12px;
            color: #a99080;
            margin-bottom: 10px;
            min-height: 20px;
        }

        .build-option {
            background: rgba(45, 24, 16, 0.8);
            border: 2px solid var(--leather);
            border-radius: 8px;
            padding: 10px 15px;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 80px;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            user-select: none;
        }

        .build-option:hover {
            border-color: var(--gold);
            background: rgba(60, 35, 20, 0.9);
        }

        .build-option.selected {
            border-color: var(--gold);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.4);
            background: rgba(80, 50, 25, 0.9);
        }

        .build-option.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .build-option.repair-option {
            background: rgba(30, 100, 30, 0.8);
            border-color: #4ade80;
        }

        .build-option.repair-option:hover {
            background: rgba(40, 130, 40, 0.9);
            border-color: #6aff9a;
        }

        .build-option.repair-option.selected {
            border-color: #6aff9a;
            box-shadow: 0 0 15px rgba(74, 222, 128, 0.5);
            background: rgba(40, 130, 40, 0.9);
        }

        .build-option.upgrade-option {
            background: rgba(100, 80, 30, 0.8);
            border-color: #f59e0b;
        }

        .build-option.upgrade-option:hover {
            background: rgba(130, 100, 40, 0.9);
            border-color: #fbbf24;
        }

        .build-option.upgrade-option.selected {
            border-color: #fbbf24;
            box-shadow: 0 0 15px rgba(245, 158, 11, 0.5);
            background: rgba(130, 100, 40, 0.9);
        }

        .build-option.delete-option {
            background: rgba(100, 30, 30, 0.8);
            border-color: #ef4444;
        }

        .build-option.delete-option:hover {
            background: rgba(130, 40, 40, 0.9);
            border-color: #f87171;
        }

        .build-option.delete-option.selected {
            border-color: #f87171;
            box-shadow: 0 0 15px rgba(239, 68, 68, 0.5);
            background: rgba(130, 40, 40, 0.9);
        }

        .build-option.forge-option {
            background: rgba(100, 60, 20, 0.8);
            border-color: #f97316;
        }

        .build-option.forge-option:hover {
            background: rgba(130, 80, 30, 0.9);
            border-color: #fb923c;
        }

        .build-option.forge-option.selected {
            border-color: #fb923c;
            box-shadow: 0 0 15px rgba(249, 115, 22, 0.5);
            background: rgba(130, 80, 30, 0.9);
        }

        .build-option.stable-option {
            background: rgba(60, 80, 40, 0.8);
            border-color: #84cc16;
        }

        .build-option.stable-option:hover {
            background: rgba(80, 100, 50, 0.9);
            border-color: #a3e635;
        }

        .build-option.stable-option.selected {
            border-color: #a3e635;
            box-shadow: 0 0 15px rgba(132, 204, 22, 0.5);
            background: rgba(80, 100, 50, 0.9);
        }

        #damaged-buildings-info {
            font-family: 'IM Fell English', serif;
            font-size: 13px;
            color: #fbbf24;
            margin-top: 10px;
            padding: 5px 10px;
            background: rgba(100, 70, 0, 0.3);
            border-radius: 4px;
        }

        .build-icon {
            font-size: 24px;
            display: block;
            margin-bottom: 5px;
        }

        .build-name {
            font-family: 'Rye', cursive;
            font-size: 12px;
            color: var(--dust);
            display: block;
        }

        .build-cost {
            font-family: 'IM Fell English', serif;
            font-size: 12px;
            color: var(--gold);
        }

        .build-done-btn {
            font-family: 'Rye', cursive;
            font-size: 16px;
            color: #1a1a1a;
            background: var(--gold);
            border: none;
            padding: 10px 30px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s ease;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        .build-done-btn:hover,
        .build-done-btn:active {
            background: #ffed80;
            transform: scale(1.05);
        }
        
        .build-option:active {
            transform: scale(0.95);
            border-color: var(--gold);
        }
        
        .build-tab:active {
            transform: scale(0.95);
        }

        #building-status {
            position: fixed;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Rye', cursive;
            font-size: 14px;
            padding: 8px 16px;
            border-radius: 4px;
            z-index: 100;
            pointer-events: none;
        }

        #building-status.bonus {
            color: #4ade80;
            background: rgba(0, 50, 0, 0.8);
            border: 1px solid #4ade80;
        }

        .grid-preview {
            position: absolute;
            pointer-events: none;
        }

        #levelup-screen {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.85);
            z-index: 150;
            pointer-events: auto;
        }

        .levelup-title {
            font-family: 'Rye', cursive;
            font-size: 36px;
            color: var(--gold);
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8), 0 0 30px rgba(255, 215, 0, 0.4);
            margin-bottom: 10px;
        }

        .levelup-subtitle {
            font-family: 'IM Fell English', serif;
            font-size: 18px;
            color: var(--dust);
            margin-bottom: 30px;
        }

        .points-available {
            font-family: 'Rye', cursive;
            font-size: 24px;
            color: var(--gold);
            margin-bottom: 20px;
        }

        .stats-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
            background: rgba(0, 0, 0, 0.6);
            border: 3px solid var(--leather);
            padding: 25px;
            border-radius: 8px;
            min-width: 350px;
        }

        .stat-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 15px;
        }

        .stat-info {
            display: flex;
            align-items: center;
            gap: 10px;
            min-width: 120px;
        }

        .stat-icon {
            font-size: 20px;
            width: 28px;
            text-align: center;
        }

        .stat-name {
            font-family: 'IM Fell English', serif;
            font-size: 16px;
            color: var(--parchment);
        }

        .stat-level {
            font-family: 'Rye', cursive;
            font-size: 16px;
            color: var(--gold);
            min-width: 30px;
            text-align: center;
        }

        .stat-value {
            font-family: 'IM Fell English', serif;
            font-size: 13px;
            color: var(--dust);
            min-width: 70px;
            text-align: right;
        }

        .stat-bar-bg {
            width: 100px;
            height: 12px;
            background: rgba(0,0,0,0.5);
            border: 1px solid var(--leather);
            border-radius: 2px;
            overflow: hidden;
        }

        .stat-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--gold), #ffed4a);
            transition: width 0.3s ease;
        }

        .stat-btn {
            width: 32px;
            height: 32px;
            font-family: 'Rye', cursive;
            font-size: 20px;
            color: var(--parchment);
            background: linear-gradient(180deg, var(--leather) 0%, #5c2c0a 100%);
            border: 2px solid var(--dust);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
        }

        .stat-btn:hover:not(:disabled) {
            border-color: var(--gold);
            transform: scale(1.1);
        }

        .stat-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .stat-btn:active:not(:disabled) {
            transform: scale(0.95);
        }

        .confirm-btn {
            margin-top: 25px;
            font-family: 'Rye', cursive;
            font-size: 16px;
            color: var(--parchment);
            background: linear-gradient(180deg, #2a6e2a 0%, #1a4a1a 100%);
            border: 3px solid #4a4;
            padding: 12px 35px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.2s ease;
        }

        .confirm-btn:hover:not(:disabled) {
            box-shadow: 0 0 20px rgba(68, 170, 68, 0.4);
            transform: translateY(-2px);
        }

        .confirm-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #weapon-swap-screen {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.9);
            z-index: 160;
            pointer-events: auto;
        }

        .swap-title {
            font-family: 'Rye', cursive;
            font-size: 28px;
            color: var(--gold);
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            margin-bottom: 25px;
        }

        .weapon-comparison {
            display: flex;
            gap: 40px;
            align-items: stretch;
        }

        .weapon-card {
            background: rgba(0, 0, 0, 0.7);
            border: 3px solid var(--leather);
            border-radius: 8px;
            padding: 20px;
            min-width: 220px;
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .weapon-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        .weapon-card.current-weapon {
            border-color: #666;
        }

        .weapon-card.new-weapon {
            border-color: var(--gold);
        }

        .weapon-card-label {
            font-family: 'IM Fell English', serif;
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 10px;
        }

        .weapon-card-name {
            font-family: 'Rye', cursive;
            font-size: 18px;
            margin-bottom: 15px;
            text-align: center;
        }

        .weapon-card-icon {
            width: 120px;
            height: 140px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .weapon-card-icon canvas {
            image-rendering: pixelated;
        }

        .weapon-stats-list {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .weapon-stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 10px;
            background: rgba(255,255,255,0.05);
            border-radius: 4px;
        }

        .weapon-stat-label {
            font-family: 'IM Fell English', serif;
            font-size: 14px;
            color: var(--dust);
        }

        .weapon-stat-value {
            font-family: 'Rye', cursive;
            font-size: 14px;
        }

        .stat-better {
            color: #4ade80;
        }

        .stat-worse {
            color: #f87171;
        }

        .stat-same {
            color: var(--parchment);
        }

        .weapon-card-button {
            margin-top: 15px;
            font-family: 'Rye', cursive;
            font-size: 14px;
            padding: 10px 25px;
            border: 2px solid;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s ease;
            background: transparent;
        }

        .keep-btn {
            color: #888;
            border-color: #666;
        }

        .keep-btn:hover {
            color: var(--parchment);
            border-color: var(--parchment);
            background: rgba(255,255,255,0.1);
        }

        .swap-btn {
            color: var(--gold);
            border-color: var(--gold);
        }

        .swap-btn:hover {
            background: rgba(255, 215, 0, 0.2);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
        }

        .vs-divider {
            font-family: 'Rye', cursive;
            font-size: 24px;
            color: var(--blood);
            text-shadow: 0 0 10px rgba(139, 37, 0, 0.5);
        }

        /* Armor Swap Screen */
        #armor-swap-screen {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.9);
            z-index: 160;
            pointer-events: auto;
        }

        .armor-comparison {
            display: flex;
            gap: 40px;
            align-items: stretch;
        }

        .armor-card {
            background: rgba(0, 0, 0, 0.7);
            border: 3px solid var(--leather);
            border-radius: 8px;
            padding: 20px;
            min-width: 200px;
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .armor-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        .armor-card.current-armor {
            border-color: #666;
        }

        .armor-card.new-armor {
            border-color: var(--gold);
        }

        .armor-card-label {
            font-family: 'IM Fell English', serif;
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 10px;
        }

        .armor-card-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }

        .armor-card-name {
            font-family: 'Rye', cursive;
            font-size: 16px;
            margin-bottom: 10px;
            text-align: center;
        }

        .armor-card-stats {
            font-family: 'IM Fell English', serif;
            font-size: 13px;
            color: var(--dust);
            text-align: center;
            margin-bottom: 10px;
            min-height: 60px;
        }

        .armor-stat-line {
            margin: 4px 0;
        }

        .armor-stat-line.armor-value {
            color: #60a5fa;
            font-weight: bold;
        }

        .armor-stat-line.bonus {
            color: #4ade80;
        }

        .armor-card-button {
            margin-top: auto;
            font-family: 'Rye', cursive;
            font-size: 14px;
            padding: 10px 25px;
            border: 2px solid;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s ease;
            background: transparent;
        }

        /* Forge Screen */
        #forge-screen {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.95);
            z-index: 170;
            pointer-events: auto;
        }

        .forge-title {
            font-family: 'Rye', cursive;
            font-size: 32px;
            color: #f97316;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8), 0 0 20px rgba(249,115,22,0.5);
            margin-bottom: 10px;
        }

        .forge-subtitle {
            font-family: 'IM Fell English', serif;
            font-size: 14px;
            color: var(--dust);
            margin-bottom: 25px;
        }

        .forge-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .forge-tab {
            font-family: 'Rye', cursive;
            font-size: 14px;
            padding: 10px 20px;
            background: rgba(50, 40, 30, 0.8);
            border: 2px solid #5a4a3a;
            color: var(--dust);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .forge-tab:hover {
            border-color: #f97316;
            color: #f97316;
        }

        .forge-tab.active {
            background: rgba(100, 60, 20, 0.9);
            border-color: #f97316;
            color: #f97316;
        }

        .forge-content {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 800px;
            max-height: 400px;
            overflow-y: auto;
        }

        .forge-item {
            background: rgba(40, 30, 20, 0.9);
            border: 2px solid #5a4a3a;
            border-radius: 8px;
            padding: 15px;
            min-width: 180px;
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .forge-item:hover {
            border-color: #f97316;
            transform: translateY(-3px);
        }

        .forge-item.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .forge-item-icon {
            font-size: 36px;
            margin-bottom: 8px;
        }

        .forge-item-name {
            font-family: 'Rye', cursive;
            font-size: 13px;
            color: var(--parchment);
            margin-bottom: 5px;
            text-align: center;
        }

        .forge-item-stats {
            font-family: 'IM Fell English', serif;
            font-size: 11px;
            color: var(--dust);
            text-align: center;
            margin-bottom: 8px;
        }

        .forge-item-cost {
            font-family: 'Rye', cursive;
            font-size: 12px;
            color: #fbbf24;
        }

        .forge-item-upgrade {
            font-family: 'IM Fell English', serif;
            font-size: 11px;
            color: #4ade80;
            margin-top: 5px;
        }

        .forge-close {
            margin-top: 20px;
            font-family: 'Rye', cursive;
            font-size: 14px;
            padding: 10px 30px;
            background: rgba(60, 40, 30, 0.9);
            border: 2px solid #5a4a3a;
            color: var(--parchment);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .forge-close:hover {
            border-color: var(--gold);
            color: var(--gold);
        }

        /* Stable Screen */
        #stable-screen {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.95);
            z-index: 170;
            pointer-events: auto;
        }

        .stable-title {
            font-family: 'Rye', cursive;
            font-size: 32px;
            color: #84cc16;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8), 0 0 20px rgba(132,204,22,0.5);
            margin-bottom: 10px;
        }

        .stable-subtitle {
            font-family: 'IM Fell English', serif;
            font-size: 14px;
            color: var(--dust);
            margin-bottom: 25px;
        }

        .stable-content {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 700px;
        }

        .horse-card {
            background: rgba(40, 50, 30, 0.9);
            border: 2px solid #5a6a4a;
            border-radius: 8px;
            padding: 15px;
            min-width: 150px;
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .horse-card:hover {
            border-color: #84cc16;
            transform: translateY(-3px);
        }

        .horse-card.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .horse-card.owned {
            border-color: #4ade80;
            background: rgba(50, 70, 40, 0.9);
        }

        .horse-card-icon {
            font-size: 48px;
            margin-bottom: 8px;
        }

        .horse-card-name {
            font-family: 'Rye', cursive;
            font-size: 14px;
            color: var(--parchment);
            margin-bottom: 5px;
        }

        .horse-card-stats {
            font-family: 'IM Fell English', serif;
            font-size: 12px;
            color: var(--dust);
            text-align: center;
            margin-bottom: 8px;
        }

        .horse-card-cost {
            font-family: 'Rye', cursive;
            font-size: 13px;
            color: #fbbf24;
        }

        .current-horse {
            margin-top: 20px;
            padding: 15px 25px;
            background: rgba(40, 50, 30, 0.8);
            border: 2px solid #5a6a4a;
            border-radius: 8px;
            text-align: center;
        }

        .current-horse-title {
            font-family: 'IM Fell English', serif;
            font-size: 12px;
            color: #888;
            margin-bottom: 5px;
        }

        .current-horse-info {
            font-family: 'Rye', cursive;
            font-size: 16px;
            color: #84cc16;
        }

        .stable-close {
            margin-top: 20px;
            font-family: 'Rye', cursive;
            font-size: 14px;
            padding: 10px 30px;
            background: rgba(40, 50, 30, 0.9);
            border: 2px solid #5a6a4a;
            color: var(--parchment);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .stable-close:hover {
            border-color: #84cc16;
            color: #84cc16;
        }

        /* Horse health bar in HUD */
        .horse-bar {
            margin-top: 5px;
        }

        .horse-bar .bar-fill {
            background: linear-gradient(90deg, #65a30d, #84cc16);
        }

        /* ========== MOBILE RESPONSIVE STYLES ========== */
        @media screen and (max-width: 768px), screen and (max-height: 600px) {
            /* Level Up Screen */
            .levelup-title {
                font-size: 24px;
                margin-bottom: 5px;
            }
            
            .levelup-subtitle {
                font-size: 14px;
                margin-bottom: 15px;
            }
            
            .points-available {
                font-size: 18px;
                margin-bottom: 10px;
            }
            
            .stats-container {
                padding: 12px;
                min-width: auto;
                width: 95vw;
                max-width: 400px;
                max-height: 70vh;
                overflow-y: auto;
                gap: 8px;
            }
            
            .stat-row {
                gap: 8px;
                flex-wrap: nowrap;
            }
            
            .stat-info {
                min-width: 80px;
                gap: 5px;
            }
            
            .stat-icon {
                font-size: 16px;
                width: 20px;
            }
            
            .stat-name {
                font-size: 12px;
            }
            
            .stat-level {
                font-size: 14px;
                min-width: 24px;
            }
            
            .stat-value {
                font-size: 10px;
                min-width: 50px;
            }
            
            .stat-bar-bg {
                width: 50px;
                height: 8px;
            }
            
            .stat-btn {
                width: 36px;
                height: 36px;
                font-size: 18px;
            }
            
            .confirm-btn {
                margin-top: 15px;
                font-size: 14px;
                padding: 10px 25px;
            }
            
            /* Weapon Swap Screen */
            .swap-title {
                font-size: 20px;
                margin-bottom: 15px;
            }
            
            .weapon-comparison {
                flex-direction: column;
                gap: 15px;
                width: 90vw;
                max-width: 300px;
            }
            
            .weapon-card {
                min-width: auto;
                width: 100%;
                padding: 12px;
            }
            
            .weapon-card-name {
                font-size: 14px;
                margin-bottom: 10px;
            }
            
            .weapon-card-icon {
                width: 80px;
                height: 80px;
                margin-bottom: 10px;
            }
            
            .weapon-stats-list {
                gap: 4px;
            }
            
            .weapon-stat-row {
                padding: 4px 8px;
            }
            
            .weapon-stat-label,
            .weapon-stat-value {
                font-size: 12px;
            }
            
            .weapon-card-button {
                margin-top: 10px;
                font-size: 12px;
                padding: 8px 20px;
            }
            
            .vs-divider {
                font-size: 18px;
            }
            
            /* Armor Swap Screen */
            .armor-comparison {
                flex-direction: column;
                gap: 15px;
                width: 90vw;
                max-width: 300px;
            }
            
            .armor-card {
                min-width: auto;
                width: 100%;
                padding: 12px;
            }
            
            .armor-card-icon {
                font-size: 32px;
                margin-bottom: 5px;
            }
            
            .armor-card-name {
                font-size: 14px;
                margin-bottom: 5px;
            }
            
            .armor-card-stats {
                font-size: 11px;
                min-height: 40px;
            }
            
            .armor-card-button {
                font-size: 12px;
                padding: 8px 20px;
            }
            
            /* Forge Screen */
            .forge-content {
                max-width: 95vw;
                max-height: 80vh;
                padding: 15px;
            }
            
            .forge-title {
                font-size: 20px;
            }
            
            .armor-repair-grid {
                gap: 8px;
            }
            
            .repair-slot {
                padding: 8px;
            }
            
            .slot-icon {
                font-size: 24px;
            }
            
            .slot-name {
                font-size: 10px;
            }
            
            /* Stable Screen */
            .stable-content {
                max-width: 95vw;
                max-height: 80vh;
                padding: 15px;
            }
            
            .stable-title {
                font-size: 20px;
            }
            
            .horse-grid {
                gap: 8px;
            }
            
            .horse-card {
                padding: 10px;
                min-width: 70px;
            }
            
            .horse-icon {
                font-size: 28px;
            }
            
            .horse-name {
                font-size: 11px;
            }
            
            /* Build Phase UI */
            #build-phase-ui {
                max-height: 45vh;
                overflow-y: auto;
                padding: 10px 15px;
                width: 95%;
                max-width: 500px;
                bottom: 10px;
            }
            
            .build-phase-title {
                font-size: 16px;
            }
            
            .build-tabs {
                gap: 5px;
                flex-wrap: wrap;
            }
            
            .build-tab {
                padding: 6px 12px;
                font-size: 11px;
            }
            
            .build-options {
                gap: 6px;
            }
            
            .build-option {
                padding: 8px 10px;
                min-width: 65px;
            }
            
            .build-icon {
                font-size: 18px;
            }
            
            .build-name {
                font-size: 10px;
            }
            
            .build-cost {
                font-size: 10px;
            }
            
            .build-done-btn {
                padding: 10px 20px;
                font-size: 12px;
            }
            
            .siege-info {
                font-size: 10px;
            }
        }
        
        /* Extra small screens (phones in portrait) */
        @media screen and (max-width: 480px) {
            .stats-container {
                padding: 8px;
                gap: 6px;
            }
            
            .stat-row {
                gap: 4px;
            }
            
            .stat-info {
                min-width: 60px;
            }
            
            .stat-name {
                font-size: 10px;
            }
            
            .stat-bar-bg {
                width: 40px;
                display: none;
            }
            
            .stat-btn {
                width: 32px;
                height: 32px;
            }
            
            .weapon-comparison,
            .armor-comparison {
                max-width: 280px;
            }
            
            /* Even smaller build UI for tiny screens */
            #build-phase-ui {
                max-height: 40vh;
                padding: 8px 10px;
                bottom: 5px;
            }
            
            .build-phase-title {
                font-size: 14px;
            }
            
            .build-phase-subtitle {
                font-size: 11px;
                margin-bottom: 5px;
            }
            
            .build-option {
                padding: 6px 8px;
                min-width: 55px;
            }
            
            .build-icon {
                font-size: 16px;
            }
            
            .build-name {
                font-size: 9px;
            }
            
            .build-cost {
                font-size: 9px;
            }
            
            .build-done-btn {
                padding: 8px 15px;
                font-size: 11px;
                margin-top: 8px;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game"></canvas>
    </div>

    <div id="ui-overlay">
        <div id="hud" class="hidden">
            <div class="hud-section">
                <div class="stat-bar">
                    <span class="stat-label">Health</span>
                    <div class="bar-container">
                        <div class="bar-fill health-fill" id="health-bar" style="width: 100%"></div>
                    </div>
                </div>
                <div class="stat-bar">
                    <span class="stat-label">Armor</span>
                    <div class="bar-container">
                        <div class="bar-fill armor-fill" id="armor-bar" style="width: 0%"></div>
                    </div>
                </div>
                <div class="stat-bar">
                    <span class="stat-label">XP</span>
                    <div class="bar-container">
                        <div class="bar-fill xp-fill" id="xp-bar" style="width: 0%"></div>
                    </div>
                </div>
                <div class="stat-bar horse-bar hidden" id="horse-bar-container">
                    <span class="stat-label"> Horse</span>
                    <div class="bar-container">
                        <div class="bar-fill" id="horse-bar" style="width: 100%"></div>
                    </div>
                </div>
                <div id="armor-slots-display">
                    <span class="armor-slot" id="slot-head" title="Head"></span>
                    <span class="armor-slot" id="slot-body" title="Body"></span>
                    <span class="armor-slot" id="slot-arms" title="Arms"></span>
                    <span class="armor-slot" id="slot-legs" title="Legs"></span>
                    <span class="armor-slot" id="slot-feet" title="Feet"></span>
                    <span class="armor-slot" id="slot-belt" title="Belt"></span>
                </div>
            </div>
            <div class="hud-section" style="align-items: flex-end;">
                <div id="bounty-display">$0</div>
                <div id="wave-display">Wave 1</div>
                <div id="weapons-container">
                    <div id="melee-weapon-display" class="weapon-slot active">
                        <div class="weapon-header">
                            <span class="weapon-slot-icon"></span>
                            <span class="weapon-slot-name" id="melee-weapon-name">Rusty Sword</span>
                        </div>
                        <span class="weapon-slot-stats" id="melee-weapon-stats">DMG: 12</span>
                    </div>
                    <div id="ranged-weapon-display" class="weapon-slot">
                        <div class="weapon-header">
                            <span class="weapon-slot-icon"></span>
                            <span class="weapon-slot-name" id="ranged-weapon-name">Old Bow</span>
                        </div>
                        <span class="weapon-slot-stats" id="ranged-weapon-stats">DMG: 10</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="mobile-controls" class="hidden">
        <div class="joystick-area" id="joystick-left">
            <div class="joystick-inner" id="joystick-left-inner"></div>
        </div>
    </div>

    <div id="pickup-prompt">Press SPACE to pick up</div>

    <div id="weapon-swap-screen" class="hidden">
        <h2 class="swap-title">New Weapon Found!</h2>
        <div class="weapon-comparison">
            <div class="weapon-card current-weapon" onclick="keepCurrentWeapon()">
                <span class="weapon-card-label">Current Weapon</span>
                <div class="weapon-card-icon">
                    <canvas id="current-weapon-canvas" width="120" height="140"></canvas>
                </div>
                <span class="weapon-card-name" id="current-weapon-name">Rusty Sword</span>
                <div class="weapon-stats-list" id="current-weapon-stats"></div>
                <button class="weapon-card-button keep-btn">Keep</button>
            </div>
            
            <span class="vs-divider">VS</span>
            
            <div class="weapon-card new-weapon" onclick="swapToNewWeapon()">
                <span class="weapon-card-label">New Weapon</span>
                <div class="weapon-card-icon">
                    <canvas id="new-weapon-canvas" width="120" height="140"></canvas>
                </div>
                <span class="weapon-card-name" id="new-weapon-name">Unknown</span>
                <div class="weapon-stats-list" id="new-weapon-stats"></div>
                <button class="weapon-card-button swap-btn">Equip</button>
            </div>
        </div>
    </div>

    <div id="menu-screen">
        <h1 class="title">Knight's Ransom</h1>
        <p class="subtitle">Defend your castle against the horde. Collect weapons and armor. Survive.</p>
        <button class="menu-btn" id="start-btn">Start Game</button>
        <p class="instructions">WASD or Arrow Keys to move  Auto-aim shoots automatically<br>Walk over drops to collect  SPACE to swap weapons</p>
    </div>

    <div id="armor-swap-screen" class="hidden">
        <h2 class="swap-title" id="armor-swap-title">New Armor Found!</h2>
        <div class="armor-comparison">
            <div class="armor-card current-armor" onclick="keepCurrentArmor()">
                <span class="armor-card-label">Current</span>
                <div class="armor-card-icon" id="current-armor-icon">-</div>
                <span class="armor-card-name" id="current-armor-name">Empty</span>
                <div class="armor-card-stats" id="current-armor-stats">No armor equipped</div>
                <button class="armor-card-button keep-btn">Keep</button>
            </div>
            
            <span class="vs-divider">VS</span>
            
            <div class="armor-card new-armor" onclick="equipNewArmor()">
                <span class="armor-card-label">New</span>
                <div class="armor-card-icon" id="new-armor-icon"></div>
                <span class="armor-card-name" id="new-armor-name">Unknown</span>
                <div class="armor-card-stats" id="new-armor-stats"></div>
                <button class="armor-card-button swap-btn">Equip</button>
            </div>
        </div>
    </div>

    <div id="forge-screen" class="hidden">
        <h2 class="forge-title"> The Forge </h2>
        <p class="forge-subtitle">Upgrade your equipment for gold</p>
        
        <div class="forge-tabs">
            <button class="forge-tab active" onclick="switchForgeTab('weapons')" id="forge-tab-weapons"> Weapons</button>
            <button class="forge-tab" onclick="switchForgeTab('armor')" id="forge-tab-armor"> Upgrade</button>
            <button class="forge-tab" onclick="switchForgeTab('repair')" id="forge-tab-repair"> Repair</button>
        </div>
        
        <div class="forge-content" id="forge-content">
            <!-- Populated dynamically -->
        </div>
        
        <button class="forge-close" onclick="closeForge()">Close Forge</button>
    </div>

    <div id="stable-screen" class="hidden">
        <h2 class="stable-title"> The Stable </h2>
        <p class="stable-subtitle">Purchase a horse for protection - it absorbs damage for you!</p>
        
        <div class="stable-content" id="stable-content">
            <!-- Populated dynamically -->
        </div>
        
        <div class="current-horse" id="current-horse-display">
            <div class="current-horse-title">Current Mount</div>
            <div class="current-horse-info" id="current-horse-info">None</div>
        </div>
        
        <button class="stable-close" onclick="closeStable()">Close Stable</button>
    </div>

    <div id="game-over-screen" class="hidden">
        <h1 class="title">Fallen</h1>
        <p class="subtitle">The horde has overwhelmed you...</p>
        <div class="stats-display">
            <p class="stat-line">Bounty Collected: <span class="stat-value" id="final-bounty">$0</span></p>
            <p class="stat-line">Waves Survived: <span class="stat-value" id="final-wave">0</span></p>
            <p class="stat-line">Enemies Defeated: <span class="stat-value" id="final-kills">0</span></p>
        </div>
        <button class="menu-btn" id="restart-btn">Try Again</button>
    </div>

    <button id="install-btn"> Install Game</button>

    <div id="build-phase-ui" class="hidden">
        <div class="build-phase-header">
            <div class="build-phase-title"> Build Phase</div>
            <button class="minimize-btn" onclick="toggleBuildMinimize()" id="minimize-btn" title="Minimize"></button>
        </div>
        
        <div class="build-phase-content">
            <div class="build-phase-subtitle">Wave <span id="build-wave">1</span> Complete! Place your defenses.</div>
            
            <div class="build-tabs">
                <button class="build-tab active" onclick="switchBuildCategory('structures')" id="tab-structures"> Structures</button>
                <button class="build-tab" onclick="switchBuildCategory('siege')" id="tab-siege"> Siege</button>
            </div>
            
            <div class="build-options" id="structures-options">
                <div class="build-option" onclick="selectBuilding('wall')" id="build-wall">
                    <span class="build-icon"></span>
                    <span class="build-name">Palisade</span>
                    <span class="build-cost">$15</span>
                </div>
                <div class="build-option" onclick="selectBuilding('tower')" id="build-tower">
                    <span class="build-icon"></span>
                    <span class="build-name">Tower</span>
                    <span class="build-cost">$75</span>
                </div>
                <div class="build-option" onclick="selectBuilding('gate')" id="build-gate">
                    <span class="build-icon"></span>
                    <span class="build-name">Gate</span>
                    <span class="build-cost">$50</span>
                </div>
                <div class="build-option" onclick="selectBuilding('ladder')" id="build-ladder">
                    <span class="build-icon"></span>
                    <span class="build-name">Ladder</span>
                    <span class="build-cost">$15</span>
                </div>
                <div class="build-option forge-option" onclick="selectBuilding('forge')" id="build-forge">
                    <span class="build-icon"></span>
                    <span class="build-name">Forge</span>
                    <span class="build-cost">$100</span>
                </div>
                <div class="build-option stable-option" onclick="selectBuilding('stable')" id="build-stable">
                    <span class="build-icon"></span>
                    <span class="build-name">Stable</span>
                    <span class="build-cost">$125</span>
                </div>
                <div class="build-option upgrade-option" onclick="selectUpgradeMode()" id="build-upgrade">
                    <span class="build-icon"></span>
                    <span class="build-name">Upgrade</span>
                    <span class="build-cost">$25+</span>
                </div>
                <div class="build-option repair-option" onclick="selectRepairMode()" id="build-repair">
                    <span class="build-icon"></span>
                    <span class="build-name">Repair</span>
                    <span class="build-cost">$10</span>
                </div>
                <div class="build-option delete-option" onclick="selectDeleteMode()" id="build-delete">
                    <span class="build-icon"></span>
                    <span class="build-name">Delete</span>
                    <span class="build-cost">+50%</span>
                </div>
            </div>
            
            <div class="build-options hidden" id="siege-options">
                <div class="build-option" onclick="selectSiege('scorpion')" id="siege-scorpion">
                    <span class="build-icon"></span>
                    <span class="build-name">Scorpion</span>
                    <span class="build-cost">$75</span>
                </div>
                <div class="build-option" onclick="selectSiege('catapult')" id="siege-catapult">
                    <span class="build-icon"></span>
                    <span class="build-name">Catapult</span>
                    <span class="build-cost">$125</span>
                </div>
                <div class="build-option" onclick="selectSiege('onager')" id="siege-onager">
                    <span class="build-icon"></span>
                    <span class="build-name">Onager</span>
                    <span class="build-cost">$150</span>
                </div>
                <div class="build-option" onclick="selectSiege('trebuchet')" id="siege-trebuchet">
                    <span class="build-icon"></span>
                    <span class="build-name">Trebuchet</span>
                    <span class="build-cost">$200</span>
                </div>
            </div>
            
            <div class="siege-info" id="siege-info"></div>
            
            <div id="damaged-buildings-info" class="hidden">
                <span id="damaged-count">0</span> damaged structures
            </div>
            <button class="build-done-btn" onclick="endBuildPhase()">Start Wave <span id="next-wave">2</span> </button>
        </div>
        
        <div class="minimized-controls">
            <button class="build-done-btn" onclick="endBuildPhase()">Start Wave <span id="next-wave-min">2</span> </button>
        </div>
    </div>

    <div id="building-status" class="hidden"></div>

    <div id="levelup-screen" class="hidden">
        <h2 class="levelup-title">Level Up!</h2>
        <p class="levelup-subtitle">You've grown stronger. Allocate your skill points.</p>
        <p class="points-available">Points Available: <span id="points-remaining">0</span></p>
        
        <div class="stats-container">
            <div class="stat-row" data-stat="vitality">
                <div class="stat-info">
                    <span class="stat-icon"></span>
                    <span class="stat-name">Vitality</span>
                </div>
                <span class="stat-level" id="lvl-vitality">0</span>
                <div class="stat-bar-bg">
                    <div class="stat-bar-fill" id="bar-vitality" style="width: 0%"></div>
                </div>
                <span class="stat-value" id="val-vitality">100 HP</span>
                <button class="stat-btn" onclick="allocateStat('vitality')">+</button>
            </div>
            
            <div class="stat-row" data-stat="recovery">
                <div class="stat-info">
                    <span class="stat-icon"></span>
                    <span class="stat-name">Recovery</span>
                </div>
                <span class="stat-level" id="lvl-recovery">0</span>
                <div class="stat-bar-bg">
                    <div class="stat-bar-fill" id="bar-recovery" style="width: 0%"></div>
                </div>
                <span class="stat-value" id="val-recovery">0.0/s</span>
                <button class="stat-btn" onclick="allocateStat('recovery')">+</button>
            </div>
            
            <div class="stat-row" data-stat="strength">
                <div class="stat-info">
                    <span class="stat-icon"></span>
                    <span class="stat-name">Strength</span>
                </div>
                <span class="stat-level" id="lvl-strength">0</span>
                <div class="stat-bar-bg">
                    <div class="stat-bar-fill" id="bar-strength" style="width: 0%"></div>
                </div>
                <span class="stat-value" id="val-strength">+0 dmg</span>
                <button class="stat-btn" onclick="allocateStat('strength')">+</button>
            </div>
            
            <div class="stat-row" data-stat="dexterity">
                <div class="stat-info">
                    <span class="stat-icon"></span>
                    <span class="stat-name">Attack Speed</span>
                </div>
                <span class="stat-level" id="lvl-dexterity">0</span>
                <div class="stat-bar-bg">
                    <div class="stat-bar-fill" id="bar-dexterity" style="width: 0%"></div>
                </div>
                <span class="stat-value" id="val-dexterity">+0 spd</span>
                <button class="stat-btn" onclick="allocateStat('dexterity')">+</button>
            </div>
            
            <div class="stat-row" data-stat="toughness">
                <div class="stat-info">
                    <span class="stat-icon"></span>
                    <span class="stat-name">Toughness</span>
                </div>
                <span class="stat-level" id="lvl-toughness">0</span>
                <div class="stat-bar-bg">
                    <div class="stat-bar-fill" id="bar-toughness" style="width: 0%"></div>
                </div>
                <span class="stat-value" id="val-toughness">50 armor</span>
                <button class="stat-btn" onclick="allocateStat('toughness')">+</button>
            </div>
            
            <div class="stat-row" data-stat="fortune">
                <div class="stat-info">
                    <span class="stat-icon"></span>
                    <span class="stat-name">Fortune</span>
                </div>
                <span class="stat-level" id="lvl-fortune">0</span>
                <div class="stat-bar-bg">
                    <div class="stat-bar-fill" id="bar-fortune" style="width: 0%"></div>
                </div>
                <span class="stat-value" id="val-fortune">+0% gold</span>
                <button class="stat-btn" onclick="allocateStat('fortune')">+</button>
            </div>
            
            <div class="stat-row" data-stat="wisdom">
                <div class="stat-info">
                    <span class="stat-icon"></span>
                    <span class="stat-name">Wisdom</span>
                </div>
                <span class="stat-level" id="lvl-wisdom">0</span>
                <div class="stat-bar-bg">
                    <div class="stat-bar-fill" id="bar-wisdom" style="width: 0%"></div>
                </div>
                <span class="stat-value" id="val-wisdom">+0% XP</span>
                <button class="stat-btn" onclick="allocateStat('wisdom')">+</button>
            </div>
            
            <div class="stat-row" data-stat="precision">
                <div class="stat-info">
                    <span class="stat-icon"></span>
                    <span class="stat-name">Crit Chance</span>
                </div>
                <span class="stat-level" id="lvl-precision">0</span>
                <div class="stat-bar-bg">
                    <div class="stat-bar-fill" id="bar-precision" style="width: 0%"></div>
                </div>
                <span class="stat-value" id="val-precision">5%</span>
                <button class="stat-btn" onclick="allocateStat('precision')">+</button>
            </div>
            
            <div class="stat-row" data-stat="ferocity">
                <div class="stat-info">
                    <span class="stat-icon"></span>
                    <span class="stat-name">Crit Damage</span>
                </div>
                <span class="stat-level" id="lvl-ferocity">0</span>
                <div class="stat-bar-bg">
                    <div class="stat-bar-fill" id="bar-ferocity" style="width: 0%"></div>
                </div>
                <span class="stat-value" id="val-ferocity">150%</span>
                <button class="stat-btn" onclick="allocateStat('ferocity')">+</button>
            </div>
        </div>
        
        <button class="confirm-btn" id="confirm-levelup" onclick="confirmLevelUp()">Continue</button>
    </div>

    <script>
        // Game constants
        const GAME_WIDTH = 800;
        const GAME_HEIGHT = 600;
        const WORLD_WIDTH = 3200;
        const WORLD_HEIGHT = 2400;
        
        // Camera position (top-left corner of viewport)
        let camera = { x: 0, y: 0 };
        
        // Buildings array
        let buildings = [];
        
        // Grid-based building system
        const GRID_SIZE = 40; // Match ground tile size
        
        // Building types and costs
        const BUILDING_TYPES = {
            wall: {
                name: 'Palisade',
                cost: 15,
                icon: '',
                health: 60,
                blockEnemies: true,
                blockPlayer: true,
                climbable: true,
                rangeBonus: 1.15,
                damageBonus: 1.1,
                siegeBonus: 1.1,
                wallTier: 1,
                upgradeable: true,
                tierData: 'WALL_TIERS',
                description: 'Wooden wall. Can be upgraded.'
            },
            tower: {
                name: 'Wooden Tower',
                cost: 75,
                icon: '',
                health: 200,
                blockEnemies: true,
                blockPlayer: true,
                climbable: true,
                rangeBonus: 1.5,
                damageBonus: 1.35,
                elevated: true,
                siegeBonus: 1.5,
                wallTier: 1,
                upgradeable: true,
                tierData: 'TOWER_TIERS',
                description: 'Strong defense. Can be upgraded.'
            },
            gate: {
                name: 'Wooden Gate',
                cost: 50,
                icon: '',
                health: 75,
                blockEnemies: true,
                blockPlayer: false,
                wallTier: 1,
                upgradeable: true,
                tierData: 'GATE_TIERS',
                description: 'You pass through. Can be upgraded.'
            },
            ladder: {
                name: 'Ladder',
                cost: 15,
                icon: '',
                health: 50,
                blockEnemies: false,
                blockPlayer: false,
                isLadder: true,
                description: 'Place next to wall/tower to climb up.'
            },
            forge: {
                name: 'Forge',
                cost: 100,
                icon: '',
                health: 150,
                blockEnemies: true,
                blockPlayer: false,
                isForge: true,
                description: 'Upgrade weapons and armor.'
            },
            stable: {
                name: 'Stable',
                cost: 125,
                icon: '',
                health: 175,
                blockEnemies: true,
                blockPlayer: false,
                isStable: true,
                description: 'Purchase horses for protection.'
            }
        };
        
        // Wall upgrade tiers
        const WALL_TIERS = {
            1: {
                name: 'Palisade',
                icon: '',
                health: 60,
                rangeBonus: 1.15,
                damageBonus: 1.1,
                siegeBonus: 1.1,
                upgradeCost: 25, // Cost to upgrade to next tier
                color: '#8b5a2b'
            },
            2: {
                name: 'Stone Wall',
                icon: '',
                health: 120,
                rangeBonus: 1.25,
                damageBonus: 1.2,
                siegeBonus: 1.25,
                upgradeCost: 50,
                color: '#808080'
            },
            3: {
                name: 'Fortified Wall',
                icon: '',
                health: 200,
                rangeBonus: 1.4,
                damageBonus: 1.3,
                siegeBonus: 1.4,
                upgradeCost: null, // Max tier
                color: '#606080'
            }
        };
        
        // Tower upgrade tiers
        const TOWER_TIERS = {
            1: {
                name: 'Wooden Tower',
                icon: '',
                health: 200,
                rangeBonus: 1.5,
                damageBonus: 1.35,
                siegeBonus: 1.5,
                upgradeCost: 50,
                color: '#8b5a2b'
            },
            2: {
                name: 'Stone Tower',
                icon: '',
                health: 350,
                rangeBonus: 1.7,
                damageBonus: 1.5,
                siegeBonus: 1.7,
                upgradeCost: 100,
                color: '#808080'
            },
            3: {
                name: 'Fortress Tower',
                icon: '',
                health: 500,
                rangeBonus: 2.0,
                damageBonus: 1.7,
                siegeBonus: 2.0,
                upgradeCost: null,
                color: '#606080'
            }
        };
        
        // Gate upgrade tiers
        const GATE_TIERS = {
            1: {
                name: 'Wooden Gate',
                icon: '',
                health: 75,
                upgradeCost: 35,
                color: '#8b5a2b'
            },
            2: {
                name: 'Reinforced Gate',
                icon: '',
                health: 150,
                upgradeCost: 75,
                color: '#808080'
            },
            3: {
                name: 'Iron Gate',
                icon: '',
                health: 250,
                upgradeCost: null,
                color: '#505070'
            }
        };
        
        // Siege weapon types
        const SIEGE_TYPES = {
            scorpion: {
                name: 'Scorpion',
                cost: 75,
                icon: '',
                health: 60,
                damage: 15,
                range: 250,
                fireRate: 1500,
                projectileSpeed: 12,
                projectileSize: 3,
                projectileColor: '#8b4513',
                description: 'Fast bolts, medium damage'
            },
            catapult: {
                name: 'Catapult',
                cost: 125,
                icon: '',
                health: 80,
                damage: 35,
                range: 300,
                fireRate: 3000,
                projectileSpeed: 8,
                projectileSize: 6,
                projectileColor: '#696969',
                areaOfEffect: 30,
                description: 'Slow rocks, area damage'
            },
            onager: {
                name: 'Onager',
                cost: 150,
                icon: '',
                health: 70,
                damage: 25,
                range: 350,
                fireRate: 2500,
                projectileSpeed: 10,
                projectileSize: 5,
                projectileColor: '#ff4500',
                areaOfEffect: 40,
                burning: true,
                description: 'Flaming projectiles, large AoE'
            },
            trebuchet: {
                name: 'Trebuchet',
                cost: 200,
                icon: '',
                health: 100,
                damage: 60,
                range: 450,
                fireRate: 5000,
                projectileSpeed: 7,
                projectileSize: 8,
                projectileColor: '#2f4f4f',
                areaOfEffect: 50,
                description: 'Massive range & damage, very slow'
            }
        };
        
        // Siege weapons array
        let siegeWeapons = [];
        let siegeProjectiles = [];
        
        // Building phase state
        let buildPhase = false;
        let selectedBuildingType = null;
        let selectedSiegeType = null;
        let buildCategory = 'structures'; // 'structures' or 'siege'
        let playerElevated = false;
        let repairMode = false;
        let upgradeMode = false;
        let deleteMode = false;
        let forgeOpen = false;
        let forgeTab = 'weapons';
        const REPAIR_COST_PERCENT = 0.5; // Cost is 50% of the damage amount (based on building tier cost)
        
        function getRepairCost(building) {
            if (!building || building.health >= building.maxHealth) return 0;
            
            const damage = building.maxHealth - building.health;
            const damagePercent = damage / building.maxHealth;
            
            // Get the base cost of the building based on type and tier
            let baseCost = 20; // Default
            const tier = building.wallTier || 1;
            
            if (building.type === 'wall') {
                baseCost = WALL_TIERS[tier].cost;
            } else if (building.type === 'tower') {
                baseCost = TOWER_TIERS[tier].cost;
            } else if (building.type === 'gate') {
                baseCost = GATE_TIERS[tier].cost;
            } else if (building.type === 'forge') {
                baseCost = 100;
            } else if (building.type === 'stable') {
                baseCost = 75;
            }
            
            // Repair cost is a percentage of building cost based on damage
            const repairCost = Math.ceil(baseCost * damagePercent * REPAIR_COST_PERCENT);
            return Math.max(1, repairCost); // Minimum 1 gold
        }
        const DELETE_REFUND = 0.5; // Refund 50% of building cost
        
        // Weapon upgrade costs (per level)
        const WEAPON_UPGRADE_COST = 30;
        // Armor upgrade costs (per level)
        const ARMOR_UPGRADE_COST = 25;
        
        // Horse types available at stable
        const HORSE_TYPES = {
            pony: {
                name: 'Pony',
                icon: '',
                health: 50,
                cost: 50,
                speedBonus: 0.1,
                description: 'Small but sturdy'
            },
            stallion: {
                name: 'Stallion',
                icon: '',
                health: 100,
                cost: 100,
                speedBonus: 0.2,
                description: 'Strong and fast'
            },
            warhorse: {
                name: 'Warhorse',
                icon: '',
                health: 175,
                cost: 175,
                speedBonus: 0.15,
                damageBonus: 5,
                description: 'Trained for battle'
            },
            destrier: {
                name: 'Destrier',
                icon: '',
                health: 250,
                cost: 275,
                speedBonus: 0.25,
                damageBonus: 8,
                description: 'The finest mount'
            }
        };
        
        let stableOpen = false;

        // Weapon base templates with stat ranges for randomization
        const WEAPON_TEMPLATES = {
            // ========== MELEE WEAPONS ==========
            // DAGGERS & KNIVES (Fast, low damage)
            dagger: { 
                name: 'Dagger', 
                baseDamage: 8, damageRange: 3,
                baseFireRate: 250, fireRateRange: 50,
                baseSpeed: 10, speedRange: 2,          
                spread: 0.1, projectiles: 1, 
                color: '#c0c0c0',
                visual: { type: 'melee', weapon: 'Dagger' },
                melee: true, range: 70
            },
            stiletto: { 
                name: 'Stiletto', 
                baseDamage: 10, damageRange: 3,
                baseFireRate: 220, fireRateRange: 40,
                baseSpeed: 10, speedRange: 2,          
                spread: 0.05, projectiles: 1, 
                color: '#d0d0d0',
                visual: { type: 'melee', weapon: 'Dagger' },
                melee: true, range: 65,
                critBonus: 0.15 // Higher crit chance
            },
            dirk: { 
                name: 'Dirk', 
                baseDamage: 11, damageRange: 4,
                baseFireRate: 280, fireRateRange: 50,
                baseSpeed: 10, speedRange: 2,          
                spread: 0.08, projectiles: 1, 
                color: '#b8b8b8',
                visual: { type: 'melee', weapon: 'Dagger' },
                melee: true, range: 75
            },
            // SWORDS (Balanced)
            sword: { 
                name: 'Sword', 
                baseDamage: 15, damageRange: 5,
                baseFireRate: 450, fireRateRange: 100,
                baseSpeed: 9, speedRange: 2,
                spread: 0.05, projectiles: 1, 
                color: '#e8e8e8',
                visual: { type: 'melee', weapon: 'Sword' },
                melee: true, range: 100
            },
            longsword: { 
                name: 'Longsword', 
                baseDamage: 18, damageRange: 6,
                baseFireRate: 520, fireRateRange: 100,
                baseSpeed: 9, speedRange: 2,
                spread: 0.05, projectiles: 1, 
                color: '#e0e0e0',
                visual: { type: 'melee', weapon: 'Sword' },
                melee: true, range: 115
            },
            broadsword: { 
                name: 'Broadsword', 
                baseDamage: 20, damageRange: 6,
                baseFireRate: 550, fireRateRange: 100,
                baseSpeed: 8, speedRange: 2,
                spread: 0.1, projectiles: 1, 
                color: '#d8d8d8',
                visual: { type: 'melee', weapon: 'Sword' },
                melee: true, range: 105,
                cleave: true
            },
            scimitar: { 
                name: 'Scimitar', 
                baseDamage: 14, damageRange: 4,
                baseFireRate: 380, fireRateRange: 80,
                baseSpeed: 10, speedRange: 2,
                spread: 0.08, projectiles: 1, 
                color: '#c9b037',
                visual: { type: 'melee', weapon: 'Sword' },
                melee: true, range: 95
            },
            rapier: { 
                name: 'Rapier', 
                baseDamage: 12, damageRange: 4,
                baseFireRate: 320, fireRateRange: 60,
                baseSpeed: 11, speedRange: 2,
                spread: 0.02, projectiles: 1, 
                color: '#f0f0f0',
                visual: { type: 'melee', weapon: 'Sword' },
                melee: true, range: 120,
                critBonus: 0.1
            },
            falchion: { 
                name: 'Falchion', 
                baseDamage: 17, damageRange: 5,
                baseFireRate: 480, fireRateRange: 100,
                baseSpeed: 9, speedRange: 2,
                spread: 0.1, projectiles: 1, 
                color: '#c0c0c0',
                visual: { type: 'melee', weapon: 'Sword' },
                melee: true, range: 95
            },
            claymore: { 
                name: 'Claymore', 
                baseDamage: 28, damageRange: 8,
                baseFireRate: 750, fireRateRange: 150,
                baseSpeed: 7, speedRange: 2,
                spread: 0.15, projectiles: 1, 
                color: '#b0b0b0',
                visual: { type: 'melee', weapon: 'Sword' },
                melee: true, range: 130,
                cleave: true
            },
            katana: { 
                name: 'Katana', 
                baseDamage: 16, damageRange: 4,
                baseFireRate: 350, fireRateRange: 70,
                baseSpeed: 11, speedRange: 2,
                spread: 0.03, projectiles: 1, 
                color: '#e8e8f0',
                visual: { type: 'melee', weapon: 'Sword' },
                melee: true, range: 110,
                critBonus: 0.12
            },
            // AXES (High damage, slower)
            axe: { 
                name: 'Battle Axe', 
                baseDamage: 25, damageRange: 8,
                baseFireRate: 700, fireRateRange: 150,
                baseSpeed: 8, speedRange: 2,
                spread: 0.2, projectiles: 1, 
                color: '#8b4513',
                visual: { type: 'melee', weapon: 'Axe' },
                melee: true, range: 90,
                cleave: true
            },
            hatchet: { 
                name: 'Hatchet', 
                baseDamage: 14, damageRange: 4,
                baseFireRate: 400, fireRateRange: 80,
                baseSpeed: 9, speedRange: 2,
                spread: 0.15, projectiles: 1, 
                color: '#6b4423',
                visual: { type: 'melee', weapon: 'Axe' },
                melee: true, range: 75
            },
            greataxe: { 
                name: 'Greataxe', 
                baseDamage: 35, damageRange: 10,
                baseFireRate: 900, fireRateRange: 200,
                baseSpeed: 7, speedRange: 2,
                spread: 0.25, projectiles: 1, 
                color: '#5a3a1a',
                visual: { type: 'melee', weapon: 'Axe' },
                melee: true, range: 100,
                cleave: true
            },
            waraxe: { 
                name: 'War Axe', 
                baseDamage: 22, damageRange: 6,
                baseFireRate: 600, fireRateRange: 120,
                baseSpeed: 8, speedRange: 2,
                spread: 0.18, projectiles: 1, 
                color: '#7a5a3a',
                visual: { type: 'melee', weapon: 'Axe' },
                melee: true, range: 85,
                cleave: true
            },
            // MACES & HAMMERS (Stun, armor breaking)
            mace: { 
                name: 'Mace', 
                baseDamage: 20, damageRange: 6,
                baseFireRate: 550, fireRateRange: 100,
                baseSpeed: 8, speedRange: 2,
                spread: 0.15, projectiles: 1, 
                color: '#4a4a4a',
                visual: { type: 'melee', weapon: 'Mace' },
                melee: true, range: 85,
                stun: true
            },
            flail: { 
                name: 'Flail', 
                baseDamage: 22, damageRange: 8,
                baseFireRate: 650, fireRateRange: 150,
                baseSpeed: 7, speedRange: 2,
                spread: 0.25, projectiles: 1, 
                color: '#3a3a3a',
                visual: { type: 'melee', weapon: 'Mace' },
                melee: true, range: 100,
                stun: true
            },
            morningstar: { 
                name: 'Morningstar', 
                baseDamage: 24, damageRange: 7,
                baseFireRate: 600, fireRateRange: 120,
                baseSpeed: 8, speedRange: 2,
                spread: 0.18, projectiles: 1, 
                color: '#5a5a5a',
                visual: { type: 'melee', weapon: 'Mace' },
                melee: true, range: 90,
                stun: true
            },
            warhammer: { 
                name: 'Warhammer', 
                baseDamage: 30, damageRange: 10,
                baseFireRate: 800, fireRateRange: 180,
                baseSpeed: 7, speedRange: 2,
                spread: 0.2, projectiles: 1, 
                color: '#6a6a6a',
                visual: { type: 'melee', weapon: 'Mace' },
                melee: true, range: 95,
                stun: true
            },
            maul: { 
                name: 'Maul', 
                baseDamage: 40, damageRange: 12,
                baseFireRate: 1000, fireRateRange: 200,
                baseSpeed: 6, speedRange: 2,
                spread: 0.3, projectiles: 1, 
                color: '#4a4a4a',
                visual: { type: 'melee', weapon: 'Mace' },
                melee: true, range: 100,
                stun: true,
                cleave: true
            },
            // POLEARMS (Long range melee)
            spear: { 
                name: 'Spear', 
                baseDamage: 16, damageRange: 5,
                baseFireRate: 500, fireRateRange: 100,
                baseSpeed: 9, speedRange: 2,
                spread: 0.05, projectiles: 1, 
                color: '#8b7355',
                visual: { type: 'melee', weapon: 'Spear' },
                melee: true, range: 140
            },
            pike: { 
                name: 'Pike', 
                baseDamage: 18, damageRange: 5,
                baseFireRate: 600, fireRateRange: 120,
                baseSpeed: 8, speedRange: 2,
                spread: 0.03, projectiles: 1, 
                color: '#7a6345',
                visual: { type: 'melee', weapon: 'Spear' },
                melee: true, range: 160
            },
            halberd: { 
                name: 'Halberd', 
                baseDamage: 26, damageRange: 8,
                baseFireRate: 750, fireRateRange: 150,
                baseSpeed: 7, speedRange: 2,
                spread: 0.1, projectiles: 1, 
                color: '#5a5a6a',
                visual: { type: 'melee', weapon: 'Spear' },
                melee: true, range: 135,
                cleave: true
            },
            glaive: { 
                name: 'Glaive', 
                baseDamage: 22, damageRange: 6,
                baseFireRate: 650, fireRateRange: 130,
                baseSpeed: 8, speedRange: 2,
                spread: 0.08, projectiles: 1, 
                color: '#6a6a7a',
                visual: { type: 'melee', weapon: 'Spear' },
                melee: true, range: 130,
                cleave: true
            },
            trident: { 
                name: 'Trident', 
                baseDamage: 20, damageRange: 6,
                baseFireRate: 580, fireRateRange: 100,
                baseSpeed: 8, speedRange: 2,
                spread: 0.06, projectiles: 1, 
                color: '#4a8a9a',
                visual: { type: 'melee', weapon: 'Spear' },
                melee: true, range: 145
            },
            // EXOTIC MELEE
            scythe: { 
                name: 'War Scythe', 
                baseDamage: 28, damageRange: 9,
                baseFireRate: 700, fireRateRange: 140,
                baseSpeed: 8, speedRange: 2,
                spread: 0.2, projectiles: 1, 
                color: '#3a3a3a',
                visual: { type: 'melee', weapon: 'Axe' },
                melee: true, range: 125,
                cleave: true,
                critBonus: 0.08
            },
            club: { 
                name: 'Club', 
                baseDamage: 12, damageRange: 4,
                baseFireRate: 450, fireRateRange: 80,
                baseSpeed: 8, speedRange: 2,
                spread: 0.2, projectiles: 1, 
                color: '#5a4a3a',
                visual: { type: 'melee', weapon: 'Mace' },
                melee: true, range: 80,
                stun: true
            },
            quarterstaff: { 
                name: 'Quarterstaff', 
                baseDamage: 10, damageRange: 3,
                baseFireRate: 350, fireRateRange: 70,
                baseSpeed: 10, speedRange: 2,
                spread: 0.1, projectiles: 1, 
                color: '#8a7a5a',
                visual: { type: 'melee', weapon: 'Spear' },
                melee: true, range: 120
            },
            
            // ========== RANGED WEAPONS ==========
            // BOWS (Balanced ranged)
            bow: { 
                name: 'Bow', 
                baseDamage: 12, damageRange: 4,
                baseFireRate: 600, fireRateRange: 100,
                baseSpeed: 11, speedRange: 3,
                spread: 0.05, projectiles: 1, 
                color: '#deb887',
                visual: { type: 'ranged', weapon: 'Bow' },
                range: 280
            },
            shortbow: { 
                name: 'Shortbow', 
                baseDamage: 9, damageRange: 3,
                baseFireRate: 450, fireRateRange: 80,
                baseSpeed: 12, speedRange: 3,
                spread: 0.08, projectiles: 1, 
                color: '#c9a76a',
                visual: { type: 'ranged', weapon: 'Bow' },
                range: 220
            },
            longbow: { 
                name: 'Longbow', 
                baseDamage: 18, damageRange: 5,
                baseFireRate: 800, fireRateRange: 150,
                baseSpeed: 14, speedRange: 3,
                spread: 0.03, projectiles: 1, 
                color: '#a08050',
                visual: { type: 'ranged', weapon: 'Bow' },
                range: 380
            },
            compositebow: { 
                name: 'Composite Bow', 
                baseDamage: 15, damageRange: 4,
                baseFireRate: 550, fireRateRange: 100,
                baseSpeed: 13, speedRange: 3,
                spread: 0.04, projectiles: 1, 
                color: '#8b7355',
                visual: { type: 'ranged', weapon: 'Bow' },
                range: 320
            },
            recurvebow: { 
                name: 'Recurve Bow', 
                baseDamage: 14, damageRange: 4,
                baseFireRate: 500, fireRateRange: 90,
                baseSpeed: 14, speedRange: 3,
                spread: 0.04, projectiles: 1, 
                color: '#9a8a6a',
                visual: { type: 'ranged', weapon: 'Bow' },
                range: 300
            },
            warbow: { 
                name: 'War Bow', 
                baseDamage: 20, damageRange: 6,
                baseFireRate: 700, fireRateRange: 130,
                baseSpeed: 13, speedRange: 3,
                spread: 0.05, projectiles: 1, 
                color: '#6a5a4a',
                visual: { type: 'ranged', weapon: 'Bow' },
                range: 350,
                pierce: true
            },
            // CROSSBOWS (High damage, slow)
            crossbow: { 
                name: 'Crossbow', 
                baseDamage: 22, damageRange: 7,
                baseFireRate: 1000, fireRateRange: 200,
                baseSpeed: 14, speedRange: 3,
                spread: 0, projectiles: 1, 
                color: '#654321',
                visual: { type: 'ranged', weapon: 'Crossbow' },
                range: 350
            },
            lightcrossbow: { 
                name: 'Light Crossbow', 
                baseDamage: 16, damageRange: 5,
                baseFireRate: 750, fireRateRange: 150,
                baseSpeed: 15, speedRange: 3,
                spread: 0.02, projectiles: 1, 
                color: '#7a6a5a',
                visual: { type: 'ranged', weapon: 'Crossbow' },
                range: 300
            },
            heavycrossbow: { 
                name: 'Heavy Crossbow', 
                baseDamage: 30, damageRange: 9,
                baseFireRate: 1300, fireRateRange: 250,
                baseSpeed: 12, speedRange: 3,
                spread: 0, projectiles: 1, 
                color: '#4a3a2a',
                visual: { type: 'ranged', weapon: 'Crossbow' },
                range: 400,
                pierce: true
            },
            arbalest: { 
                name: 'Arbalest', 
                baseDamage: 35, damageRange: 10,
                baseFireRate: 1500, fireRateRange: 300,
                baseSpeed: 16, speedRange: 3,
                spread: 0, projectiles: 1, 
                color: '#2f4f4f',
                visual: { type: 'ranged', weapon: 'Arbalest' },
                range: 450,
                pierce: true
            },
            repeatingcrossbow: { 
                name: 'Repeating Crossbow', 
                baseDamage: 10, damageRange: 3,
                baseFireRate: 350, fireRateRange: 70,
                baseSpeed: 13, speedRange: 3,
                spread: 0.1, projectiles: 1, 
                color: '#5a4a3a',
                visual: { type: 'ranged', weapon: 'Crossbow' },
                range: 250
            },
            // THROWING WEAPONS
            throwingknife: { 
                name: 'Throwing Knives', 
                baseDamage: 8, damageRange: 3,
                baseFireRate: 300, fireRateRange: 60,
                baseSpeed: 14, speedRange: 3,
                spread: 0.15, projectiles: 2, 
                color: '#c0c0c0',
                visual: { type: 'ranged', weapon: 'ThrowingKnife' },
                range: 180
            },
            throwingaxe: { 
                name: 'Throwing Axes', 
                baseDamage: 14, damageRange: 4,
                baseFireRate: 500, fireRateRange: 100,
                baseSpeed: 11, speedRange: 3,
                spread: 0.12, projectiles: 1, 
                color: '#8b4513',
                visual: { type: 'ranged', weapon: 'ThrowingAxe' },
                range: 200
            },
            javelin: { 
                name: 'Javelins', 
                baseDamage: 18, damageRange: 5,
                baseFireRate: 700, fireRateRange: 120,
                baseSpeed: 13, speedRange: 3,
                spread: 0.05, projectiles: 1, 
                color: '#8b7355',
                visual: { type: 'ranged', weapon: 'Javelin' },
                range: 260,
                pierce: true
            },
            chakram: { 
                name: 'Chakram', 
                baseDamage: 11, damageRange: 3,
                baseFireRate: 400, fireRateRange: 80,
                baseSpeed: 15, speedRange: 3,
                spread: 0.08, projectiles: 1, 
                color: '#d4af37',
                visual: { type: 'ranged', weapon: 'Chakram' },
                range: 220
            },
            bolas: { 
                name: 'Bolas', 
                baseDamage: 6, damageRange: 2,
                baseFireRate: 600, fireRateRange: 100,
                baseSpeed: 10, speedRange: 2,
                spread: 0.15, projectiles: 1, 
                color: '#5a5a5a',
                visual: { type: 'ranged', weapon: 'Bolas' },
                range: 160,
                stun: true
            },
            // SLINGS
            sling: { 
                name: 'Sling', 
                baseDamage: 10, damageRange: 4,
                baseFireRate: 500, fireRateRange: 100,
                baseSpeed: 12, speedRange: 3,
                spread: 0.12, projectiles: 1, 
                color: '#8a7a5a',
                visual: { type: 'ranged', weapon: 'Sling' },
                range: 200
            },
            staffsling: { 
                name: 'Staff Sling', 
                baseDamage: 16, damageRange: 5,
                baseFireRate: 650, fireRateRange: 120,
                baseSpeed: 14, speedRange: 3,
                spread: 0.08, projectiles: 1, 
                color: '#7a6a4a',
                visual: { type: 'ranged', weapon: 'Sling' },
                range: 280
            },
            // EXOTIC RANGED
            blowgun: { 
                name: 'Blowgun', 
                baseDamage: 5, damageRange: 2,
                baseFireRate: 350, fireRateRange: 70,
                baseSpeed: 16, speedRange: 3,
                spread: 0.02, projectiles: 1, 
                color: '#4a6a4a',
                visual: { type: 'ranged', weapon: 'Blowgun' },
                range: 200,
                poison: true // Damage over time
            },
            handcannon: { 
                name: 'Hand Cannon', 
                baseDamage: 45, damageRange: 15,
                baseFireRate: 2000, fireRateRange: 400,
                baseSpeed: 10, speedRange: 2,
                spread: 0.2, projectiles: 1, 
                color: '#3a3a3a',
                visual: { type: 'ranged', weapon: 'HandCannon' },
                range: 250
            },
            firelancea: { 
                name: 'Fire Lance', 
                baseDamage: 25, damageRange: 8,
                baseFireRate: 1200, fireRateRange: 200,
                baseSpeed: 8, speedRange: 2,
                spread: 0.3, projectiles: 3, 
                color: '#8b4513',
                visual: { type: 'ranged', weapon: 'FireLance' },
                range: 150,
                burning: true
            }
        };
        
        // Generate a randomized weapon from a template
        function generateRandomWeapon(templateKey) {
            const template = WEAPON_TEMPLATES[templateKey];
            
            // Randomize stats within range (can be + or -)
            const damageVariance = Math.floor(Math.random() * (template.damageRange * 2 + 1)) - template.damageRange;
            const fireRateVariance = Math.floor(Math.random() * (template.fireRateRange * 2 + 1)) - template.fireRateRange;
            const speedVariance = Math.floor(Math.random() * (template.speedRange * 2 + 1)) - template.speedRange;
            
            const damage = Math.max(1, template.baseDamage + damageVariance);
            const fireRate = Math.max(50, template.baseFireRate + fireRateVariance);
            const projectileSpeed = Math.max(4, template.baseSpeed + speedVariance);
            
            // Calculate quality rating based on how good the rolls are
            const damageQuality = (damage - (template.baseDamage - template.damageRange)) / (template.damageRange * 2);
            const fireRateQuality = ((template.baseFireRate + template.fireRateRange) - fireRate) / (template.fireRateRange * 2);
            const speedQuality = (projectileSpeed - (template.baseSpeed - template.speedRange)) / (template.speedRange * 2);
            const avgQuality = (damageQuality + fireRateQuality + speedQuality) / 3;
            
            // Determine rarity based on quality
            let rarity, rarityColor, namePrefix;
            if (avgQuality >= 0.8) {
                rarity = 'legendary';
                rarityColor = '#ffd700';
                namePrefix = 'Legendary ';
            } else if (avgQuality >= 0.6) {
                rarity = 'rare';
                rarityColor = '#a855f7';
                namePrefix = 'Superior ';
            } else if (avgQuality >= 0.4) {
                rarity = 'uncommon';
                rarityColor = '#3b82f6';
                namePrefix = 'Fine ';
            } else {
                rarity = 'common';
                rarityColor = '#9ca3af';
                namePrefix = '';
            }
            
            return {
                name: namePrefix + template.name,
                baseName: template.name,
                damage: damage,
                fireRate: fireRate,
                projectileSpeed: projectileSpeed,
                spread: template.spread,
                projectiles: template.projectiles,
                color: template.color,
                visual: { ...template.visual, weapon: template.name },
                rarity: rarity,
                rarityColor: rarityColor,
                melee: template.melee || false,
                range: template.range || 0,
                cleave: template.cleave || false,
                stun: template.stun || false,
                pierce: template.pierce || false
            };
        }
        
        // Starting melee weapon
        const STARTING_MELEE_WEAPON = {
            name: 'Rusty Sword',
            baseName: 'Sword',
            damage: 12,
            fireRate: 500,
            projectileSpeed: 9,
            spread: 0.05,
            projectiles: 1,
            color: '#a0a0a0',
            visual: { type: 'melee', weapon: 'Sword' },
            melee: true,
            range: 100,
            rarity: 'common',
            rarityColor: '#9ca3af'
        };
        
        // Starting ranged weapon
        const STARTING_RANGED_WEAPON = {
            name: 'Old Bow',
            baseName: 'Bow',
            damage: 10,
            fireRate: 650,
            projectileSpeed: 10,
            spread: 0.08,
            projectiles: 1,
            color: '#deb887',
            visual: { type: 'ranged', weapon: 'Bow' },
            melee: false,
            range: 250,
            rarity: 'common',
            rarityColor: '#9ca3af'
        };

        // Armor grades (rarity)
        const ARMOR_GRADES = {
            common: { name: 'Common', color: '#9ca3af', multiplier: 1.0 },
            uncommon: { name: 'Uncommon', color: '#22c55e', multiplier: 1.15 },
            rare: { name: 'Rare', color: '#3b82f6', multiplier: 1.3 },
            epic: { name: 'Epic', color: '#a855f7', multiplier: 1.5 },
            legendary: { name: 'Legendary', color: '#ffd700', multiplier: 1.8 }
        };
        
        // Armor base types per slot
        const ARMOR_BASES = {
            head: [
                { name: 'Cap', baseArmor: 3, icon: '' },
                { name: 'Helm', baseArmor: 5, icon: '' },
                { name: 'Great Helm', baseArmor: 7, icon: '' },
                { name: 'Crown', baseArmor: 4, icon: '', bonusType: 'xpBonus' }
            ],
            body: [
                { name: 'Vest', baseArmor: 8, icon: '' },
                { name: 'Mail', baseArmor: 12, icon: '' },
                { name: 'Plate', baseArmor: 18, icon: '' },
                { name: 'Royal Armor', baseArmor: 15, icon: '', bonusType: 'damageReduction' }
            ],
            arms: [
                { name: 'Bracers', baseArmor: 2, icon: '' },
                { name: 'Vambraces', baseArmor: 4, icon: '' },
                { name: 'Gauntlets', baseArmor: 5, icon: '', bonusType: 'attackSpeed' }
            ],
            legs: [
                { name: 'Leggings', baseArmor: 4, icon: '' },
                { name: 'Greaves', baseArmor: 7, icon: '' },
                { name: 'Cuisses', baseArmor: 9, icon: '', bonusType: 'moveSpeed' }
            ],
            feet: [
                { name: 'Shoes', baseArmor: 2, icon: '' },
                { name: 'Boots', baseArmor: 3, icon: '' },
                { name: 'Sabatons', baseArmor: 5, icon: '', bonusType: 'moveSpeed' }
            ],
            belt: [
                { name: 'Sash', baseArmor: 1, icon: '' },
                { name: 'Belt', baseArmor: 2, icon: '' },
                { name: 'Girdle', baseArmor: 3, icon: '', bonusType: 'bountyBonus' }
            ]
        };
        
        // Bonus values by type
        const ARMOR_BONUS_VALUES = {
            xpBonus: { base: 0.05, perLevel: 0.02 },
            damageReduction: { base: 0.03, perLevel: 0.01 },
            attackSpeed: { base: 10, perLevel: 5 },
            moveSpeed: { base: 0.05, perLevel: 0.02 },
            bountyBonus: { base: 0.05, perLevel: 0.02 },
            healthRegen: { base: 0.5, perLevel: 0.25 },
            critChance: { base: 0.03, perLevel: 0.01 }
        };

        // Generate armor drop with level and grade
        function generateArmorDrop() {
            const slots = Object.keys(ARMOR_BASES);
            const slot = slots[Math.floor(Math.random() * slots.length)];
            const bases = ARMOR_BASES[slot];
            const base = bases[Math.floor(Math.random() * bases.length)];
            
            // Level based on wave (1-10)
            const minLevel = Math.max(1, Math.floor(wave / 2));
            const maxLevel = Math.min(10, minLevel + 3);
            const level = minLevel + Math.floor(Math.random() * (maxLevel - minLevel + 1));
            
            // Grade based on random roll (higher waves = better chance)
            const gradeRoll = Math.random() + (wave * 0.02);
            let grade;
            if (gradeRoll < 0.5) grade = 'common';
            else if (gradeRoll < 0.75) grade = 'uncommon';
            else if (gradeRoll < 0.9) grade = 'rare';
            else if (gradeRoll < 0.98) grade = 'epic';
            else grade = 'legendary';
            
            const gradeData = ARMOR_GRADES[grade];
            
            // Calculate armor value
            const armor = Math.round(base.baseArmor * (1 + (level - 1) * 0.2) * gradeData.multiplier);
            
            // Calculate bonus if applicable
            let bonus = {};
            if (base.bonusType) {
                const bonusData = ARMOR_BONUS_VALUES[base.bonusType];
                bonus[base.bonusType] = bonusData.base + bonusData.perLevel * (level - 1);
            }
            
            // Grade-specific extra bonuses for epic/legendary
            if (grade === 'epic' || grade === 'legendary') {
                const extraBonuses = Object.keys(ARMOR_BONUS_VALUES);
                const extraBonus = extraBonuses[Math.floor(Math.random() * extraBonuses.length)];
                if (!bonus[extraBonus]) {
                    const bonusData = ARMOR_BONUS_VALUES[extraBonus];
                    bonus[extraBonus] = (bonusData.base + bonusData.perLevel * (level - 1)) * (grade === 'legendary' ? 0.7 : 0.4);
                }
            }
            
            // Build name
            const gradeName = grade !== 'common' ? gradeData.name + ' ' : '';
            const name = `${gradeName}${base.name} +${level}`;
            
            return {
                slot: slot,
                baseName: base.name,
                name: name,
                level: level,
                grade: grade,
                armor: armor,
                color: gradeData.color,
                bonus: bonus,
                icon: base.icon
            };
        }
        
        // Calculate armor score for comparison
        function getArmorScore(armorPiece) {
            if (!armorPiece) return 0;
            let score = armorPiece.armor;
            // Add bonus value to score
            for (let bonus in armorPiece.bonus) {
                score += armorPiece.bonus[bonus] * 10;
            }
            return score;
        }
        
        // Format bonus for display
        function formatBonus(bonusType, value) {
            switch(bonusType) {
                case 'xpBonus': return `+${Math.round(value * 100)}% XP`;
                case 'damageReduction': return `+${Math.round(value * 100)}% DR`;
                case 'attackSpeed': return `+${Math.round(value)} Atk Spd`;
                case 'moveSpeed': return `+${Math.round(value * 100)}% Move`;
                case 'bountyBonus': return `+${Math.round(value * 100)}% Gold`;
                case 'healthRegen': return `+${value.toFixed(1)} HP/s`;
                case 'critChance': return `+${Math.round(value * 100)}% Crit`;
                default: return `+${value}`;
            }
        }

        // Game state
        let canvas, ctx;
        let gameState = 'menu';
        let player, enemies, projectiles, drops, particles;
        let wave = 1;
        let kills = 0;
        let bounty = 0;
        let totalBountyEarned = 0; // Track total gold earned (not spent)
        let lastShot = 0;
        let spawnTimer = 0;
        let waveTimer = 0;
        let nearbyDrop = null;
        let keys = {};
        let isMobile = false;
        let joystickInput = { x: 0, y: 0 };
        let lastRegenTick = 0;
        let isPaused = false;
        let pendingWeapon = null;
        let pendingWeaponIndex = -1;
        let pendingWeaponSlot = 'melee'; // 'melee' or 'ranged'
        let pendingArmor = null;
        let pendingArmorIndex = -1;
        let isBossWave = false;
        let bossSpawned = false;
        let bossDefeated = false;
        
        // Terrain elements
        let terrainElements = [];
        let grassPatches = [];
        let dirtPatches = [];
        
        function generateTerrain() {
            terrainElements = [];
            grassPatches = [];
            dirtPatches = [];
            
            // Generate random grass color variations for ground
            for (let i = 0; i < 800; i++) {
                grassPatches.push({
                    x: Math.random() * WORLD_WIDTH,
                    y: Math.random() * WORLD_HEIGHT,
                    radius: 20 + Math.random() * 40,
                    color: Math.random() > 0.5 ? '#3d5c2d' : '#4a6b3a'
                });
            }
            
            // Generate dirt patches
            for (let i = 0; i < 40; i++) {
                dirtPatches.push({
                    x: Math.random() * WORLD_WIDTH,
                    y: Math.random() * WORLD_HEIGHT,
                    radiusX: 30 + Math.random() * 80,
                    radiusY: 20 + Math.random() * 50,
                    rotation: Math.random() * Math.PI
                });
            }
            
            // Generate trees (avoid center where player spawns)
            for (let i = 0; i < 60; i++) {
                let x, y;
                do {
                    x = Math.random() * WORLD_WIDTH;
                    y = Math.random() * WORLD_HEIGHT;
                } while (Math.abs(x - WORLD_WIDTH/2) < 300 && Math.abs(y - WORLD_HEIGHT/2) < 300);
                
                terrainElements.push({
                    type: 'tree',
                    x: x,
                    y: y,
                    size: 0.8 + Math.random() * 0.6,
                    variant: Math.floor(Math.random() * 3) // 3 tree variants
                });
            }
            
            // Generate rocks
            for (let i = 0; i < 80; i++) {
                let x, y;
                do {
                    x = Math.random() * WORLD_WIDTH;
                    y = Math.random() * WORLD_HEIGHT;
                } while (Math.abs(x - WORLD_WIDTH/2) < 200 && Math.abs(y - WORLD_HEIGHT/2) < 200);
                
                terrainElements.push({
                    type: 'rock',
                    x: x,
                    y: y,
                    size: 0.5 + Math.random() * 1,
                    variant: Math.floor(Math.random() * 3)
                });
            }
            
            // Generate bushes
            for (let i = 0; i < 100; i++) {
                terrainElements.push({
                    type: 'bush',
                    x: Math.random() * WORLD_WIDTH,
                    y: Math.random() * WORLD_HEIGHT,
                    size: 0.6 + Math.random() * 0.6
                });
            }
            
            // Generate grass tufts
            for (let i = 0; i < 200; i++) {
                terrainElements.push({
                    type: 'grass_tuft',
                    x: Math.random() * WORLD_WIDTH,
                    y: Math.random() * WORLD_HEIGHT,
                    size: 0.5 + Math.random() * 0.5
                });
            }
            
            // Generate flowers
            for (let i = 0; i < 60; i++) {
                terrainElements.push({
                    type: 'flower',
                    x: Math.random() * WORLD_WIDTH,
                    y: Math.random() * WORLD_HEIGHT,
                    color: ['#ff6b6b', '#ffd93d', '#6bcb77', '#4d96ff', '#ff8fab'][Math.floor(Math.random() * 5)]
                });
            }
            
            // Sort by Y position for proper layering
            terrainElements.sort((a, b) => a.y - b.y);
        }

        // Initialize
        function init() {
            canvas = document.getElementById('game');
            ctx = canvas.getContext('2d');
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // Input handlers
            window.addEventListener('keydown', e => {
                keys[e.key.toLowerCase()] = true;
                if (e.key === ' ' && nearbyDrop && !buildPhase) {
                    pickupDrop(nearbyDrop);
                    e.preventDefault();
                }
                // Number keys to select building type during build phase
                if (buildPhase) {
                    if (e.key === '1') selectBuilding('wall');
                    if (e.key === '2') selectBuilding('tower');
                    if (e.key === '3') selectBuilding('gate');
                    if (e.key === '4') selectBuilding('ladder');
                    if (e.key === '5') selectRepairMode();
                    if (e.key === '6') selectBuilding('forge');
                    if (e.key === '7') selectBuilding('stable');
                    if ((e.key === 'f' || e.key === 'F') && checkForgeInteraction()) {
                        openForge();
                        e.preventDefault();
                    }
                    if ((e.key === 'h' || e.key === 'H') && checkStableInteraction()) {
                        openStable();
                        e.preventDefault();
                    }
                    if (e.key === 'Enter') {
                        endBuildPhase();
                        e.preventDefault();
                    }
                }
                // Close forge or stable with Escape
                if (forgeOpen && e.key === 'Escape') {
                    closeForge();
                    e.preventDefault();
                }
                if (stableOpen && e.key === 'Escape') {
                    closeStable();
                    e.preventDefault();
                }
            });
            window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
            
            // Canvas click for building placement or repair
            canvas.addEventListener('click', e => {
                if (!buildPhase) return;
                
                const rect = canvas.getBoundingClientRect();
                const scaleX = GAME_WIDTH / rect.width;
                const scaleY = GAME_HEIGHT / rect.height;
                const canvasX = (e.clientX - rect.left) * scaleX;
                const canvasY = (e.clientY - rect.top) * scaleY;
                
                // Convert to world coordinates
                const worldX = canvasX + camera.x;
                const worldY = canvasY + camera.y;
                
                if (repairMode) {
                    repairBuilding(worldX, worldY);
                } else if (upgradeMode) {
                    upgradeWall(worldX, worldY);
                } else if (deleteMode) {
                    deleteBuilding(worldX, worldY);
                } else if (selectedBuildingType) {
                    placeBuilding(worldX, worldY);
                } else if (selectedSiegeType) {
                    placeSiegeWeapon(worldX, worldY);
                }
            });
            
            // Track mouse for build preview
            canvas.addEventListener('mousemove', e => {
                const rect = canvas.getBoundingClientRect();
                const scaleX = GAME_WIDTH / rect.width;
                const scaleY = GAME_HEIGHT / rect.height;
                const canvasX = (e.clientX - rect.left) * scaleX;
                const canvasY = (e.clientY - rect.top) * scaleY;
                
                mouseWorldPos = {
                    x: canvasX + camera.x,
                    y: canvasY + camera.y
                };
            });
            
            canvas.addEventListener('mouseleave', () => {
                mouseWorldPos = null;
            });
            
            // Check for mobile
            isMobile = 'ontouchstart' in window;
            if (isMobile) {
                setupMobileControls();
            }
            
            // Menu buttons
            document.getElementById('start-btn').addEventListener('click', startGame);
            document.getElementById('restart-btn').addEventListener('click', startGame);
            
            // Start game loop
            requestAnimationFrame(gameLoop);
        }

        function resizeCanvas() {
            const container = document.getElementById('game-container');
            const scale = Math.min(container.clientWidth / GAME_WIDTH, container.clientHeight / GAME_HEIGHT);
            canvas.width = GAME_WIDTH;
            canvas.height = GAME_HEIGHT;
            canvas.style.width = `${GAME_WIDTH * scale}px`;
            canvas.style.height = `${GAME_HEIGHT * scale}px`;
        }

        function setupMobileControls() {
            const controls = document.getElementById('mobile-controls');
            const joystick = document.getElementById('joystick-left');
            const inner = document.getElementById('joystick-left-inner');
            
            let touchId = null;
            let centerX, centerY;
            
            joystick.addEventListener('touchstart', e => {
                e.preventDefault();
                const touch = e.touches[0];
                touchId = touch.identifier;
                const rect = joystick.getBoundingClientRect();
                centerX = rect.left + rect.width / 2;
                centerY = rect.top + rect.height / 2;
            });
            
            window.addEventListener('touchmove', e => {
                for (let touch of e.touches) {
                    if (touch.identifier === touchId) {
                        const dx = touch.clientX - centerX;
                        const dy = touch.clientY - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const maxDist = 40;
                        
                        if (dist > 0) {
                            const clampedDist = Math.min(dist, maxDist);
                            joystickInput.x = (dx / dist) * (clampedDist / maxDist);
                            joystickInput.y = (dy / dist) * (clampedDist / maxDist);
                            
                            inner.style.transform = `translate(calc(-50% + ${joystickInput.x * maxDist}px), calc(-50% + ${joystickInput.y * maxDist}px))`;
                        }
                    }
                }
            });
            
            window.addEventListener('touchend', e => {
                for (let touch of e.changedTouches) {
                    if (touch.identifier === touchId) {
                        touchId = null;
                        joystickInput.x = 0;
                        joystickInput.y = 0;
                        inner.style.transform = 'translate(-50%, -50%)';
                    }
                }
            });
        }

        function startGame() {
            gameState = 'playing';
            wave = 1;
            kills = 0;
            bounty = 0;
            totalBountyEarned = 0;
            
            // Ensure bounty is definitely a number
            if (typeof bounty !== 'number' || isNaN(bounty)) {
                bounty = 0;
            }
            
            player = {
                x: WORLD_WIDTH / 2,
                y: WORLD_HEIGHT / 2,
                radius: 20,
                speed: 3,
                health: 100,
                maxHealth: 100,
                armor: 0,
                maxArmor: 50,
                xp: 0,
                xpToLevel: 50,
                level: 1,
                meleeWeapon: { ...STARTING_MELEE_WEAPON },
                rangedWeapon: { ...STARTING_RANGED_WEAPON },
                armorVisual: null,
                aimAngle: 0,
                walkCycle: 0,
                isMoving: false,
                facingRight: true,
                // Armor slots
                armorSlots: {
                    head: null,
                    body: null,
                    arms: null,
                    legs: null,
                    feet: null,
                    belt: null
                },
                // Upgradeable stats (flat values)
                healthRegen: 0,        // HP per second
                bonusDamage: 0,        // Flat damage added to attacks
                attackSpeed: 0,        // Reduces fire rate delay in ms
                bonusArmor: 0,         // Flat armor added
                goldBonus: 0,          // % increase to gold earned
                xpBonus: 0,            // % increase to XP earned
                critChance: 5,         // Base 5% crit chance
                critDamage: 150,       // Base 150% crit damage
                // Stat point tracking
                statPoints: 0,
                pendingPoints: 0,
                // Stat levels for UI
                statLevels: {
                    vitality: 0,       // +12 max health per point
                    recovery: 0,       // +0.4 health regen per point
                    strength: 0,       // +2 damage per point
                    dexterity: 0,      // Attack Speed: -15ms fire delay per point
                    toughness: 0,      // +8 max armor per point
                    fortune: 0,        // +5% gold per point
                    wisdom: 0,         // +5% XP per point
                    precision: 0,      // +2% crit chance per point
                    ferocity: 0        // +10% crit damage per point
                },
                // Horse mount
                horse: null
            };
            
            lastRegenTick = Date.now();
            
            // Initialize camera to center on player
            camera.x = player.x - GAME_WIDTH / 2;
            camera.y = player.y - GAME_HEIGHT / 2;
            
            enemies = [];
            projectiles = [];
            drops = [];
            particles = [];
            buildings = [];
            siegeWeapons = [];
            siegeProjectiles = [];
            spawnTimer = 0;
            waveTimer = 0;
            buildPhase = false;
            selectedBuildingType = null;
            selectedSiegeType = null;
            buildCategory = 'structures';
            mouseWorldPos = null;
            playerElevated = false;
            repairMode = false;
            
            // Generate terrain
            generateTerrain();
            
            document.getElementById('menu-screen').classList.add('hidden');
            document.getElementById('game-over-screen').classList.add('hidden');
            document.getElementById('hud').classList.remove('hidden');
            document.getElementById('build-phase-ui').classList.add('hidden');
            document.getElementById('damaged-buildings-info').classList.add('hidden');
            if (isMobile) {
                document.getElementById('mobile-controls').classList.remove('hidden');
            }
        }

        function gameOver() {
            gameState = 'gameover';
            document.getElementById('hud').classList.add('hidden');
            document.getElementById('mobile-controls').classList.add('hidden');
            document.getElementById('build-phase-ui').classList.add('hidden');
            document.getElementById('building-status').classList.add('hidden');
            document.getElementById('game-over-screen').classList.remove('hidden');
            document.getElementById('final-bounty').textContent = `$${totalBountyEarned}`;
            document.getElementById('final-wave').textContent = wave;
            document.getElementById('final-kills').textContent = kills;
        }

        function gameLoop(timestamp) {
            if (gameState === 'playing' && !isPaused) {
                update(timestamp);
            }
            render();
            requestAnimationFrame(gameLoop);
        }

        function update(timestamp) {
            // Player movement
            let dx = 0, dy = 0;
            if (keys['w'] || keys['arrowup']) dy -= 1;
            if (keys['s'] || keys['arrowdown']) dy += 1;
            if (keys['a'] || keys['arrowleft']) dx -= 1;
            if (keys['d'] || keys['arrowright']) dx += 1;
            
            // Add joystick input
            dx += joystickInput.x;
            dy += joystickInput.y;
            
            // Normalize
            const len = Math.sqrt(dx * dx + dy * dy);
            if (len > 0) {
                dx /= len;
                dy /= len;
                player.isMoving = true;
                player.walkCycle += 0.3;
                if (dx !== 0) player.facingRight = dx > 0;
            } else {
                player.isMoving = false;
            }
            
            // Calculate new position
            const newX = player.x + dx * player.speed;
            const newY = player.y + dy * player.speed;
            
            // Check building collision for player
            const currentGrid = worldToGrid(player.x, player.y);
            const newGridX = worldToGrid(newX, player.y);
            const newGridY = worldToGrid(player.x, newY);
            
            // Check if player is currently elevated (on wall/tower)
            const currentBuilding = getBuildingAt(currentGrid.gx, currentGrid.gy);
            const isOnClimbable = currentBuilding && currentBuilding.climbable && playerElevated;
            
            // Check X movement
            const buildingX = getBuildingAt(newGridX.gx, newGridX.gy);
            let canMoveX = true;
            
            if (isOnClimbable) {
                // Currently elevated - can only move to adjacent climbable OR ladder/gate
                if (newGridX.gx !== currentGrid.gx) {
                    if (buildingX && buildingX.climbable) {
                        canMoveX = true; // Can walk on connected walls/towers
                    } else if (buildingX && (buildingX.isLadder || buildingX.type === 'gate')) {
                        canMoveX = true; // Can exit via ladder or gate
                    } else if (hasAdjacentExit(newGridX.gx, newGridX.gy)) {
                        canMoveX = true; // Ground tile adjacent to ladder/gate
                    } else {
                        canMoveX = false; // Can't just walk off the wall
                    }
                }
            } else {
                // On ground - check if building blocks us
                if (buildingX && buildingX.blockPlayer) {
                    // Check if there's an adjacent ladder or gate allowing climb
                    if (!canClimbTo(newGridX.gx, newGridX.gy)) {
                        canMoveX = false;
                    }
                }
            }
            
            // Check Y movement
            const buildingY = getBuildingAt(newGridY.gx, newGridY.gy);
            let canMoveY = true;
            
            if (isOnClimbable) {
                // Currently elevated - can only move to adjacent climbable OR ladder/gate
                if (newGridY.gy !== currentGrid.gy) {
                    if (buildingY && buildingY.climbable) {
                        canMoveY = true; // Can walk on connected walls/towers
                    } else if (buildingY && (buildingY.isLadder || buildingY.type === 'gate')) {
                        canMoveY = true; // Can exit via ladder or gate
                    } else if (hasAdjacentExit(newGridY.gx, newGridY.gy)) {
                        canMoveY = true; // Ground tile adjacent to ladder/gate
                    } else {
                        canMoveY = false; // Can't just walk off the wall
                    }
                }
            } else {
                // On ground - check if building blocks us
                if (buildingY && buildingY.blockPlayer) {
                    if (!canClimbTo(newGridY.gx, newGridY.gy)) {
                        canMoveY = false;
                    }
                }
            }
            
            // Apply movement
            if (canMoveX) player.x = newX;
            if (canMoveY) player.y = newY;
            
            // Update elevation status
            const newGrid = worldToGrid(player.x, player.y);
            const standingOn = getBuildingAt(newGrid.gx, newGrid.gy);
            
            if (standingOn && standingOn.climbable) {
                // On a wall/tower - become elevated if coming from ladder/gate or already elevated
                if (hasAdjacentLadderOrGate(newGrid.gx, newGrid.gy) || playerElevated) {
                    playerElevated = true;
                }
            } else if (standingOn && (standingOn.isLadder || standingOn.type === 'gate')) {
                // On a ladder or gate - not elevated but can access walls
                playerElevated = false;
            } else {
                // On regular ground
                playerElevated = false;
            }
            
            // Clamp to bounds
            player.x = Math.max(player.radius, Math.min(WORLD_WIDTH - player.radius, player.x));
            player.y = Math.max(player.radius, Math.min(WORLD_HEIGHT - player.radius, player.y));
            
            // Update camera to follow player
            camera.x = player.x - GAME_WIDTH / 2;
            camera.y = player.y - GAME_HEIGHT / 2;
            // Clamp camera to world bounds
            camera.x = Math.max(0, Math.min(WORLD_WIDTH - GAME_WIDTH, camera.x));
            camera.y = Math.max(0, Math.min(WORLD_HEIGHT - GAME_HEIGHT, camera.y));
            
            // Health regeneration (base + building bonus)
            const buildingStatus = getPlayerBuildingStatus();
            const totalRegen = player.healthRegen + buildingStatus.healthRegen;
            if (totalRegen > 0 && timestamp - lastRegenTick >= 1000) {
                player.health = Math.min(player.health + totalRegen, player.maxHealth);
                lastRegenTick = timestamp;
            }
            
            // Update building status display
            updateBuildingStatus();
            
            // Get current weapon based on elevation (ranged only when elevated)
            const currentWeapon = getCurrentWeapon();
            
            // Auto-aim and shoot (with flat attack speed bonus reducing delay)
            const adjustedFireRate = Math.max(50, currentWeapon.fireRate - player.attackSpeed);
            if (enemies.length > 0 && timestamp - lastShot > adjustedFireRate) {
                const nearest = findNearestEnemy();
                if (nearest) {
                    shoot(nearest, timestamp);
                    lastShot = timestamp;
                }
            }
            
            // Spawn enemies - faster spawn rate, more enemies per wave
            // Only spawn during the first 30 seconds of the wave
            spawnTimer += 16;
            const spawnRate = Math.max(300, 1500 - wave * 120); // Faster spawns
            
            // Check if this is a boss wave (every 5th wave)
            isBossWave = (wave % 5 === 0);
            
            if (isBossWave) {
                // Boss wave - spawn only the boss once
                if (!bossSpawned && !buildPhase) {
                    spawnBoss();
                    bossSpawned = true;
                }
            } else {
                // Normal wave spawning
                if (spawnTimer > spawnRate && !buildPhase && waveTimer <= 30000) {
                    spawnEnemy();
                    // Chance to spawn additional enemy in later waves
                    if (wave >= 3 && Math.random() < 0.3) {
                        spawnEnemy();
                    }
                    if (wave >= 6 && Math.random() < 0.2) {
                        spawnEnemy();
                    }
                    spawnTimer = 0;
                }
            }
            
            // Wave progression - enter build phase when spawning complete AND all enemies defeated
            waveTimer += 16;
            let waveSpawningComplete = isBossWave ? bossSpawned : (waveTimer > 30000);
            if (waveSpawningComplete && enemies.length === 0 && !buildPhase) {
                // Check if boss was defeated this wave
                if (isBossWave && bossSpawned) {
                    bossDefeated = true;
                }
                startBuildPhase();
            }
            
            // Update enemies
            updateEnemies();
            
            // Update projectiles
            updateProjectiles();
            
            // Update melee swing animation
            updateMeleeSwing();
            
            // Update siege weapons
            updateSiegeWeapons(timestamp);
            
            // Update particles
            updateParticles();
            
            // Check drops
            checkDrops();
            
            // Update HUD
            updateHUD();
        }

        function findNearestEnemy() {
            let nearest = null;
            let minDist = Infinity;
            
            for (let enemy of enemies) {
                const dist = distance(player, enemy);
                if (dist < minDist) {
                    minDist = dist;
                    nearest = enemy;
                }
            }
            
            return nearest;
        }
        
        // Get the current active weapon based on player state and enemy proximity
        function getCurrentWeapon() {
            // Safety check if player not initialized
            if (!player || !player.meleeWeapon || !player.rangedWeapon) {
                return STARTING_MELEE_WEAPON;
            }
            
            // When elevated, only ranged weapons work
            if (playerElevated) {
                return player.rangedWeapon;
            }
            
            // Safety check if enemies not initialized
            if (!enemies || enemies.length === 0) {
                return player.rangedWeapon;
            }
            
            // On ground, check if any enemy is in melee range
            const meleeRange = player.meleeWeapon.range || 100;
            let enemyInMeleeRange = false;
            
            for (let enemy of enemies) {
                const dist = distance(player, enemy);
                if (dist <= meleeRange + enemy.radius) {
                    enemyInMeleeRange = true;
                    break;
                }
            }
            
            // Use melee if enemy close, otherwise ranged
            if (enemyInMeleeRange) {
                return player.meleeWeapon;
            }
            return player.rangedWeapon;
        }

        function shoot(target, timestamp) {
            const weapon = getCurrentWeapon();
            const distToTarget = distance(player, target);
            const baseAngle = Math.atan2(target.y - player.y, target.x - player.x);
            player.aimAngle = baseAngle;
            player.facingRight = Math.cos(baseAngle) >= 0;
            
            // Get building bonuses
            const buildingStatus = getPlayerBuildingStatus();
            
            // Calculate damage with flat bonus and building multiplier
            const totalDamage = Math.round((weapon.damage + player.bonusDamage) * buildingStatus.damageBonus);
            
            // Get weapon range (with building bonus for ranged)
            const weaponRange = (weapon.range || 300) * (weapon.melee ? 1 : buildingStatus.rangeBonus);
            
            // Check if target is in range
            if (distToTarget > weaponRange) {
                return; // Target out of range, don't attack
            }
            
            if (weapon.melee) {
                // MELEE ATTACK - swing the weapon
                meleeSwing(baseAngle, totalDamage, weapon);
            } else {
                // RANGED ATTACK - fire projectile
                const boostedSpeed = weapon.projectileSpeed * buildingStatus.rangeBonus;
                
                for (let i = 0; i < weapon.projectiles; i++) {
                    const spreadAngle = (Math.random() - 0.5) * weapon.spread;
                    const angle = baseAngle + spreadAngle;
                    
                    // Calculate crit for this projectile
                    const critChance = player.critChance || 5;
                    const critDamage = player.critDamage || 150;
                    const isCrit = Math.random() * 100 < critChance;
                    const projDamage = isCrit ? Math.floor(totalDamage * (critDamage / 100)) : totalDamage;
                    
                    projectiles.push({
                        x: player.x,
                        y: player.y,
                        vx: Math.cos(angle) * boostedSpeed,
                        vy: Math.sin(angle) * boostedSpeed,
                        damage: projDamage,
                        color: isCrit ? '#ffff00' : weapon.color,
                        radius: isCrit ? 6 : 4,
                        maxRange: weaponRange,
                        distanceTraveled: 0,
                        pierce: weapon.pierce || false,
                        isCrit: isCrit
                    });
                }
                
                // Arrow/bolt particles
                for (let i = 0; i < 3; i++) {
                    particles.push({
                        x: player.x + Math.cos(baseAngle) * 20,
                        y: player.y + Math.sin(baseAngle) * 20,
                        vx: Math.cos(baseAngle) * 2 + (Math.random() - 0.5) * 1,
                        vy: Math.sin(baseAngle) * 2 + (Math.random() - 0.5) * 1,
                        life: 8,
                        color: '#8b7355',
                        radius: 2
                    });
                }
            }
        }
        
        // Critical hit calculation
        function calculateDamage(baseDamage, enemyX, enemyY) {
            const critChance = player.critChance || 5;
            const critDamage = player.critDamage || 150;
            
            let isCrit = Math.random() * 100 < critChance;
            let finalDamage = baseDamage;
            
            if (isCrit) {
                finalDamage = Math.floor(baseDamage * (critDamage / 100));
                
                // Show crit indicator
                particles.push({
                    x: enemyX,
                    y: enemyY - 20,
                    vx: 0,
                    vy: -2,
                    life: 40,
                    color: '#ff4444',
                    radius: 8,
                    text: 'CRIT!',
                    textColor: '#ffff00'
                });
            }
            
            return { damage: finalDamage, isCrit: isCrit };
        }
        
        // Melee attack variables
        let meleeSwingActive = false;
        let meleeSwingAngle = 0;
        let meleeSwingProgress = 0;
        let meleeSwingDuration = 200; // ms
        let meleeSwingStart = 0;
        let meleeHitEnemies = [];
        
        function meleeSwing(angle, damage, weapon) {
            meleeSwingActive = true;
            meleeSwingAngle = angle;
            meleeSwingProgress = 0;
            meleeSwingStart = Date.now();
            meleeSwingDuration = Math.max(100, weapon.fireRate * 0.4);
            meleeHitEnemies = [];
            
            // Determine swing arc based on weapon - cleave weapons have wider arc
            const swingArc = weapon.cleave ? Math.PI * 1.2 : Math.PI * 0.7;
            const range = weapon.range || 60;
            
            // Hit enemies in the swing arc
            const startAngle = angle - swingArc / 2;
            const endAngle = angle + swingArc / 2;
            
            for (let enemy of enemies) {
                const dist = distance(player, enemy);
                if (dist <= range + enemy.radius) {
                    const enemyAngle = Math.atan2(enemy.y - player.y, enemy.x - player.x);
                    
                    // Normalize angles for comparison
                    let angleDiff = enemyAngle - angle;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    
                    if (Math.abs(angleDiff) <= swingArc / 2) {
                        // Enemy is in swing arc - calculate crit
                        const damageResult = calculateDamage(damage, enemy.x, enemy.y);
                        enemy.health -= damageResult.damage;
                        meleeHitEnemies.push(enemy);
                        
                        // Stun effect for mace
                        if (weapon.stun && Math.random() < 0.3) {
                            enemy.stunned = true;
                            enemy.stunnedUntil = Date.now() + 500;
                        }
                        
                        // Hit particles - bigger for crits
                        const particleCount = damageResult.isCrit ? 10 : 5;
                        const particleColor = damageResult.isCrit ? '#ffff00' : weapon.color;
                        for (let i = 0; i < particleCount; i++) {
                            particles.push({
                                x: enemy.x,
                                y: enemy.y,
                                vx: (Math.random() - 0.5) * 6,
                                vy: (Math.random() - 0.5) * 6,
                                life: 15,
                                color: particleColor,
                                radius: damageResult.isCrit ? 5 : 3
                            });
                        }
                        
                        // Knockback
                        const knockAngle = Math.atan2(enemy.y - player.y, enemy.x - player.x);
                        enemy.x += Math.cos(knockAngle) * 15;
                        enemy.y += Math.sin(knockAngle) * 15;
                        
                        if (enemy.health <= 0) {
                            const idx = enemies.indexOf(enemy);
                            if (idx >= 0) {
                                killEnemy(idx, enemy);
                            }
                        }
                        
                        // All melee weapons hit all enemies in range
                    }
                }
            }
            
            // Swing particles
            for (let i = 0; i < 8; i++) {
                const particleAngle = startAngle + (i / 8) * swingArc;
                particles.push({
                    x: player.x + Math.cos(particleAngle) * range * 0.7,
                    y: player.y + Math.sin(particleAngle) * range * 0.7,
                    vx: Math.cos(particleAngle) * 2,
                    vy: Math.sin(particleAngle) * 2,
                    life: 10,
                    color: weapon.color,
                    radius: 2
                });
            }
        }
        
        function updateMeleeSwing() {
            if (!meleeSwingActive) return;
            
            const elapsed = Date.now() - meleeSwingStart;
            meleeSwingProgress = Math.min(1, elapsed / meleeSwingDuration);
            
            if (meleeSwingProgress >= 1) {
                meleeSwingActive = false;
            }
        }
        
        function drawMeleeSwing() {
            if (!meleeSwingActive) return;
            if (!player || !player.meleeWeapon) return;
            
            const weapon = player.meleeWeapon;
            const range = weapon.range || 60;
            const swingArc = weapon.cleave ? Math.PI * 1.2 : Math.PI * 0.7;
            
            // Swing animation: start from one side, sweep to the other
            const swingOffset = (meleeSwingProgress - 0.5) * swingArc;
            const currentAngle = meleeSwingAngle + swingOffset;
            
            ctx.save();
            ctx.translate(player.x, player.y);
            
            // Draw swing arc
            ctx.globalAlpha = 0.3 * (1 - meleeSwingProgress);
            ctx.fillStyle = weapon.color;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.arc(0, 0, range, meleeSwingAngle - swingArc/2, meleeSwingAngle + swingArc/2);
            ctx.closePath();
            ctx.fill();
            
            // Draw swing trail
            ctx.globalAlpha = 0.6 * (1 - meleeSwingProgress);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(0, 0, range * 0.8, currentAngle - 0.3, currentAngle + 0.1);
            ctx.stroke();
            
            ctx.restore();
        }

        function spawnEnemy() {
            const side = Math.floor(Math.random() * 4);
            let x, y;
            
            // Spawn enemies just outside the current viewport
            const spawnMargin = 50;
            switch (side) {
                case 0: // Top
                    x = camera.x + Math.random() * GAME_WIDTH; 
                    y = camera.y - spawnMargin; 
                    break;
                case 1: // Right
                    x = camera.x + GAME_WIDTH + spawnMargin; 
                    y = camera.y + Math.random() * GAME_HEIGHT; 
                    break;
                case 2: // Bottom
                    x = camera.x + Math.random() * GAME_WIDTH; 
                    y = camera.y + GAME_HEIGHT + spawnMargin; 
                    break;
                case 3: // Left
                    x = camera.x - spawnMargin; 
                    y = camera.y + Math.random() * GAME_HEIGHT; 
                    break;
            }
            
            // Clamp spawn position to world bounds
            x = Math.max(0, Math.min(WORLD_WIDTH, x));
            y = Math.max(0, Math.min(WORLD_HEIGHT, y));
            
            // Base stats (reduced for easier gameplay)
            const baseHealth = 20 + wave * 5;
            const baseSpeed = 1.0 + wave * 0.08;
            const baseDamage = 8 + wave * 1.5;
            
            // Enemy types based on wave
            const types = ['basic'];
            if (wave >= 3) types.push('fast', 'fast'); // More fast enemies
            if (wave >= 4) types.push('tank');
            if (wave >= 5) types.push('berserker');
            if (wave >= 6) types.push('elite');
            if (wave >= 8) types.push('brute');
            if (wave >= 10) types.push('boss');
            
            const type = types[Math.floor(Math.random() * types.length)];
            
            let enemy = {
                x, y,
                radius: 14,
                health: baseHealth,
                maxHealth: baseHealth,
                speed: baseSpeed,
                damage: baseDamage,
                value: 12,
                color: '#c41e3a',
                type
            };
            
            switch (type) {
                case 'fast':
                    enemy.speed *= 1.8;
                    enemy.health *= 0.5;
                    enemy.radius = 10;
                    enemy.color = '#ff6b35';
                    enemy.value = 15;
                    enemy.damage *= 0.6;
                    break;
                case 'tank':
                    enemy.speed *= 0.45;
                    enemy.health *= 3;
                    enemy.radius = 22;
                    enemy.color = '#5c3d2e';
                    enemy.damage *= 1.3;
                    enemy.value = 35;
                    break;
                case 'berserker':
                    enemy.speed *= 1.4;
                    enemy.health *= 1.0;
                    enemy.radius = 13;
                    enemy.color = '#e74c3c';
                    enemy.damage *= 1.5;
                    enemy.value = 25;
                    break;
                case 'elite':
                    enemy.health *= 1.8;
                    enemy.speed *= 1.1;
                    enemy.radius = 16;
                    enemy.color = '#9b59b6';
                    enemy.damage *= 1.2;
                    enemy.value = 50;
                    break;
                case 'brute':
                    enemy.speed *= 0.6;
                    enemy.health *= 3.5;
                    enemy.radius = 26;
                    enemy.color = '#2c3e50';
                    enemy.damage *= 1.5;
                    enemy.value = 60;
                    break;
                case 'boss':
                    enemy.speed *= 0.5;
                    enemy.health *= 6;
                    enemy.radius = 35;
                    enemy.color = '#8b0000';
                    enemy.damage *= 2;
                    enemy.value = 150;
                    break;
            }
            
            enemy.maxHealth = enemy.health;
            enemies.push(enemy);
        }
        
        function spawnBoss() {
            // Spawn boss at a distance from player
            const angle = Math.random() * Math.PI * 2;
            const dist = 400;
            let x = player.x + Math.cos(angle) * dist;
            let y = player.y + Math.sin(angle) * dist;
            
            // Clamp to world bounds
            x = Math.max(50, Math.min(WORLD_WIDTH - 50, x));
            y = Math.max(50, Math.min(WORLD_HEIGHT - 50, y));
            
            // Boss scales with wave number
            const bossLevel = Math.floor(wave / 5);
            const healthMultiplier = 1 + (bossLevel - 1) * 0.5; // +50% per boss level
            const damageMultiplier = 1 + (bossLevel - 1) * 0.3; // +30% per boss level
            
            const baseHealth = (100 + wave * 20) * healthMultiplier;
            const baseDamage = (15 + wave * 2) * damageMultiplier;
            
            const boss = {
                x, y,
                radius: 45 + bossLevel * 5,
                health: baseHealth,
                maxHealth: baseHealth,
                speed: 0.8 + wave * 0.02,
                damage: baseDamage,
                value: 300 + bossLevel * 100,
                color: '#8b0000',
                type: 'boss',
                isBoss: true
            };
            
            enemies.push(boss);
            
            // Boss spawn announcement particles
            for (let i = 0; i < 30; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    life: 50,
                    color: '#ff4444',
                    radius: 6
                });
            }
        }

        function updateEnemies() {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                
                // Check if stunned
                if (enemy.stunned) {
                    if (Date.now() >= enemy.stunnedUntil) {
                        enemy.stunned = false;
                    } else {
                        // Stunned enemies don't move or attack
                        continue;
                    }
                }
                
                // Move toward player
                const dx = player.x - enemy.x;
                const dy = player.y - enemy.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 0) {
                    const moveX = (dx / dist) * enemy.speed;
                    const moveY = (dy / dist) * enemy.speed;
                    
                    // Check building collision before moving
                    const newX = enemy.x + moveX;
                    const newY = enemy.y + moveY;
                    const newGrid = worldToGrid(newX, newY);
                    const building = getBuildingAt(newGrid.gx, newGrid.gy);
                    
                    if (building && building.blockEnemies) {
                        // Attack the building instead
                        if (!enemy.attackCooldown || enemy.attackCooldown <= 0) {
                            damageBuilding(building, enemy.damage / 2);
                            enemy.attackCooldown = 60; // frames between attacks
                        } else {
                            enemy.attackCooldown--;
                        }
                        
                        // Try to move around the building
                        const altGrid1 = worldToGrid(enemy.x + moveX, enemy.y);
                        const altGrid2 = worldToGrid(enemy.x, enemy.y + moveY);
                        
                        if (!getBuildingAt(altGrid1.gx, altGrid1.gy)?.blockEnemies) {
                            enemy.x += moveX * 0.5;
                        } else if (!getBuildingAt(altGrid2.gx, altGrid2.gy)?.blockEnemies) {
                            enemy.y += moveY * 0.5;
                        }
                    } else {
                        enemy.x = newX;
                        enemy.y = newY;
                    }
                }
                
                // Check collision with player
                if (distance(enemy, player) < enemy.radius + player.radius) {
                    takeDamage(enemy.damage);
                    
                    // Knockback
                    const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                    enemy.x -= Math.cos(angle) * 30;
                    enemy.y -= Math.sin(angle) * 30;
                }
            }
        }

        function updateProjectiles() {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];
                const speed = Math.sqrt(proj.vx * proj.vx + proj.vy * proj.vy);
                proj.x += proj.vx;
                proj.y += proj.vy;
                
                // Track distance traveled
                proj.distanceTraveled = (proj.distanceTraveled || 0) + speed;
                
                // Check if exceeded max range
                if (proj.maxRange && proj.distanceTraveled > proj.maxRange) {
                    // Arrow falls to ground
                    for (let k = 0; k < 3; k++) {
                        particles.push({
                            x: proj.x,
                            y: proj.y,
                            vx: (Math.random() - 0.5) * 2,
                            vy: 2 + Math.random() * 2,
                            life: 20,
                            color: '#5a4030',
                            radius: 2
                        });
                    }
                    projectiles.splice(i, 1);
                    continue;
                }
                
                // Check bounds
                if (proj.x < 0 || proj.x > WORLD_WIDTH || proj.y < 0 || proj.y > WORLD_HEIGHT) {
                    projectiles.splice(i, 1);
                    continue;
                }
                
                // Check enemy collisions
                let hitEnemy = false;
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    
                    // Skip already hit enemies for pierce projectiles
                    if (proj.hitEnemies && proj.hitEnemies.includes(enemy)) continue;
                    
                    if (distance(proj, enemy) < proj.radius + enemy.radius) {
                        enemy.health -= proj.damage;
                        
                        // Show crit indicator for crit projectiles
                        if (proj.isCrit) {
                            particles.push({
                                x: enemy.x,
                                y: enemy.y - 20,
                                vx: 0,
                                vy: -2,
                                life: 40,
                                color: '#ff4444',
                                radius: 8,
                                text: 'CRIT!',
                                textColor: '#ffff00'
                            });
                        }
                        
                        // Hit particles - more for crits
                        const particleCount = proj.isCrit ? 8 : 4;
                        for (let k = 0; k < particleCount; k++) {
                            particles.push({
                                x: proj.x,
                                y: proj.y,
                                vx: (Math.random() - 0.5) * 4,
                                vy: (Math.random() - 0.5) * 4,
                                life: 15,
                                color: proj.isCrit ? '#ffff00' : enemy.color,
                                radius: proj.isCrit ? 4 : 3
                            });
                        }
                        
                        if (enemy.health <= 0) {
                            killEnemy(j, enemy);
                        }
                        
                        // Pierce projectiles continue through
                        if (proj.pierce) {
                            proj.hitEnemies = proj.hitEnemies || [];
                            proj.hitEnemies.push(enemy);
                            proj.damage *= 0.7; // Reduce damage after piercing
                        } else {
                            hitEnemy = true;
                            projectiles.splice(i, 1);
                            break;
                        }
                    }
                }
            }
        }
        
        function updateSiegeWeapons(timestamp) {
            // Update siege projectiles
            for (let i = siegeProjectiles.length - 1; i >= 0; i--) {
                const proj = siegeProjectiles[i];
                proj.x += proj.vx;
                proj.y += proj.vy;
                
                // Check if reached target or out of bounds
                if (proj.x < 0 || proj.x > WORLD_WIDTH || proj.y < 0 || proj.y > WORLD_HEIGHT) {
                    siegeProjectiles.splice(i, 1);
                    continue;
                }
                
                // Check enemy collisions
                let hit = false;
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    const hitRange = proj.areaOfEffect > 0 ? proj.areaOfEffect : proj.radius + enemy.radius;
                    
                    if (distance(proj, enemy) < hitRange) {
                        hit = true;
                        
                        // Area of effect damage
                        if (proj.areaOfEffect > 0) {
                            for (let k = enemies.length - 1; k >= 0; k--) {
                                const e = enemies[k];
                                if (distance(proj, e) < proj.areaOfEffect) {
                                    e.health -= proj.damage;
                                    
                                    // Hit particles
                                    for (let p = 0; p < 2; p++) {
                                        particles.push({
                                            x: e.x,
                                            y: e.y,
                                            vx: (Math.random() - 0.5) * 4,
                                            vy: (Math.random() - 0.5) * 4,
                                            life: 15,
                                            color: proj.color,
                                            radius: 3
                                        });
                                    }
                                    
                                    if (e.health <= 0) {
                                        killEnemy(k, e);
                                    }
                                }
                            }
                            
                            // Explosion effect
                            for (let p = 0; p < 12; p++) {
                                const angle = (p / 12) * Math.PI * 2;
                                particles.push({
                                    x: proj.x,
                                    y: proj.y,
                                    vx: Math.cos(angle) * 4,
                                    vy: Math.sin(angle) * 4,
                                    life: 20,
                                    color: proj.burning ? '#ff4500' : proj.color,
                                    radius: 4
                                });
                            }
                        } else {
                            // Single target damage
                            enemy.health -= proj.damage;
                            
                            for (let p = 0; p < 4; p++) {
                                particles.push({
                                    x: proj.x,
                                    y: proj.y,
                                    vx: (Math.random() - 0.5) * 5,
                                    vy: (Math.random() - 0.5) * 5,
                                    life: 15,
                                    color: proj.color,
                                    radius: 3
                                });
                            }
                            
                            if (enemy.health <= 0) {
                                killEnemy(j, enemy);
                            }
                        }
                        
                        siegeProjectiles.splice(i, 1);
                        break;
                    }
                }
            }
            
            // Update siege weapons (targeting and firing)
            for (let siege of siegeWeapons) {
                // Find nearest enemy in range
                let nearestEnemy = null;
                let nearestDist = siege.range;
                
                for (let enemy of enemies) {
                    const dist = distance(siege, enemy);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestEnemy = enemy;
                    }
                }
                
                if (nearestEnemy) {
                    // Rotate toward target
                    const targetAngle = Math.atan2(nearestEnemy.y - siege.y, nearestEnemy.x - siege.x);
                    siege.angle = targetAngle;
                    
                    // Fire if ready
                    if (timestamp - siege.lastFired > siege.fireRate) {
                        siege.lastFired = timestamp;
                        
                        // Create projectile
                        siegeProjectiles.push({
                            x: siege.x,
                            y: siege.y,
                            vx: Math.cos(targetAngle) * siege.projectileSpeed,
                            vy: Math.sin(targetAngle) * siege.projectileSpeed,
                            damage: siege.damage,
                            radius: siege.projectileSize,
                            color: siege.projectileColor,
                            areaOfEffect: siege.areaOfEffect || 0,
                            burning: siege.burning || false
                        });
                        
                        // Firing particles
                        for (let i = 0; i < 5; i++) {
                            particles.push({
                                x: siege.x + Math.cos(targetAngle) * 15,
                                y: siege.y + Math.sin(targetAngle) * 15,
                                vx: Math.cos(targetAngle) * 2 + (Math.random() - 0.5) * 2,
                                vy: Math.sin(targetAngle) * 2 + (Math.random() - 0.5) * 2,
                                life: 10,
                                color: siege.burning ? '#ff4500' : '#d4a574',
                                radius: 2
                            });
                        }
                    }
                }
            }
        }
        
        function drawSiegeProjectiles() {
            for (let proj of siegeProjectiles) {
                ctx.save();
                ctx.translate(proj.x, proj.y);
                ctx.rotate(Math.atan2(proj.vy, proj.vx));
                
                // Draw projectile
                ctx.fillStyle = proj.color;
                ctx.beginPath();
                ctx.ellipse(0, 0, proj.radius * 1.5, proj.radius, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Trail
                ctx.globalAlpha = 0.5;
                ctx.fillStyle = proj.burning ? '#ff8c00' : proj.color;
                ctx.beginPath();
                ctx.ellipse(-proj.radius * 2, 0, proj.radius, proj.radius * 0.5, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        }

        function killEnemy(index, enemy) {
            // Death particles
            for (let i = 0; i < 10; i++) {
                particles.push({
                    x: enemy.x,
                    y: enemy.y,
                    vx: (Math.random() - 0.5) * 6,
                    vy: (Math.random() - 0.5) * 6,
                    life: 30,
                    color: enemy.color,
                    radius: 5
                });
            }
            
            // XP and bounty
            const enemyValue = enemy.value || 10; // Default value if undefined
            
            // Apply gold bonus from Fortune stat
            const goldMultiplier = 1 + (player.goldBonus || 0) / 100;
            const goldEarned = Math.floor(enemyValue * goldMultiplier);
            
            // Apply XP bonus from Wisdom stat
            const xpMultiplier = 1 + (player.xpBonus || 0) / 100;
            const xpEarned = Math.floor((enemyValue / 2) * xpMultiplier);
            
            player.xp += xpEarned;
            bounty += goldEarned;
            totalBountyEarned += goldEarned;
            kills++;
            
            // Safety check for NaN
            if (isNaN(bounty)) bounty = 0;
            
            // Check level up
            let levelsGained = 0;
            while (player.xp >= player.xpToLevel) {
                player.xp -= player.xpToLevel;
                player.level++;
                player.xpToLevel = Math.floor(player.xpToLevel * 1.5);
                levelsGained++;
                
                // Level up particles
                for (let i = 0; i < 20; i++) {
                    particles.push({
                        x: player.x,
                        y: player.y,
                        vx: (Math.random() - 0.5) * 8,
                        vy: (Math.random() - 0.5) * 8,
                        life: 40,
                        color: '#ffd700',
                        radius: 4
                    });
                }
            }
            
            // If leveled up, add stat points and show upgrade screen
            if (levelsGained > 0) {
                player.pendingPoints += levelsGained * 5; // 5 points per level
                showLevelUpScreen();
            }
            
            // Check if this was a boss kill - give bonus stat points
            if (enemy.isBoss) {
                const bossLevel = Math.floor(wave / 5);
                const bonusPoints = 10 * bossLevel; // 10 points for first boss, 20 for second, etc.
                player.pendingPoints += bonusPoints;
                
                // Boss defeat celebration particles
                for (let i = 0; i < 50; i++) {
                    particles.push({
                        x: enemy.x,
                        y: enemy.y,
                        vx: (Math.random() - 0.5) * 12,
                        vy: (Math.random() - 0.5) * 12,
                        life: 60,
                        color: ['#ffd700', '#ff4444', '#ff8800'][Math.floor(Math.random() * 3)],
                        radius: 6
                    });
                }
                
                // Show level up screen with bonus points
                if (bonusPoints > 0) {
                    showLevelUpScreen();
                }
            }
            
            // Random drops
            if (Math.random() < 0.15) {
                spawnDrop(enemy.x, enemy.y);
            }
            
            // Boss always drops loot
            if (enemy.isBoss) {
                for (let i = 0; i < 3; i++) {
                    spawnDrop(enemy.x + (Math.random() - 0.5) * 50, enemy.y + (Math.random() - 0.5) * 50);
                }
            }
            
            enemies.splice(index, 1);
        }
        
        function showLevelUpScreen() {
            isPaused = true;
            document.getElementById('levelup-screen').classList.remove('hidden');
            updateLevelUpUI();
        }
        
        function updateLevelUpUI() {
            document.getElementById('points-remaining').textContent = player.pendingPoints;
            
            // Update stat levels
            document.getElementById('lvl-vitality').textContent = player.statLevels.vitality;
            document.getElementById('lvl-recovery').textContent = player.statLevels.recovery;
            document.getElementById('lvl-strength').textContent = player.statLevels.strength;
            document.getElementById('lvl-dexterity').textContent = player.statLevels.dexterity;
            document.getElementById('lvl-toughness').textContent = player.statLevels.toughness;
            document.getElementById('lvl-fortune').textContent = player.statLevels.fortune;
            document.getElementById('lvl-wisdom').textContent = player.statLevels.wisdom;
            document.getElementById('lvl-precision').textContent = player.statLevels.precision;
            document.getElementById('lvl-ferocity').textContent = player.statLevels.ferocity;
            
            // Update stat value displays
            document.getElementById('val-vitality').textContent = player.maxHealth + ' HP';
            document.getElementById('val-recovery').textContent = player.healthRegen.toFixed(1) + '/s';
            document.getElementById('val-strength').textContent = '+' + player.bonusDamage + ' dmg';
            document.getElementById('val-dexterity').textContent = '+' + player.attackSpeed + ' spd';
            document.getElementById('val-toughness').textContent = player.maxArmor + ' armor';
            document.getElementById('val-fortune').textContent = '+' + player.goldBonus + '% gold';
            document.getElementById('val-wisdom').textContent = '+' + player.xpBonus + '% XP';
            document.getElementById('val-precision').textContent = player.critChance + '%';
            document.getElementById('val-ferocity').textContent = player.critDamage + '%';
            
            // Update bars (visual representation, max around 20 points per stat)
            const maxPoints = 20;
            document.getElementById('bar-vitality').style.width = Math.min(100, (player.statLevels.vitality / maxPoints) * 100) + '%';
            document.getElementById('bar-recovery').style.width = Math.min(100, (player.statLevels.recovery / maxPoints) * 100) + '%';
            document.getElementById('bar-strength').style.width = Math.min(100, (player.statLevels.strength / maxPoints) * 100) + '%';
            document.getElementById('bar-dexterity').style.width = Math.min(100, (player.statLevels.dexterity / maxPoints) * 100) + '%';
            document.getElementById('bar-toughness').style.width = Math.min(100, (player.statLevels.toughness / maxPoints) * 100) + '%';
            document.getElementById('bar-fortune').style.width = Math.min(100, (player.statLevels.fortune / maxPoints) * 100) + '%';
            document.getElementById('bar-wisdom').style.width = Math.min(100, (player.statLevels.wisdom / maxPoints) * 100) + '%';
            document.getElementById('bar-precision').style.width = Math.min(100, (player.statLevels.precision / maxPoints) * 100) + '%';
            document.getElementById('bar-ferocity').style.width = Math.min(100, (player.statLevels.ferocity / maxPoints) * 100) + '%';
            
            // Enable/disable buttons based on available points
            const buttons = document.querySelectorAll('.stat-btn');
            buttons.forEach(btn => {
                btn.disabled = player.pendingPoints <= 0;
            });
        }
        
        function allocateStat(stat) {
            if (player.pendingPoints <= 0) return;
            
            player.pendingPoints--;
            player.statLevels[stat]++;
            
            // Apply flat stat increases (Diablo 2 style)
            switch(stat) {
                case 'vitality':
                    // Each point adds 12 max health
                    player.maxHealth += 12;
                    player.health += 12; // Also heal
                    break;
                case 'recovery':
                    // Each point adds 0.4 health regen per second
                    player.healthRegen += 0.4;
                    break;
                case 'strength':
                    // Each point adds 2 flat damage
                    player.bonusDamage += 2;
                    break;
                case 'dexterity':
                    // Each point reduces fire delay by 15ms (increases attack speed)
                    player.attackSpeed += 15;
                    break;
                case 'toughness':
                    // Each point adds 8 max armor
                    player.maxArmor += 8;
                    break;
                case 'fortune':
                    // Each point adds 5% gold bonus
                    player.goldBonus += 5;
                    break;
                case 'wisdom':
                    // Each point adds 5% XP bonus
                    player.xpBonus += 5;
                    break;
                case 'precision':
                    // Each point adds 2% crit chance
                    player.critChance += 2;
                    break;
                case 'ferocity':
                    // Each point adds 10% crit damage
                    player.critDamage += 10;
                    break;
            }
            
            updateLevelUpUI();
            
            // Play a little feedback particle
            for (let i = 0; i < 5; i++) {
                particles.push({
                    x: player.x + (Math.random() - 0.5) * 20,
                    y: player.y + (Math.random() - 0.5) * 20,
                    vx: (Math.random() - 0.5) * 4,
                    vy: -Math.random() * 3,
                    life: 25,
                    color: '#ffd700',
                    radius: 3
                });
            }
        }
        
        function confirmLevelUp() {
            isPaused = false;
            document.getElementById('levelup-screen').classList.add('hidden');
        }

        function spawnDrop(x, y) {
            const rand = Math.random();
            let drop;
            
            if (rand < 0.4) {
                // Health drop
                drop = {
                    x, y,
                    type: 'health',
                    name: 'Health Kit',
                    icon: '',
                    value: 30,
                    color: '#c41e3a',
                    radius: 12
                };
            } else if (rand < 0.7) {
                // Weapon drop with random stats
                const weaponKeys = Object.keys(WEAPON_TEMPLATES);
                const weaponKey = weaponKeys[Math.floor(Math.random() * weaponKeys.length)];
                const weapon = generateRandomWeapon(weaponKey);
                
                // Choose icon based on weapon type
                let icon = '';
                const baseName = weapon.baseName;
                
                // Daggers & Knives
                if (['Dagger', 'Stiletto', 'Dirk'].includes(baseName)) icon = '';
                // Swords
                else if (['Sword', 'Longsword', 'Broadsword', 'Scimitar', 'Rapier', 'Falchion', 'Claymore', 'Katana'].includes(baseName)) icon = '';
                // Axes
                else if (['Battle Axe', 'Hatchet', 'Greataxe', 'War Axe'].includes(baseName)) icon = '';
                // Maces & Hammers
                else if (['Mace', 'Flail', 'Morningstar', 'Warhammer', 'Maul', 'Club'].includes(baseName)) icon = '';
                // Polearms
                else if (['Spear', 'Pike', 'Halberd', 'Glaive', 'Trident', 'Quarterstaff'].includes(baseName)) icon = '';
                // Scythe
                else if (baseName === 'War Scythe') icon = '';
                // Bows
                else if (['Bow', 'Shortbow', 'Longbow', 'Composite Bow', 'Recurve Bow', 'War Bow'].includes(baseName)) icon = '';
                // Crossbows
                else if (['Crossbow', 'Light Crossbow', 'Heavy Crossbow', 'Arbalest', 'Repeating Crossbow'].includes(baseName)) icon = '';
                // Throwing weapons
                else if (['Throwing Knives', 'Throwing Axes', 'Javelins', 'Chakram', 'Bolas'].includes(baseName)) icon = '';
                // Slings
                else if (['Sling', 'Staff Sling'].includes(baseName)) icon = '';
                // Exotic ranged
                else if (baseName === 'Blowgun') icon = '';
                else if (baseName === 'Hand Cannon') icon = '';
                else if (baseName === 'Fire Lance') icon = '';
                
                drop = {
                    x, y,
                    type: 'weapon',
                    name: weapon.name,
                    icon: icon,
                    weapon: weapon,
                    isMelee: weapon.melee || false,
                    color: weapon.rarityColor,
                    radius: 14,
                    rarity: weapon.rarity
                };
            } else {
                // Armor drop - use new slot system
                const armorData = generateArmorDrop();
                drop = {
                    x, y,
                    type: 'armor',
                    name: armorData.name,
                    icon: armorData.icon,
                    slot: armorData.slot,
                    tier: armorData.tier,
                    armorValue: armorData.armor,
                    bonus: armorData.bonus,
                    color: armorData.color,
                    radius: 14
                };
            }
            
            drop.spawnTime = Date.now();
            drop.id = Date.now() + Math.random(); // Unique ID for each drop
            drops.push(drop);
        }

        function checkDrops() {
            nearbyDrop = null;
            const pickupPrompt = document.getElementById('pickup-prompt');
            
            for (let i = drops.length - 1; i >= 0; i--) {
                const drop = drops[i];
                const dist = distance(player, drop);
                
                // Auto-pickup health
                if (drop.type === 'health' && dist < player.radius + drop.radius) {
                    player.health = Math.min(player.health + drop.value, player.maxHealth);
                    // Pickup particles
                    for (let j = 0; j < 8; j++) {
                        particles.push({
                            x: drop.x,
                            y: drop.y,
                            vx: (Math.random() - 0.5) * 4,
                            vy: (Math.random() - 0.5) * 4,
                            life: 20,
                            color: drop.color,
                            radius: 3
                        });
                    }
                    drops.splice(i, 1);
                    continue;
                }
                
                // Auto-pickup weapon - show swap screen
                if (drop.type === 'weapon' && dist < player.radius + drop.radius) {
                    showWeaponSwapScreen(drop, drop.id);
                    continue;
                }
                
                // Armor pickup - show swap screen for choice
                if (drop.type === 'armor' && dist < player.radius + drop.radius) {
                    showArmorSwapScreen(drop, drop.id);
                    continue;
                }
                
                // Despawn after 15 seconds
                if (Date.now() - drop.spawnTime > 15000) {
                    drops.splice(i, 1);
                }
            }
            
            // Hide the old pickup prompt since we auto-pickup now
            pickupPrompt.classList.remove('visible');
        }
        
        function showArmorSwapScreen(armorDrop, dropId) {
            isPaused = true;
            pendingArmor = armorDrop;
            pendingArmorIndex = dropId; // Now stores ID instead of index
            
            const slot = armorDrop.slot;
            const currentArmor = player.armorSlots[slot];
            const slotName = slot.charAt(0).toUpperCase() + slot.slice(1);
            
            // Update title
            document.getElementById('armor-swap-title').textContent = `New ${slotName} Armor!`;
            
            // Update current armor display
            const currentIcon = document.getElementById('current-armor-icon');
            const currentName = document.getElementById('current-armor-name');
            const currentStats = document.getElementById('current-armor-stats');
            
            if (currentArmor) {
                currentIcon.textContent = currentArmor.icon || '';
                currentName.textContent = currentArmor.name;
                currentName.style.color = currentArmor.color;
                
                let statsHtml = `<div class="armor-stat-line armor-value">Armor: ${currentArmor.armor}</div>`;
                for (let bonus in currentArmor.bonus) {
                    statsHtml += `<div class="armor-stat-line bonus">${formatBonus(bonus, currentArmor.bonus[bonus])}</div>`;
                }
                currentStats.innerHTML = statsHtml;
            } else {
                currentIcon.textContent = '';
                currentName.textContent = 'Empty Slot';
                currentName.style.color = '#666';
                currentStats.innerHTML = '<div class="armor-stat-line">No armor equipped</div>';
            }
            
            // Update new armor display
            document.getElementById('new-armor-icon').textContent = armorDrop.icon;
            document.getElementById('new-armor-name').textContent = armorDrop.name;
            document.getElementById('new-armor-name').style.color = armorDrop.color;
            
            let newStatsHtml = `<div class="armor-stat-line armor-value">Armor: ${armorDrop.armorValue}</div>`;
            newStatsHtml += `<div class="armor-stat-line">Level: ${armorDrop.level}</div>`;
            for (let bonus in armorDrop.bonus) {
                newStatsHtml += `<div class="armor-stat-line bonus">${formatBonus(bonus, armorDrop.bonus[bonus])}</div>`;
            }
            document.getElementById('new-armor-stats').innerHTML = newStatsHtml;
            
            // Update border color
            document.querySelector('.armor-card.new-armor').style.borderColor = armorDrop.color;
            
            document.getElementById('armor-swap-screen').classList.remove('hidden');
        }
        
        function keepCurrentArmor() {
            // Convert to bounty based on level
            if (pendingArmor) {
                const sellValue = (pendingArmor.level || 1) * 3;
                bounty += sellValue;
                
                // Safety check for NaN
                if (isNaN(bounty)) bounty = 0;
                
                // Find and remove drop by ID
                const dropIndex = drops.findIndex(d => d.id === pendingArmorIndex);
                if (dropIndex >= 0) {
                    const drop = drops[dropIndex];
                    for (let j = 0; j < 5; j++) {
                        particles.push({
                            x: drop.x,
                            y: drop.y,
                            vx: (Math.random() - 0.5) * 3,
                            vy: -2 - Math.random() * 2,
                            life: 20,
                            color: '#ffd700',
                            radius: 2
                        });
                    }
                    drops.splice(dropIndex, 1);
                }
            }
            
            pendingArmor = null;
            pendingArmorIndex = -1;
            isPaused = false;
            document.getElementById('armor-swap-screen').classList.add('hidden');
        }
        
        function equipNewArmor() {
            if (pendingArmor) {
                const slot = pendingArmor.slot;
                const armorValue = pendingArmor.armorValue;
                
                player.armorSlots[slot] = {
                    name: pendingArmor.name,
                    baseName: pendingArmor.baseName,
                    level: pendingArmor.level,
                    grade: pendingArmor.grade,
                    armor: armorValue,
                    maxArmor: armorValue, // Track max durability
                    currentArmor: armorValue, // Track current durability
                    bonus: pendingArmor.bonus,
                    color: pendingArmor.color,
                    icon: pendingArmor.icon
                };
                
                recalculateArmorStats();
                
                // Find and remove drop by ID
                const dropIndex = drops.findIndex(d => d.id === pendingArmorIndex);
                if (dropIndex >= 0) {
                    const drop = drops[dropIndex];
                    for (let j = 0; j < 12; j++) {
                        particles.push({
                            x: drop.x,
                            y: drop.y,
                            vx: (Math.random() - 0.5) * 5,
                            vy: (Math.random() - 0.5) * 5,
                            life: 25,
                            color: pendingArmor.color,
                            radius: 4
                        });
                    }
                    drops.splice(dropIndex, 1);
                }
            }
            
            pendingArmor = null;
            pendingArmorIndex = -1;
            isPaused = false;
            document.getElementById('armor-swap-screen').classList.add('hidden');
        }
        
        // ============ FORGE SYSTEM ============
        
        function hasForge() {
            return buildings.some(b => b.type === 'forge');
        }
        
        function openForge() {
            if (!hasForge()) return;
            
            forgeOpen = true;
            isPaused = true;
            forgeTab = 'weapons';
            document.getElementById('forge-screen').classList.remove('hidden');
            updateForgeContent();
        }
        
        function closeForge() {
            forgeOpen = false;
            isPaused = false;
            document.getElementById('forge-screen').classList.add('hidden');
        }
        
        function switchForgeTab(tab) {
            forgeTab = tab;
            document.querySelectorAll('.forge-tab').forEach(t => t.classList.remove('active'));
            document.getElementById(`forge-tab-${tab}`).classList.add('active');
            updateForgeContent();
        }
        
        function updateForgeContent() {
            const content = document.getElementById('forge-content');
            content.innerHTML = '';
            
            if (forgeTab === 'weapons') {
                // Show melee and ranged weapons
                const weapons = [
                    { key: 'melee', weapon: player.meleeWeapon, label: 'Melee' },
                    { key: 'ranged', weapon: player.rangedWeapon, label: 'Ranged' }
                ];
                
                weapons.forEach(({ key, weapon, label }) => {
                    const level = weapon.forgeLevel || 0;
                    const maxLevel = 10;
                    const cost = WEAPON_UPGRADE_COST * (level + 1);
                    const canAfford = bounty >= cost;
                    const canUpgrade = level < maxLevel;
                    
                    const icon = weapon.melee ? '' : '';
                    
                    const div = document.createElement('div');
                    div.className = `forge-item ${(!canAfford || !canUpgrade) ? 'disabled' : ''}`;
                    div.innerHTML = `
                        <div class="forge-item-icon">${icon}</div>
                        <div class="forge-item-name" style="color: ${weapon.rarityColor || '#9ca3af'}">${weapon.name}</div>
                        <div class="forge-item-stats">
                            DMG: ${weapon.damage} | Rate: ${(1000/weapon.fireRate).toFixed(1)}/s<br>
                            Forge Level: ${level}/${maxLevel}
                        </div>
                        ${canUpgrade ? `
                            <div class="forge-item-cost">${canAfford ? '' : ' '}$${cost}</div>
                            <div class="forge-item-upgrade">+${Math.ceil(weapon.damage * 0.1)} DMG, +5% Rate</div>
                        ` : '<div class="forge-item-cost" style="color: #4ade80">MAX LEVEL</div>'}
                    `;
                    
                    if (canAfford && canUpgrade) {
                        div.onclick = () => upgradeWeaponAtForge(key);
                    }
                    
                    content.appendChild(div);
                });
            } else if (forgeTab === 'armor') {
                // Show armor pieces for upgrade
                const slots = ['head', 'body', 'arms', 'legs', 'feet', 'belt'];
                
                slots.forEach(slot => {
                    const armor = player.armorSlots[slot];
                    const slotName = slot.charAt(0).toUpperCase() + slot.slice(1);
                    
                    if (!armor) {
                        const div = document.createElement('div');
                        div.className = 'forge-item disabled';
                        div.innerHTML = `
                            <div class="forge-item-icon"></div>
                            <div class="forge-item-name">${slotName}</div>
                            <div class="forge-item-stats">No armor equipped</div>
                        `;
                        content.appendChild(div);
                        return;
                    }
                    
                    const level = armor.forgeLevel || 0;
                    const maxLevel = 5;
                    const cost = ARMOR_UPGRADE_COST * (level + 1);
                    const canAfford = bounty >= cost;
                    const canUpgrade = level < maxLevel;
                    
                    const div = document.createElement('div');
                    div.className = `forge-item ${(!canAfford || !canUpgrade) ? 'disabled' : ''}`;
                    div.innerHTML = `
                        <div class="forge-item-icon">${armor.icon || ''}</div>
                        <div class="forge-item-name" style="color: ${armor.color || '#9ca3af'}">${armor.name}</div>
                        <div class="forge-item-stats">
                            Armor: ${armor.maxArmor || armor.armor}<br>
                            Forge Level: ${level}/${maxLevel}
                        </div>
                        ${canUpgrade ? `
                            <div class="forge-item-cost">${canAfford ? '' : ' '}$${cost}</div>
                            <div class="forge-item-upgrade">+${Math.ceil((armor.maxArmor || armor.armor) * 0.15)} Armor</div>
                        ` : '<div class="forge-item-cost" style="color: #4ade80">MAX LEVEL</div>'}
                    `;
                    
                    if (canAfford && canUpgrade) {
                        div.onclick = () => upgradeArmorAtForge(slot);
                    }
                    
                    content.appendChild(div);
                });
            } else if (forgeTab === 'repair') {
                // Show armor pieces for repair
                const slots = ['head', 'body', 'arms', 'legs', 'feet', 'belt'];
                const ARMOR_REPAIR_COST = 5; // Cost per armor point to repair
                
                // Add "Repair All" button at top
                let totalDamage = 0;
                slots.forEach(slot => {
                    const armor = player.armorSlots[slot];
                    if (armor && armor.maxArmor) {
                        totalDamage += (armor.maxArmor - (armor.currentArmor || 0));
                    }
                });
                
                if (totalDamage > 0) {
                    const totalCost = Math.ceil(totalDamage * ARMOR_REPAIR_COST);
                    const canAffordAll = bounty >= totalCost;
                    
                    const repairAllDiv = document.createElement('div');
                    repairAllDiv.className = `forge-item ${!canAffordAll ? 'disabled' : ''}`;
                    repairAllDiv.style.background = 'rgba(74, 222, 128, 0.2)';
                    repairAllDiv.style.borderColor = '#4ade80';
                    repairAllDiv.innerHTML = `
                        <div class="forge-item-icon"></div>
                        <div class="forge-item-name" style="color: #4ade80">Repair All Armor</div>
                        <div class="forge-item-stats">
                            Restore ${Math.ceil(totalDamage)} armor points
                        </div>
                        <div class="forge-item-cost">${canAffordAll ? '' : ' '}$${totalCost}</div>
                    `;
                    
                    if (canAffordAll) {
                        repairAllDiv.onclick = () => repairAllArmor();
                    }
                    
                    content.appendChild(repairAllDiv);
                }
                
                slots.forEach(slot => {
                    const armor = player.armorSlots[slot];
                    const slotName = slot.charAt(0).toUpperCase() + slot.slice(1);
                    
                    if (!armor) {
                        const div = document.createElement('div');
                        div.className = 'forge-item disabled';
                        div.innerHTML = `
                            <div class="forge-item-icon"></div>
                            <div class="forge-item-name">${slotName}</div>
                            <div class="forge-item-stats">No armor equipped</div>
                        `;
                        content.appendChild(div);
                        return;
                    }
                    
                    // Ensure durability values exist
                    if (armor.maxArmor === undefined) {
                        armor.maxArmor = armor.armor;
                        armor.currentArmor = armor.armor;
                    }
                    
                    const damage = armor.maxArmor - armor.currentArmor;
                    const cost = Math.ceil(damage * ARMOR_REPAIR_COST);
                    const canAfford = bounty >= cost;
                    const needsRepair = damage > 0;
                    const durabilityPct = Math.round((armor.currentArmor / armor.maxArmor) * 100);
                    
                    // Color based on durability
                    let durColor = '#4ade80'; // green
                    if (durabilityPct < 25) durColor = '#ef4444'; // red
                    else if (durabilityPct < 50) durColor = '#f59e0b'; // orange
                    else if (durabilityPct < 75) durColor = '#eab308'; // yellow
                    
                    const div = document.createElement('div');
                    div.className = `forge-item ${(!canAfford || !needsRepair) ? 'disabled' : ''}`;
                    div.innerHTML = `
                        <div class="forge-item-icon">${armor.icon || ''}</div>
                        <div class="forge-item-name" style="color: ${armor.color || '#9ca3af'}">${armor.name}</div>
                        <div class="forge-item-stats">
                            Durability: <span style="color: ${durColor}">${Math.round(armor.currentArmor)}/${armor.maxArmor}</span> (${durabilityPct}%)<br>
                            <div style="background: #333; height: 6px; border-radius: 3px; margin-top: 4px;">
                                <div style="background: ${durColor}; width: ${durabilityPct}%; height: 100%; border-radius: 3px;"></div>
                            </div>
                        </div>
                        ${needsRepair ? `
                            <div class="forge-item-cost">${canAfford ? '' : ' '}$${cost}</div>
                            <div class="forge-item-upgrade">Restore ${Math.ceil(damage)} armor</div>
                        ` : '<div class="forge-item-cost" style="color: #4ade80">FULL DURABILITY</div>'}
                    `;
                    
                    if (canAfford && needsRepair) {
                        div.onclick = () => repairArmorAtForge(slot);
                    }
                    
                    content.appendChild(div);
                });
            }
        }
        
        function upgradeWeaponAtForge(weaponKey) {
            const weapon = weaponKey === 'melee' ? player.meleeWeapon : player.rangedWeapon;
            const level = weapon.forgeLevel || 0;
            const cost = WEAPON_UPGRADE_COST * (level + 1);
            
            if (bounty < cost || level >= 10) return;
            
            bounty -= cost;
            if (isNaN(bounty)) bounty = 0;
            weapon.forgeLevel = level + 1;
            
            // Upgrade stats
            weapon.damage = Math.ceil(weapon.damage * 1.1);
            weapon.fireRate = Math.floor(weapon.fireRate * 0.95);
            
            // Update name to show forge level
            if (!weapon.originalName) weapon.originalName = weapon.name;
            weapon.name = `${weapon.originalName} +${weapon.forgeLevel}`;
            
            // Particles
            for (let i = 0; i < 10; i++) {
                particles.push({
                    x: player.x,
                    y: player.y,
                    vx: (Math.random() - 0.5) * 5,
                    vy: -Math.random() * 3 - 1,
                    life: 25,
                    color: '#f97316',
                    radius: 3
                });
            }
            
            updateHUD();
            updateForgeContent();
        }
        
        function upgradeArmorAtForge(slot) {
            const armor = player.armorSlots[slot];
            if (!armor) return;
            
            const level = armor.forgeLevel || 0;
            const cost = ARMOR_UPGRADE_COST * (level + 1);
            
            if (bounty < cost || level >= 5) return;
            
            bounty -= cost;
            if (isNaN(bounty)) bounty = 0;
            armor.forgeLevel = level + 1;
            
            // Upgrade armor value and max armor
            const upgrade = Math.ceil((armor.maxArmor || armor.armor) * 0.15);
            armor.armor = (armor.maxArmor || armor.armor) + upgrade;
            armor.maxArmor = armor.armor;
            armor.currentArmor = armor.maxArmor; // Full repair on upgrade
            
            // Update name to show forge level
            if (!armor.originalName) armor.originalName = armor.name;
            armor.name = `${armor.originalName} +${armor.forgeLevel}`;
            
            // Recalculate stats
            recalculateArmorStats();
            
            // Particles
            for (let i = 0; i < 10; i++) {
                particles.push({
                    x: player.x,
                    y: player.y,
                    vx: (Math.random() - 0.5) * 5,
                    vy: -Math.random() * 3 - 1,
                    life: 25,
                    color: '#f97316',
                    radius: 3
                });
            }
            
            updateForgeContent();
        }
        
        function repairArmorAtForge(slot) {
            const armor = player.armorSlots[slot];
            if (!armor) return;
            
            // Ensure durability values exist
            if (armor.maxArmor === undefined) {
                armor.maxArmor = armor.armor;
                armor.currentArmor = armor.armor;
                return;
            }
            
            const damage = armor.maxArmor - armor.currentArmor;
            if (damage <= 0) return;
            
            const ARMOR_REPAIR_COST = 5;
            const cost = Math.ceil(damage * ARMOR_REPAIR_COST);
            
            if (bounty < cost) return;
            
            bounty -= cost;
            if (isNaN(bounty)) bounty = 0;
            
            armor.currentArmor = armor.maxArmor;
            
            // Recalculate stats
            recalculateArmorStats();
            
            // Green repair particles
            for (let i = 0; i < 10; i++) {
                particles.push({
                    x: player.x,
                    y: player.y,
                    vx: (Math.random() - 0.5) * 5,
                    vy: -Math.random() * 3 - 1,
                    life: 25,
                    color: '#4ade80',
                    radius: 3
                });
            }
            
            updateHUD();
            updateForgeContent();
        }
        
        function repairAllArmor() {
            const slots = ['head', 'body', 'arms', 'legs', 'feet', 'belt'];
            const ARMOR_REPAIR_COST = 5;
            
            let totalDamage = 0;
            slots.forEach(slot => {
                const armor = player.armorSlots[slot];
                if (armor && armor.maxArmor) {
                    totalDamage += (armor.maxArmor - (armor.currentArmor || 0));
                }
            });
            
            if (totalDamage <= 0) return;
            
            const totalCost = Math.ceil(totalDamage * ARMOR_REPAIR_COST);
            if (bounty < totalCost) return;
            
            bounty -= totalCost;
            if (isNaN(bounty)) bounty = 0;
            
            // Repair all pieces
            slots.forEach(slot => {
                const armor = player.armorSlots[slot];
                if (armor && armor.maxArmor) {
                    armor.currentArmor = armor.maxArmor;
                }
            });
            
            // Recalculate stats
            recalculateArmorStats();
            
            // Big green repair particles
            for (let i = 0; i < 20; i++) {
                particles.push({
                    x: player.x,
                    y: player.y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: -Math.random() * 4 - 1,
                    life: 30,
                    color: '#4ade80',
                    radius: 4
                });
            }
            
            updateHUD();
            updateForgeContent();
        }
        
        function checkForgeInteraction() {
            if (!buildPhase || !hasForge()) return false;
            
            // Check if player is near a forge
            for (let b of buildings) {
                if (b.type === 'forge') {
                    const dist = distance(player, { x: b.x + GRID_SIZE/2, y: b.y + GRID_SIZE/2 });
                    if (dist < GRID_SIZE * 1.5) {
                        return true;
                    }
                }
            }
            return false;
        }
        
        // ============ STABLE SYSTEM ============
        
        function hasStable() {
            return buildings.some(b => b.type === 'stable');
        }
        
        function openStable() {
            if (!hasStable()) return;
            
            stableOpen = true;
            isPaused = true;
            document.getElementById('stable-screen').classList.remove('hidden');
            updateStableContent();
        }
        
        function closeStable() {
            stableOpen = false;
            isPaused = false;
            document.getElementById('stable-screen').classList.add('hidden');
        }
        
        function updateStableContent() {
            const content = document.getElementById('stable-content');
            content.innerHTML = '';
            
            for (let type in HORSE_TYPES) {
                const horse = HORSE_TYPES[type];
                const isOwned = player.horse && player.horse.type === type;
                const canAfford = bounty >= horse.cost;
                
                const div = document.createElement('div');
                div.className = `horse-card ${isOwned ? 'owned' : ''} ${(!canAfford && !isOwned) ? 'disabled' : ''}`;
                
                let statsHtml = `HP: ${horse.health}`;
                if (horse.speedBonus) statsHtml += `<br>+${Math.round(horse.speedBonus * 100)}% Speed`;
                if (horse.damageBonus) statsHtml += `<br>+${horse.damageBonus} Damage`;
                
                div.innerHTML = `
                    <div class="horse-card-icon">${horse.icon}</div>
                    <div class="horse-card-name">${horse.name}</div>
                    <div class="horse-card-stats">${statsHtml}<br><em>${horse.description}</em></div>
                    ${isOwned ? 
                        '<div class="horse-card-cost" style="color: #4ade80">OWNED</div>' : 
                        `<div class="horse-card-cost">${canAfford ? '' : ' '}$${horse.cost}</div>`
                    }
                `;
                
                if (canAfford && !isOwned) {
                    div.onclick = () => purchaseHorse(type);
                }
                
                content.appendChild(div);
            }
            
            // Update current horse display
            const currentInfo = document.getElementById('current-horse-info');
            if (player.horse) {
                const horseType = HORSE_TYPES[player.horse.type];
                currentInfo.innerHTML = `${horseType.icon} ${horseType.name} - HP: ${player.horse.health}/${player.horse.maxHealth}`;
            } else {
                currentInfo.textContent = 'None';
            }
        }
        
        function purchaseHorse(type) {
            const horseData = HORSE_TYPES[type];
            if (!horseData || bounty < horseData.cost) return;
            
            bounty -= horseData.cost;
            if (isNaN(bounty)) bounty = 0;
            
            player.horse = {
                type: type,
                health: horseData.health,
                maxHealth: horseData.health,
                speedBonus: horseData.speedBonus || 0,
                damageBonus: horseData.damageBonus || 0
            };
            
            // Particles
            for (let i = 0; i < 15; i++) {
                particles.push({
                    x: player.x,
                    y: player.y,
                    vx: (Math.random() - 0.5) * 6,
                    vy: -Math.random() * 4 - 1,
                    life: 30,
                    color: '#84cc16',
                    radius: 3
                });
            }
            
            updateHUD();
            updateStableContent();
        }
        
        function checkStableInteraction() {
            if (!buildPhase || !hasStable()) return false;
            
            // Check if player is near a stable
            for (let b of buildings) {
                if (b.type === 'stable') {
                    const dist = distance(player, { x: b.x + GRID_SIZE/2, y: b.y + GRID_SIZE/2 });
                    if (dist < GRID_SIZE * 1.5) {
                        return true;
                    }
                }
            }
            return false;
        }
        
        function damageHorse(amount) {
            if (!player.horse) return amount; // No horse, return full damage
            
            // Horse takes damage first
            const horseAbsorbed = Math.min(player.horse.health, amount);
            player.horse.health -= horseAbsorbed;
            
            // Horse death particles
            if (player.horse.health <= 0) {
                for (let i = 0; i < 20; i++) {
                    particles.push({
                        x: player.x,
                        y: player.y,
                        vx: (Math.random() - 0.5) * 8,
                        vy: (Math.random() - 0.5) * 8,
                        life: 35,
                        color: '#84cc16',
                        radius: 4
                    });
                }
                player.horse = null;
            }
            
            updateHUD();
            
            // Return remaining damage to player
            return amount - horseAbsorbed;
        }
        
        function recalculateArmorStats() {
            // Safety check
            if (!player || !player.armorSlots) return;
            
            // Reset armor-based stats
            let totalCurrentArmor = 0;
            let totalMaxArmor = 0;
            let armorBonuses = {
                critChance: 0,
                xpBonus: 0,
                damageReduction: 0,
                healthRegen: 0,
                attackSpeed: 0,
                damage: 0,
                moveSpeed: 0,
                dodge: 0,
                bountyBonus: 0,
                healthBonus: 0,
                knockback: 0
            };
            
            // Sum up all equipped armor
            for (let slot in player.armorSlots) {
                const armor = player.armorSlots[slot];
                if (armor) {
                    // Ensure armor has durability properties
                    if (armor.maxArmor === undefined) {
                        armor.maxArmor = armor.armor;
                        armor.currentArmor = armor.armor;
                    }
                    
                    totalCurrentArmor += armor.currentArmor || 0;
                    totalMaxArmor += armor.maxArmor || armor.armor;
                    
                    // Add bonuses
                    if (armor.bonus) {
                        for (let bonus in armor.bonus) {
                            armorBonuses[bonus] = (armorBonuses[bonus] || 0) + armor.bonus[bonus];
                        }
                    }
                }
            }
            
            // Apply armor - current and max based on equipped pieces
            player.maxArmor = Math.max(50, totalMaxArmor + (armorBonuses.healthBonus || 0));
            player.armor = Math.min(totalCurrentArmor + player.bonusArmor, player.maxArmor);
            
            // Store bonuses for use in combat/movement
            player.armorBonuses = armorBonuses;
            
            // Update visual based on body armor grade
            if (player.armorSlots.body) {
                const grade = player.armorSlots.body.grade || 'common';
                const gradeVisuals = {
                    common: { torsoColor: '#8b4513', torsoAccent: '#654321', hasShoulders: false, pattern: 'plain' },
                    uncommon: { torsoColor: '#3d6b3d', torsoAccent: '#2d5a2d', hasShoulders: true, shoulderColor: '#4d7b4d', pattern: 'plain' },
                    rare: { torsoColor: '#4a6a9a', torsoAccent: '#3a5a8a', hasShoulders: true, shoulderColor: '#5a7aaa', pattern: 'chain' },
                    epic: { torsoColor: '#7a4a9a', torsoAccent: '#6a3a8a', hasShoulders: true, shoulderColor: '#8a5aaa', pattern: 'plate' },
                    legendary: { torsoColor: '#ffd700', torsoAccent: '#daa520', hasShoulders: true, shoulderColor: '#ffed4a', pattern: 'ornate', glow: true }
                };
                player.armorVisual = gradeVisuals[grade] || gradeVisuals.common;
            }
            
            updateHUD();
        }
        
        function getArmorBonuses() {
            return player.armorBonuses || {};
        }
        
        function showWeaponSwapScreen(weaponDrop, dropId) {
            isPaused = true;
            pendingWeapon = weaponDrop.weapon;
            pendingWeaponIndex = dropId; // Now stores ID instead of index
            
            // Determine if this is a melee or ranged weapon
            const isMelee = weaponDrop.weapon.melee || false;
            const currentWeapon = isMelee ? player.meleeWeapon : player.rangedWeapon;
            const newWeapon = weaponDrop.weapon;
            
            // Store which slot we're swapping
            pendingWeaponSlot = isMelee ? 'melee' : 'ranged';
            
            // Update swap screen title
            const title = document.querySelector('.swap-title');
            if (title) {
                title.textContent = isMelee ? 'New Melee Weapon!' : 'New Ranged Weapon!';
            }
            
            // Update current weapon display
            document.getElementById('current-weapon-name').textContent = currentWeapon.name;
            document.getElementById('current-weapon-name').style.color = currentWeapon.rarityColor || '#9ca3af';
            
            // Update new weapon display
            document.getElementById('new-weapon-name').textContent = newWeapon.name;
            document.getElementById('new-weapon-name').style.color = newWeapon.rarityColor;
            
            // Draw weapon previews
            drawWeaponPreview('current-weapon-canvas', currentWeapon);
            drawWeaponPreview('new-weapon-canvas', newWeapon);
            
            // Build stats comparison
            const currentStats = document.getElementById('current-weapon-stats');
            const newStats = document.getElementById('new-weapon-stats');
            
            currentStats.innerHTML = '';
            newStats.innerHTML = '';
            
            // Compare stats
            const stats = [
                { label: 'Damage', current: currentWeapon.damage, new: newWeapon.damage, higherBetter: true },
                { label: 'Fire Rate', current: (1000/currentWeapon.fireRate).toFixed(1), new: (1000/newWeapon.fireRate).toFixed(1), higherBetter: true, suffix: '/s' },
                { label: 'Range', current: currentWeapon.range, new: newWeapon.range, higherBetter: true }
            ];
            
            stats.forEach(stat => {
                const currentVal = parseFloat(stat.current);
                const newVal = parseFloat(stat.new);
                const suffix = stat.suffix || '';
                
                let currentClass = 'stat-same';
                let newClass = 'stat-same';
                
                if (newVal > currentVal) {
                    newClass = stat.higherBetter ? 'stat-better' : 'stat-worse';
                    currentClass = stat.higherBetter ? 'stat-worse' : 'stat-better';
                } else if (newVal < currentVal) {
                    newClass = stat.higherBetter ? 'stat-worse' : 'stat-better';
                    currentClass = stat.higherBetter ? 'stat-better' : 'stat-worse';
                }
                
                currentStats.innerHTML += `
                    <div class="weapon-stat-row">
                        <span class="weapon-stat-label">${stat.label}</span>
                        <span class="weapon-stat-value ${currentClass}">${stat.current}${suffix}</span>
                    </div>
                `;
                
                newStats.innerHTML += `
                    <div class="weapon-stat-row">
                        <span class="weapon-stat-label">${stat.label}</span>
                        <span class="weapon-stat-value ${newClass}">${stat.new}${suffix}</span>
                    </div>
                `;
            });
            
            // Update border colors
            document.querySelector('.weapon-card.new-weapon').style.borderColor = newWeapon.rarityColor;
            
            document.getElementById('weapon-swap-screen').classList.remove('hidden');
        }
        
        function drawWeaponPreview(canvasId, weapon) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.clearRect(0, 0, w, h);
            
            const rarity = weapon.rarity || 'common';
            const baseName = weapon.baseName || weapon.name.split(' ').pop();
            
            ctx.save();
            ctx.translate(w/2, h/2);
            
            // Draw based on rarity
            if (rarity === 'legendary') {
                drawLegendaryWeapon(ctx, baseName);
            } else if (rarity === 'rare') {
                drawRareWeapon(ctx, baseName);
            } else if (rarity === 'uncommon') {
                drawUncommonWeapon(ctx, baseName);
            } else {
                drawCommonWeapon(ctx, baseName);
            }
            
            ctx.restore();
        }
        
        function drawCommonWeapon(ctx, type) {
            ctx.scale(2.5, 2.5);
            
            if (type === 'Revolver') {
                ctx.fillStyle = '#4a3a2a';
                ctx.fillRect(-3, -30, 6, 22);
                ctx.fillStyle = '#6b3a1a';
                ctx.fillRect(-2, -28, 3, 4);
                ctx.fillRect(0, -22, 2, 5);
                ctx.fillStyle = '#3a3025';
                ctx.beginPath();
                ctx.arc(0, -6, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#1a1a1a';
                for (let i = 0; i < 6; i++) {
                    const a = (i / 6) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.arc(Math.cos(a) * 5, -6 + Math.sin(a) * 5, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.fillStyle = '#3d2517';
                ctx.fillRect(-4, 2, 8, 18);
            } else if (type === 'Shotgun') {
                ctx.rotate(-0.3);
                ctx.fillStyle = '#3a2a1a';
                ctx.fillRect(-6, -35, 5, 32);
                ctx.fillRect(1, -35, 5, 32);
                ctx.fillStyle = '#4a3a2a';
                ctx.fillRect(-7, -5, 14, 12);
                ctx.fillStyle = '#3d2010';
                ctx.beginPath();
                ctx.moveTo(-6, 7);
                ctx.lineTo(-7, 30);
                ctx.lineTo(7, 30);
                ctx.lineTo(6, 7);
                ctx.fill();
            } else if (type === 'Rifle') {
                ctx.rotate(-0.2);
                ctx.fillStyle = '#3a3025';
                ctx.fillRect(-3, -40, 6, 38);
                ctx.fillStyle = '#2a2520';
                ctx.fillRect(-4, -30, 8, 16);
                ctx.fillStyle = '#3d2517';
                ctx.beginPath();
                ctx.moveTo(-5, 0);
                ctx.lineTo(-6, 30);
                ctx.lineTo(6, 30);
                ctx.lineTo(5, 0);
                ctx.fill();
            } else if (type === 'Repeater') {
                ctx.rotate(-0.25);
                ctx.fillStyle = '#3a3025';
                ctx.fillRect(-3, -35, 6, 32);
                ctx.fillStyle = '#6b5020';
                ctx.fillRect(-6, -5, 12, 14);
                ctx.fillStyle = '#5a4515';
                ctx.beginPath();
                ctx.ellipse(0, 16, 6, 8, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#3d2517';
                ctx.beginPath();
                ctx.moveTo(-5, 8);
                ctx.lineTo(-6, 30);
                ctx.lineTo(6, 30);
                ctx.lineTo(5, 8);
                ctx.fill();
            } else if (type === 'Dual Pistols') {
                for (let s = -1; s <= 1; s += 2) {
                    ctx.save();
                    ctx.rotate(s * 0.4);
                    ctx.translate(s * 8, 0);
                    ctx.fillStyle = '#4a3a2a';
                    ctx.fillRect(-3, -25, 6, 20);
                    ctx.fillStyle = '#2a2015';
                    ctx.fillRect(-4, -3, 8, 18);
                    ctx.restore();
                }
            }
        }
        
        function drawUncommonWeapon(ctx, type) {
            ctx.scale(2.5, 2.5);
            
            if (type === 'Revolver') {
                const barrelGrad = ctx.createLinearGradient(-3, 0, 3, 0);
                barrelGrad.addColorStop(0, '#4a4a4a');
                barrelGrad.addColorStop(0.5, '#6a6a6a');
                barrelGrad.addColorStop(1, '#4a4a4a');
                ctx.fillStyle = barrelGrad;
                ctx.fillRect(-3, -30, 6, 22);
                const cylGrad = ctx.createRadialGradient(0, -6, 0, 0, -6, 8);
                cylGrad.addColorStop(0, '#7a7a7a');
                cylGrad.addColorStop(1, '#4a4a4a');
                ctx.fillStyle = cylGrad;
                ctx.beginPath();
                ctx.arc(0, -6, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#1a1a1a';
                for (let i = 0; i < 6; i++) {
                    const a = (i / 6) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.arc(Math.cos(a) * 5, -6 + Math.sin(a) * 5, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                const gripGrad = ctx.createLinearGradient(-4, 0, 4, 0);
                gripGrad.addColorStop(0, '#5a3520');
                gripGrad.addColorStop(0.5, '#8b5030');
                gripGrad.addColorStop(1, '#5a3520');
                ctx.fillStyle = gripGrad;
                ctx.fillRect(-4, 2, 8, 18);
            } else if (type === 'Shotgun') {
                ctx.rotate(-0.3);
                const barrelGrad = ctx.createLinearGradient(-6, 0, 6, 0);
                barrelGrad.addColorStop(0, '#3a3a3a');
                barrelGrad.addColorStop(0.5, '#5a5a5a');
                barrelGrad.addColorStop(1, '#3a3a3a');
                ctx.fillStyle = barrelGrad;
                ctx.fillRect(-6, -35, 5, 32);
                ctx.fillRect(1, -35, 5, 32);
                ctx.fillStyle = '#5a5a5a';
                ctx.fillRect(-7, -5, 14, 12);
                const stockGrad = ctx.createLinearGradient(-6, 0, 6, 0);
                stockGrad.addColorStop(0, '#5a3520');
                stockGrad.addColorStop(0.5, '#8b5030');
                stockGrad.addColorStop(1, '#5a3520');
                ctx.fillStyle = stockGrad;
                ctx.beginPath();
                ctx.moveTo(-6, 7);
                ctx.lineTo(-7, 30);
                ctx.lineTo(7, 30);
                ctx.lineTo(6, 7);
                ctx.fill();
            } else if (type === 'Rifle') {
                ctx.rotate(-0.2);
                ctx.fillStyle = '#4a4a5a';
                ctx.fillRect(-3, -40, 6, 38);
                ctx.fillStyle = '#3a3a4a';
                ctx.fillRect(-4, -30, 8, 16);
                ctx.fillStyle = '#4ecdc4';
                ctx.globalAlpha = 0.5;
                ctx.beginPath();
                ctx.ellipse(0, -28, 3, 2, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
                const stockGrad = ctx.createLinearGradient(-5, 0, 5, 0);
                stockGrad.addColorStop(0, '#5a3520');
                stockGrad.addColorStop(0.5, '#8b5030');
                stockGrad.addColorStop(1, '#5a3520');
                ctx.fillStyle = stockGrad;
                ctx.beginPath();
                ctx.moveTo(-5, 0);
                ctx.lineTo(-6, 30);
                ctx.lineTo(6, 30);
                ctx.lineTo(5, 0);
                ctx.fill();
            } else if (type === 'Repeater') {
                ctx.rotate(-0.25);
                ctx.fillStyle = '#4a4a4a';
                ctx.fillRect(-3, -35, 6, 32);
                const brassGrad = ctx.createLinearGradient(-6, 0, 6, 0);
                brassGrad.addColorStop(0, '#8b7020');
                brassGrad.addColorStop(0.5, '#c9a030');
                brassGrad.addColorStop(1, '#8b7020');
                ctx.fillStyle = brassGrad;
                ctx.fillRect(-6, -5, 12, 14);
                ctx.beginPath();
                ctx.ellipse(0, 16, 6, 8, 0, 0, Math.PI * 2);
                ctx.fill();
                const stockGrad = ctx.createLinearGradient(-5, 0, 5, 0);
                stockGrad.addColorStop(0, '#5a3520');
                stockGrad.addColorStop(0.5, '#8b5030');
                stockGrad.addColorStop(1, '#5a3520');
                ctx.fillStyle = stockGrad;
                ctx.beginPath();
                ctx.moveTo(-5, 8);
                ctx.lineTo(-6, 30);
                ctx.lineTo(6, 30);
                ctx.lineTo(5, 8);
                ctx.fill();
            } else if (type === 'Dual Pistols') {
                for (let s = -1; s <= 1; s += 2) {
                    ctx.save();
                    ctx.rotate(s * 0.4);
                    ctx.translate(s * 8, 0);
                    const slideGrad = ctx.createLinearGradient(-3, 0, 3, 0);
                    slideGrad.addColorStop(0, '#6a6a6a');
                    slideGrad.addColorStop(0.5, '#9a9a9a');
                    slideGrad.addColorStop(1, '#6a6a6a');
                    ctx.fillStyle = slideGrad;
                    ctx.fillRect(-3, -25, 6, 20);
                    ctx.fillStyle = '#1a1a1a';
                    ctx.fillRect(-4, -3, 8, 18);
                    ctx.restore();
                }
            }
        }
        
        function drawRareWeapon(ctx, type) {
            ctx.scale(2.5, 2.5);
            ctx.fillStyle = 'rgba(168, 85, 247, 0.2)';
            ctx.beginPath();
            ctx.arc(0, 0, 35, 0, Math.PI * 2);
            ctx.fill();
            
            if (type === 'Revolver') {
                const barrelGrad = ctx.createLinearGradient(-3, 0, 3, 0);
                barrelGrad.addColorStop(0, '#4a4a5a');
                barrelGrad.addColorStop(0.5, '#7a7a9a');
                barrelGrad.addColorStop(1, '#4a4a5a');
                ctx.fillStyle = barrelGrad;
                ctx.fillRect(-3, -30, 6, 22);
                ctx.strokeStyle = '#a855f7';
                ctx.lineWidth = 0.8;
                for (let y = -28; y < -10; y += 3) {
                    ctx.beginPath();
                    ctx.moveTo(-2, y);
                    ctx.bezierCurveTo(0, y + 1.5, 0, y + 1.5, 2, y);
                    ctx.stroke();
                }
                const cylGrad = ctx.createRadialGradient(0, -6, 0, 0, -6, 8);
                cylGrad.addColorStop(0, '#8a8aaa');
                cylGrad.addColorStop(1, '#5a5a7a');
                ctx.fillStyle = cylGrad;
                ctx.beginPath();
                ctx.arc(0, -6, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#a855f7';
                ctx.lineWidth = 0.6;
                ctx.beginPath();
                ctx.arc(0, -6, 6.5, 0, Math.PI * 2);
                ctx.stroke();
                ctx.fillStyle = '#1a1a1a';
                for (let i = 0; i < 6; i++) {
                    const a = (i / 6) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.arc(Math.cos(a) * 5, -6 + Math.sin(a) * 5, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                const gripGrad = ctx.createLinearGradient(-4, 0, 4, 0);
                gripGrad.addColorStop(0, '#4a2520');
                gripGrad.addColorStop(0.5, '#6b3530');
                gripGrad.addColorStop(1, '#4a2520');
                ctx.fillStyle = gripGrad;
                ctx.fillRect(-4, 2, 8, 18);
                ctx.strokeStyle = '#a855f7';
                ctx.lineWidth = 0.8;
                ctx.beginPath();
                ctx.moveTo(-2, 5);
                ctx.quadraticCurveTo(0, 12, -2, 17);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(2, 5);
                ctx.quadraticCurveTo(0, 12, 2, 17);
                ctx.stroke();
            } else {
                drawUncommonWeapon(ctx, type);
            }
        }
        
        function drawLegendaryWeapon(ctx, type) {
            ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
            ctx.beginPath();
            ctx.arc(0, 0, 55, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'rgba(255, 180, 0, 0.2)';
            ctx.beginPath();
            ctx.arc(0, 0, 45, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.scale(2.5, 2.5);
            
            if (type === 'Revolver') {
                ctx.fillStyle = '#2a2a2a';
                ctx.fillRect(-4, -32, 8, 24);
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 0.7;
                for (let y = -30; y < -10; y += 2) {
                    ctx.beginPath();
                    ctx.moveTo(-3, y);
                    for (let x = -3; x <= 3; x += 0.5) {
                        ctx.lineTo(x, y + Math.sin((x + y) * 0.8) * 1.2);
                    }
                    ctx.stroke();
                }
                ctx.fillStyle = '#ffd700';
                ctx.beginPath();
                ctx.moveTo(0, -35);
                ctx.lineTo(-2, -32);
                ctx.lineTo(2, -32);
                ctx.fill();
                ctx.fillStyle = '#1a1a1a';
                ctx.beginPath();
                ctx.arc(0, -6, 10, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 0.5;
                for (let r = 3; r <= 9; r += 1.5) {
                    ctx.beginPath();
                    ctx.arc(0, -6, r, 0, Math.PI * 2);
                    ctx.stroke();
                }
                for (let i = 0; i < 12; i++) {
                    const a = (i / 12) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.moveTo(Math.cos(a) * 3, -6 + Math.sin(a) * 3);
                    ctx.lineTo(Math.cos(a) * 9, -6 + Math.sin(a) * 9);
                    ctx.stroke();
                }
                ctx.fillStyle = '#0a0a0a';
                for (let i = 0; i < 6; i++) {
                    const a = (i / 6) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.arc(Math.cos(a) * 6, -6 + Math.sin(a) * 6, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.fillStyle = '#ffd700';
                for (let i = 0; i < 6; i++) {
                    const a = (i / 6) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.arc(Math.cos(a) * 6, -6 + Math.sin(a) * 6, 1.2, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(-5, 4, 10, 6);
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-4, 9);
                ctx.quadraticCurveTo(-7, 18, 0, 22);
                ctx.quadraticCurveTo(7, 18, 4, 9);
                ctx.stroke();
                ctx.fillStyle = '#1a1008';
                ctx.beginPath();
                ctx.moveTo(-5, 10);
                ctx.quadraticCurveTo(-8, 20, -6, 32);
                ctx.lineTo(6, 32);
                ctx.quadraticCurveTo(8, 20, 5, 10);
                ctx.fill();
                ctx.strokeStyle = '#c9a030';
                ctx.lineWidth = 0.4;
                for (let y = 12; y < 30; y += 2) {
                    ctx.beginPath();
                    ctx.moveTo(-5, y);
                    for (let x = -5; x <= 5; x += 0.8) {
                        ctx.lineTo(x, y + Math.sin((x * 2 + y) * 0.5) * 1.5);
                    }
                    ctx.stroke();
                }
                ctx.fillStyle = '#ffd700';
                ctx.beginPath();
                ctx.arc(0, 21, 3, 0, Math.PI * 2);
                ctx.fill();
            } else if (type === 'Shotgun') {
                ctx.rotate(-0.3);
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(-7, -38, 6, 36);
                ctx.fillRect(1, -38, 6, 36);
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 0.5;
                for (let y = -36; y < -4; y += 2.5) {
                    ctx.beginPath();
                    ctx.moveTo(-6, y);
                    for (let x = -6; x <= -2; x += 0.5) {
                        ctx.lineTo(x, y + Math.sin((x + y) * 0.6) * 1);
                    }
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(2, y);
                    for (let x = 2; x <= 6; x += 0.5) {
                        ctx.lineTo(x, y + Math.sin((x + y) * 0.6) * 1);
                    }
                    ctx.stroke();
                }
                ctx.fillStyle = '#ffd700';
                ctx.beginPath();
                ctx.arc(0, -40, 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(-9, -4, 18, 14);
                ctx.strokeStyle = '#ffd700';
                ctx.strokeRect(-8, -3, 16, 12);
                for (let y = -2; y < 8; y += 2) {
                    ctx.beginPath();
                    ctx.moveTo(-7, y);
                    for (let x = -7; x <= 7; x += 0.5) {
                        ctx.lineTo(x, y + Math.sin((x + y) * 0.4) * 1.2);
                    }
                    ctx.stroke();
                }
                ctx.fillStyle = '#ffd700';
                ctx.fillRect(-3, 8, 2.5, 4);
                ctx.fillRect(0.5, 8, 2.5, 4);
                ctx.fillStyle = '#1a1008';
                ctx.beginPath();
                ctx.moveTo(-8, 10);
                ctx.lineTo(-9, 35);
                ctx.lineTo(9, 35);
                ctx.lineTo(8, 10);
                ctx.fill();
                ctx.strokeStyle = '#c9a030';
                ctx.lineWidth = 0.4;
                for (let y = 12; y < 33; y += 2.5) {
                    ctx.beginPath();
                    ctx.moveTo(-7, y);
                    for (let x = -7; x <= 7; x += 0.8) {
                        ctx.lineTo(x, y + Math.sin((x * 2 + y) * 0.3) * 1.5);
                    }
                    ctx.stroke();
                }
            } else if (type === 'Rifle') {
                ctx.rotate(-0.2);
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(-3, -42, 6, 40);
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 0.5;
                for (let y = -40; y < -4; y += 2) {
                    ctx.beginPath();
                    ctx.moveTo(-2, y);
                    for (let x = -2; x <= 2; x += 0.4) {
                        ctx.lineTo(x, y + Math.sin((x + y) * 0.7) * 0.8);
                    }
                    ctx.stroke();
                }
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(-5, -32, 10, 20);
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 0.6;
                ctx.strokeRect(-4.5, -31.5, 9, 19);
                ctx.fillStyle = '#ffd700';
                ctx.fillRect(-5.5, -30, 11, 2);
                ctx.fillRect(-5.5, -16, 11, 2);
                ctx.fillStyle = '#4ecdc4';
                ctx.globalAlpha = 0.7;
                ctx.beginPath();
                ctx.ellipse(0, -30, 3.5, 2, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
                ctx.fillStyle = '#1a1008';
                ctx.beginPath();
                ctx.moveTo(-6, -2);
                ctx.lineTo(-7, 32);
                ctx.lineTo(7, 32);
                ctx.lineTo(6, -2);
                ctx.fill();
                ctx.strokeStyle = '#c9a030';
                ctx.lineWidth = 0.4;
                for (let y = 0; y < 30; y += 2.5) {
                    ctx.beginPath();
                    ctx.moveTo(-5, y);
                    for (let x = -5; x <= 5; x += 0.8) {
                        ctx.lineTo(x, y + Math.sin((x * 2 + y) * 0.35) * 1.2);
                    }
                    ctx.stroke();
                }
            } else if (type === 'Repeater') {
                ctx.rotate(-0.25);
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(-3, -38, 6, 35);
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 0.5;
                for (let y = -36; y < -5; y += 2) {
                    ctx.beginPath();
                    ctx.moveTo(-2, y);
                    for (let x = -2; x <= 2; x += 0.4) {
                        ctx.lineTo(x, y + Math.sin((x + y) * 0.6) * 0.8);
                    }
                    ctx.stroke();
                }
                ctx.fillStyle = '#ffd700';
                ctx.fillRect(-4, -30, 8, 2);
                ctx.fillRect(-4, -20, 8, 2);
                const brassGrad = ctx.createLinearGradient(-7, 0, 7, 0);
                brassGrad.addColorStop(0, '#8b6914');
                brassGrad.addColorStop(0.3, '#ffd700');
                brassGrad.addColorStop(0.5, '#ffed80');
                brassGrad.addColorStop(0.7, '#ffd700');
                brassGrad.addColorStop(1, '#8b6914');
                ctx.fillStyle = brassGrad;
                ctx.fillRect(-7, -5, 14, 14);
                ctx.strokeStyle = '#4a3510';
                ctx.lineWidth = 0.5;
                for (let y = -4; y < 8; y += 1.8) {
                    ctx.beginPath();
                    ctx.moveTo(-6, y);
                    for (let x = -6; x <= 6; x += 0.5) {
                        ctx.lineTo(x, y + Math.sin((x + y) * 0.5) * 1);
                    }
                    ctx.stroke();
                }
                ctx.fillStyle = brassGrad;
                ctx.beginPath();
                ctx.moveTo(-5, 9);
                ctx.quadraticCurveTo(-9, 18, -4, 26);
                ctx.quadraticCurveTo(0, 30, 4, 26);
                ctx.quadraticCurveTo(9, 18, 5, 9);
                ctx.fill();
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.beginPath();
                ctx.ellipse(0, 18, 3, 5, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#1a1008';
                ctx.beginPath();
                ctx.moveTo(-6, 9);
                ctx.lineTo(-7, 35);
                ctx.lineTo(7, 35);
                ctx.lineTo(6, 9);
                ctx.fill();
                ctx.strokeStyle = '#c9a030';
                ctx.lineWidth = 0.4;
                for (let y = 11; y < 33; y += 2.5) {
                    ctx.beginPath();
                    ctx.moveTo(-5, y);
                    for (let x = -5; x <= 5; x += 0.8) {
                        ctx.lineTo(x, y + Math.sin((x * 2 + y) * 0.35) * 1.2);
                    }
                    ctx.stroke();
                }
            } else if (type === 'Dual Pistols') {
                for (let s = -1; s <= 1; s += 2) {
                    ctx.save();
                    ctx.rotate(s * 0.35);
                    ctx.translate(s * 10, 0);
                    ctx.fillStyle = '#1a1a1a';
                    ctx.fillRect(-4, -28, 8, 24);
                    ctx.strokeStyle = '#ffd700';
                    ctx.lineWidth = 0.5;
                    for (let y = -26; y < -6; y += 2) {
                        ctx.beginPath();
                        ctx.moveTo(-3, y);
                        for (let x = -3; x <= 3; x += 0.5) {
                            ctx.lineTo(x, y + Math.sin((x + y) * 0.6) * 0.8);
                        }
                        ctx.stroke();
                    }
                    ctx.fillStyle = '#ffd700';
                    ctx.fillRect(-4, -28, 8, 1.5);
                    ctx.fillRect(-4, -6, 8, 1.5);
                    ctx.fillStyle = '#ff3333';
                    ctx.beginPath();
                    ctx.arc(0, -29, 1.2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#1a1008';
                    ctx.fillRect(-5, -3, 10, 20);
                    ctx.strokeStyle = '#c9a030';
                    ctx.lineWidth = 0.4;
                    for (let y = -1; y < 15; y += 2) {
                        ctx.beginPath();
                        ctx.moveTo(-4, y);
                        for (let x = -4; x <= 4; x += 0.6) {
                            ctx.lineTo(x, y + Math.sin((x * 2 + y) * 0.5) * 1);
                        }
                        ctx.stroke();
                    }
                    ctx.fillStyle = '#ffd700';
                    ctx.fillRect(-4, 15, 8, 2);
                    ctx.restore();
                }
            }
        }
        
        function keepCurrentWeapon() {
            // Remove the weapon drop from the ground
            const dropIndex = drops.findIndex(d => d.id === pendingWeaponIndex);
            if (dropIndex >= 0) {
                const drop = drops[dropIndex];
                // Particles for discarding
                for (let i = 0; i < 5; i++) {
                    particles.push({
                        x: drop.x,
                        y: drop.y,
                        vx: (Math.random() - 0.5) * 3,
                        vy: -Math.random() * 2,
                        life: 15,
                        color: '#888',
                        radius: 2
                    });
                }
                drops.splice(dropIndex, 1);
            }
            
            pendingWeapon = null;
            pendingWeaponIndex = -1;
            pendingWeaponSlot = 'melee';
            isPaused = false;
            document.getElementById('weapon-swap-screen').classList.add('hidden');
        }
        
        function swapToNewWeapon() {
            if (pendingWeapon) {
                // Equip the new weapon to the appropriate slot
                if (pendingWeaponSlot === 'melee') {
                    player.meleeWeapon = pendingWeapon;
                } else {
                    player.rangedWeapon = pendingWeapon;
                }
                
                // Update HUD
                updateHUD();
                
                // Find and remove drop by ID
                const dropIndex = drops.findIndex(d => d.id === pendingWeaponIndex);
                if (dropIndex >= 0) {
                    const drop = drops[dropIndex];
                    // Pickup particles
                    for (let i = 0; i < 10; i++) {
                        particles.push({
                            x: drop.x,
                            y: drop.y,
                            vx: (Math.random() - 0.5) * 5,
                            vy: (Math.random() - 0.5) * 5,
                            life: 20,
                            color: pendingWeapon.rarityColor,
                            radius: 4
                        });
                    }
                    drops.splice(dropIndex, 1);
                }
            }
            
            pendingWeapon = null;
            pendingWeaponIndex = -1;
            pendingWeaponSlot = 'melee';
            isPaused = false;
            document.getElementById('weapon-swap-screen').classList.add('hidden');
        }

        // ============ BUILDING SYSTEM ============
        
        let buildMinimized = false;
        
        function toggleBuildMinimize() {
            buildMinimized = !buildMinimized;
            const ui = document.getElementById('build-phase-ui');
            const btn = document.getElementById('minimize-btn');
            
            if (buildMinimized) {
                ui.classList.add('minimized');
                btn.textContent = '+';
                btn.title = 'Restore';
            } else {
                ui.classList.remove('minimized');
                btn.textContent = '';
                btn.title = 'Minimize';
            }
        }
        
        function startBuildPhase() {
            buildPhase = true;
            buildMinimized = false; // Reset minimized state
            // Don't pause - allow player to move during build phase
            selectedBuildingType = 'wall'; // Default selection
            repairMode = false;
            upgradeMode = false;
            deleteMode = false;
            
            document.getElementById('build-wave').textContent = wave;
            document.getElementById('next-wave').textContent = wave + 1;
            document.getElementById('next-wave-min').textContent = wave + 1;
            document.getElementById('build-phase-ui').classList.remove('hidden');
            document.getElementById('build-phase-ui').classList.remove('minimized');
            document.getElementById('minimize-btn').textContent = '';
            
            updateBuildMenuAvailability();
            updateDamagedBuildingsInfo();
            selectBuilding('wall');
        }
        
        function endBuildPhase() {
            buildPhase = false;
            buildMinimized = false;
            selectedBuildingType = null;
            repairMode = false;
            upgradeMode = false;
            deleteMode = false;
            
            document.getElementById('build-phase-ui').classList.add('hidden');
            document.getElementById('build-phase-ui').classList.remove('minimized');
            document.getElementById('damaged-buildings-info').classList.add('hidden');
            document.querySelectorAll('.build-option').forEach(el => el.classList.remove('selected'));
            
            // Start next wave
            wave++;
            waveTimer = 0;
            bossSpawned = false;
            bossDefeated = false;
            
            // Update wave display - show BOSS for boss waves
            const nextIsBoss = (wave % 5 === 0);
            document.getElementById('wave-display').textContent = nextIsBoss ? `Wave ${wave} - BOSS` : `Wave ${wave}`;
        }
        
        function updateBuildMenuAvailability() {
            for (let type in BUILDING_TYPES) {
                const building = BUILDING_TYPES[type];
                const element = document.getElementById(`build-${type}`);
                if (element) {
                    if (bounty >= building.cost) {
                        element.classList.remove('disabled');
                    } else {
                        element.classList.add('disabled');
                    }
                }
            }
            
            // Update repair button
            const repairEl = document.getElementById('build-repair');
            if (repairEl) {
                const hasDamaged = getDamagedBuildingsCount() > 0;
                // Check if player can afford to repair at least one building
                const canAffordAnyRepair = hasDamaged && buildings.some(b => {
                    if (b.health >= b.maxHealth) return false;
                    return bounty >= getRepairCost(b);
                });
                if (canAffordAnyRepair) {
                    repairEl.classList.remove('disabled');
                } else {
                    repairEl.classList.add('disabled');
                }
            }
            
            // Update siege weapon availability
            for (let type in SIEGE_TYPES) {
                const siege = SIEGE_TYPES[type];
                const element = document.getElementById(`siege-${type}`);
                if (element) {
                    if (bounty >= siege.cost) {
                        element.classList.remove('disabled');
                    } else {
                        element.classList.add('disabled');
                    }
                }
            }
        }
        
        function switchBuildCategory(category) {
            buildCategory = category;
            selectedBuildingType = null;
            selectedSiegeType = null;
            repairMode = false;
            
            // Update tabs
            document.querySelectorAll('.build-tab').forEach(el => el.classList.remove('active'));
            document.getElementById(`tab-${category}`).classList.add('active');
            
            // Show/hide options
            document.getElementById('structures-options').classList.toggle('hidden', category !== 'structures');
            document.getElementById('siege-options').classList.toggle('hidden', category !== 'siege');
            
            // Clear selection
            document.querySelectorAll('.build-option').forEach(el => el.classList.remove('selected'));
            document.getElementById('siege-info').textContent = '';
        }
        
        function selectBuilding(type) {
            const building = BUILDING_TYPES[type];
            if (!building) return;
            
            // Clear other modes and siege selection
            repairMode = false;
            upgradeMode = false;
            deleteMode = false;
            selectedSiegeType = null;
            document.getElementById('build-repair').classList.remove('selected');
            
            // Clear previous selection
            document.querySelectorAll('.build-option').forEach(el => el.classList.remove('selected'));
            const element = document.getElementById(`build-${type}`);
            if (element) {
                element.classList.add('selected');
            }
            
            selectedBuildingType = type;
            document.getElementById('siege-info').textContent = '';
        }
        
        function selectSiege(type) {
            const siege = SIEGE_TYPES[type];
            if (!siege) return;
            
            // Clear building selection and modes
            selectedBuildingType = null;
            repairMode = false;
            upgradeMode = false;
            deleteMode = false;
            
            // Clear previous selection
            document.querySelectorAll('.build-option').forEach(el => el.classList.remove('selected'));
            const element = document.getElementById(`siege-${type}`);
            if (element) {
                element.classList.add('selected');
            }
            
            selectedSiegeType = type;
            
            // Show siege info
            const info = `${siege.description} | DMG: ${siege.damage} | Range: ${siege.range} | Rate: ${(siege.fireRate/1000).toFixed(1)}s`;
            document.getElementById('siege-info').textContent = info;
        }
        
        function selectRepairMode() {
            repairMode = true;
            upgradeMode = false;
            deleteMode = false;
            selectedBuildingType = null;
            selectedSiegeType = null;
            
            // Clear other selections
            document.querySelectorAll('.build-option').forEach(el => el.classList.remove('selected'));
            document.getElementById('build-repair').classList.add('selected');
            document.getElementById('siege-info').textContent = 'Click a damaged building to repair it';
        }
        
        function selectUpgradeMode() {
            upgradeMode = true;
            repairMode = false;
            deleteMode = false;
            selectedBuildingType = null;
            selectedSiegeType = null;
            
            // Clear other selections
            document.querySelectorAll('.build-option').forEach(el => el.classList.remove('selected'));
            document.getElementById('build-upgrade').classList.add('selected');
            document.getElementById('siege-info').textContent = 'Click a building to upgrade it';
        }
        
        function selectDeleteMode() {
            deleteMode = true;
            repairMode = false;
            upgradeMode = false;
            selectedBuildingType = null;
            selectedSiegeType = null;
            
            // Clear other selections
            document.querySelectorAll('.build-option').forEach(el => el.classList.remove('selected'));
            document.getElementById('build-delete').classList.add('selected');
            document.getElementById('siege-info').textContent = 'Click a building to delete it (50% refund)';
        }
        
        function deleteBuilding(worldX, worldY) {
            if (!buildPhase || !deleteMode) return false;
            
            const grid = worldToGrid(worldX, worldY);
            const building = getBuildingAt(grid.gx, grid.gy);
            
            if (!building) return false;
            
            // Calculate refund based on building type and tier
            let baseCost = BUILDING_TYPES[building.type] ? BUILDING_TYPES[building.type].cost : 0;
            let totalInvested = baseCost;
            
            // Add upgrade costs if upgraded
            if (building.wallTier && building.wallTier > 1) {
                let tierData;
                if (building.type === 'wall') tierData = WALL_TIERS;
                else if (building.type === 'tower') tierData = TOWER_TIERS;
                else if (building.type === 'gate') tierData = GATE_TIERS;
                
                if (tierData) {
                    for (let t = 1; t < building.wallTier; t++) {
                        totalInvested += tierData[t].upgradeCost || 0;
                    }
                }
            }
            
            const refund = Math.floor(totalInvested * DELETE_REFUND) || 0;
            bounty += refund;
            
            // Safety check for NaN
            if (isNaN(bounty)) bounty = 0;
            
            // Remove the building
            const idx = buildings.indexOf(building);
            if (idx >= 0) {
                buildings.splice(idx, 1);
            }
            
            // Also remove any siege weapon on this building
            const siege = getSiegeAt(grid.gx, grid.gy);
            if (siege) {
                const siegeIdx = siegeWeapons.indexOf(siege);
                if (siegeIdx >= 0) {
                    siegeWeapons.splice(siegeIdx, 1);
                }
            }
            
            // Delete particles
            for (let i = 0; i < 12; i++) {
                particles.push({
                    x: building.x + GRID_SIZE / 2,
                    y: building.y + GRID_SIZE / 2,
                    vx: (Math.random() - 0.5) * 6,
                    vy: (Math.random() - 0.5) * 6,
                    life: 25,
                    color: '#ef4444',
                    radius: 3
                });
            }
            
            // Gold particles for refund
            for (let i = 0; i < 8; i++) {
                particles.push({
                    x: building.x + GRID_SIZE / 2,
                    y: building.y + GRID_SIZE / 2,
                    vx: (Math.random() - 0.5) * 3,
                    vy: -2 - Math.random() * 2,
                    life: 30,
                    color: '#ffd700',
                    radius: 2
                });
            }
            
            updateHUD();
            updateBuildMenuAvailability();
            return true;
        }
        
        function upgradeBuilding(worldX, worldY) {
            if (!buildPhase || !upgradeMode) return false;
            
            const grid = worldToGrid(worldX, worldY);
            const building = getBuildingAt(grid.gx, grid.gy);
            
            if (!building) return false;
            
            // Get the appropriate tier data based on building type
            let tierData;
            if (building.type === 'wall') {
                tierData = WALL_TIERS;
            } else if (building.type === 'tower') {
                tierData = TOWER_TIERS;
            } else if (building.type === 'gate') {
                tierData = GATE_TIERS;
            } else {
                return false; // Not upgradeable
            }
            
            const currentTier = building.wallTier || 1;
            if (currentTier >= 3) return false; // Already max tier
            
            const currentTierData = tierData[currentTier];
            if (!currentTierData.upgradeCost) return false; // No upgrade available
            if (bounty < currentTierData.upgradeCost) return false; // Can't afford
            
            // Upgrade the building
            bounty -= currentTierData.upgradeCost;
            if (isNaN(bounty)) bounty = 0;
            
            const newTier = currentTier + 1;
            const newTierData = tierData[newTier];
            
            building.wallTier = newTier;
            building.name = newTierData.name;
            building.maxHealth = newTierData.health;
            building.health = newTierData.health; // Full health on upgrade
            
            // Apply bonuses if they exist
            if (newTierData.rangeBonus) building.rangeBonus = newTierData.rangeBonus;
            if (newTierData.damageBonus) building.damageBonus = newTierData.damageBonus;
            if (newTierData.siegeBonus) building.siegeBonus = newTierData.siegeBonus;
            
            // Upgrade particles
            for (let i = 0; i < 15; i++) {
                particles.push({
                    x: building.x + GRID_SIZE / 2,
                    y: building.y + GRID_SIZE / 2,
                    vx: (Math.random() - 0.5) * 6,
                    vy: -Math.random() * 4 - 2,
                    life: 30,
                    color: newTierData.color,
                    radius: 4
                });
            }
            
            updateHUD();
            updateBuildMenuAvailability();
            return true;
        }
        
        // Keep old function name for compatibility
        function upgradeWall(worldX, worldY) {
            return upgradeBuilding(worldX, worldY);
        }
        
        function getUpgradeableBuildingsCount() {
            return buildings.filter(b => 
                (b.type === 'wall' || b.type === 'tower' || b.type === 'gate') && 
                (b.wallTier || 1) < 3
            ).length;
        }
        
        // Keep old function for compatibility
        function getUpgradeableWallsCount() {
            return getUpgradeableBuildingsCount();
        }
        
        function repairBuilding(worldX, worldY) {
            if (!buildPhase || !repairMode) return false;
            
            const grid = worldToGrid(worldX, worldY);
            const building = getBuildingAt(grid.gx, grid.gy);
            
            if (!building) return false;
            if (building.health >= building.maxHealth) return false; // Already full
            
            const repairCost = getRepairCost(building);
            if (bounty < repairCost) return false;
            
            // Repair the building
            bounty -= repairCost;
            if (isNaN(bounty)) bounty = 0;
            building.health = building.maxHealth;
            
            // Repair particles
            for (let i = 0; i < 8; i++) {
                particles.push({
                    x: building.x + GRID_SIZE / 2,
                    y: building.y + GRID_SIZE / 2,
                    vx: (Math.random() - 0.5) * 4,
                    vy: -Math.random() * 3 - 1,
                    life: 25,
                    color: '#4ade80',
                    radius: 3
                });
            }
            
            updateHUD();
            updateBuildMenuAvailability();
            updateDamagedBuildingsInfo();
            return true;
        }
        
        function getDamagedBuildingsCount() {
            return buildings.filter(b => b.health < b.maxHealth).length;
        }
        
        function updateDamagedBuildingsInfo() {
            const count = getDamagedBuildingsCount();
            const infoEl = document.getElementById('damaged-buildings-info');
            const countEl = document.getElementById('damaged-count');
            
            if (count > 0) {
                countEl.textContent = count;
                infoEl.classList.remove('hidden');
            } else {
                infoEl.classList.add('hidden');
            }
        }
        
        function worldToGrid(worldX, worldY) {
            return {
                gx: Math.floor(worldX / GRID_SIZE),
                gy: Math.floor(worldY / GRID_SIZE)
            };
        }
        
        function gridToWorld(gx, gy) {
            return {
                x: gx * GRID_SIZE,
                y: gy * GRID_SIZE
            };
        }
        
        function getBuildingAt(gx, gy) {
            return buildings.find(b => b.gx === gx && b.gy === gy);
        }
        
        function placeBuilding(worldX, worldY) {
            // Handle siege weapon placement
            if (buildPhase && selectedSiegeType) {
                placeSiegeWeapon(worldX, worldY);
                return;
            }
            
            if (!buildPhase || !selectedBuildingType) return;
            
            const type = BUILDING_TYPES[selectedBuildingType];
            if (bounty < type.cost) return;
            
            const grid = worldToGrid(worldX, worldY);
            
            // Check if already occupied by building
            if (getBuildingAt(grid.gx, grid.gy)) return;
            
            // Check if already occupied by siege weapon
            if (getSiegeAt(grid.gx, grid.gy)) return;
            
            // Check world bounds
            if (grid.gx < 0 || grid.gx >= WORLD_WIDTH / GRID_SIZE ||
                grid.gy < 0 || grid.gy >= WORLD_HEIGHT / GRID_SIZE) return;
            
            // Check not placing on player
            const playerGrid = worldToGrid(player.x, player.y);
            if (grid.gx === playerGrid.gx && grid.gy === playerGrid.gy) return;
            
            // Place the building
            const buildCost = type.cost || 0;
            bounty -= buildCost;
            if (isNaN(bounty)) bounty = 0;
            
            const worldPos = gridToWorld(grid.gx, grid.gy);
            buildings.push({
                type: selectedBuildingType,
                gx: grid.gx,
                gy: grid.gy,
                x: worldPos.x,
                y: worldPos.y,
                width: GRID_SIZE,
                height: GRID_SIZE,
                health: type.health,
                maxHealth: type.health,
                ...type
            });
            
            // Particles for building
            for (let i = 0; i < 10; i++) {
                particles.push({
                    x: worldPos.x + GRID_SIZE / 2,
                    y: worldPos.y + GRID_SIZE / 2,
                    vx: (Math.random() - 0.5) * 6,
                    vy: (Math.random() - 0.5) * 6 - 2,
                    life: 20,
                    color: '#d4a574',
                    radius: 3
                });
            }
            
            updateHUD();
            updateBuildMenuAvailability();
        }
        
        function getSiegeAt(gx, gy) {
            return siegeWeapons.find(s => s.gx === gx && s.gy === gy);
        }
        
        function placeSiegeWeapon(worldX, worldY) {
            if (!buildPhase || !selectedSiegeType) return;
            
            const type = SIEGE_TYPES[selectedSiegeType];
            if (bounty < type.cost) return;
            
            const grid = worldToGrid(worldX, worldY);
            
            // Check if occupied by building (but CAN place on walls/towers for bonus)
            const existingBuilding = getBuildingAt(grid.gx, grid.gy);
            if (existingBuilding && !existingBuilding.climbable) return; // Can't place on gates/ladders
            
            // Check if already has siege weapon
            if (getSiegeAt(grid.gx, grid.gy)) return;
            
            // Check world bounds
            if (grid.gx < 0 || grid.gx >= WORLD_WIDTH / GRID_SIZE ||
                grid.gy < 0 || grid.gy >= WORLD_HEIGHT / GRID_SIZE) return;
            
            // Check not placing on player
            const playerGrid = worldToGrid(player.x, player.y);
            if (grid.gx === playerGrid.gx && grid.gy === playerGrid.gy) return;
            
            // Calculate bonuses based on placement
            let damageMultiplier = 1;
            let rangeMultiplier = 1;
            let placedOn = 'ground';
            
            if (existingBuilding) {
                if (existingBuilding.type === 'tower') {
                    damageMultiplier = 1.5;
                    rangeMultiplier = 1.4;
                    placedOn = 'tower';
                } else if (existingBuilding.type === 'wall') {
                    damageMultiplier = 1.25;
                    rangeMultiplier = 1.2;
                    placedOn = 'wall';
                }
            }
            
            // Place the siege weapon
            bounty -= type.cost;
            if (isNaN(bounty)) bounty = 0;
            
            const worldPos = gridToWorld(grid.gx, grid.gy);
            siegeWeapons.push({
                type: selectedSiegeType,
                gx: grid.gx,
                gy: grid.gy,
                x: worldPos.x + GRID_SIZE / 2,
                y: worldPos.y + GRID_SIZE / 2,
                health: type.health,
                maxHealth: type.health,
                damage: Math.round(type.damage * damageMultiplier),
                range: Math.round(type.range * rangeMultiplier),
                fireRate: type.fireRate,
                projectileSpeed: type.projectileSpeed,
                projectileSize: type.projectileSize,
                projectileColor: type.projectileColor,
                areaOfEffect: type.areaOfEffect || 0,
                burning: type.burning || false,
                lastFired: 0,
                angle: 0,
                placedOn: placedOn,
                damageMultiplier: damageMultiplier,
                rangeMultiplier: rangeMultiplier,
                ...type
            });
            
            // Particles for placement
            for (let i = 0; i < 15; i++) {
                particles.push({
                    x: worldPos.x + GRID_SIZE / 2,
                    y: worldPos.y + GRID_SIZE / 2,
                    vx: (Math.random() - 0.5) * 6,
                    vy: (Math.random() - 0.5) * 6 - 2,
                    life: 25,
                    color: '#ffd700',
                    radius: 3
                });
            }
            
            updateHUD();
            updateBuildMenuAvailability();
        }
        
        function getPlayerBuildingStatus() {
            const playerGrid = worldToGrid(player.x, player.y);
            const building = getBuildingAt(playerGrid.gx, playerGrid.gy);
            
            // Only get bonuses if elevated on a climbable structure
            if (building && building.climbable && playerElevated) {
                return {
                    inBuilding: true,
                    onWalls: true,
                    building: building,
                    rangeBonus: building.rangeBonus || 1,
                    damageBonus: building.damageBonus || 1,
                    damageReduction: 1,
                    healthRegen: 0,
                    elevated: true
                };
            }
            
            return {
                inBuilding: false,
                onWalls: false,
                building: null,
                rangeBonus: 1,
                damageBonus: 1,
                damageReduction: 1,
                healthRegen: 0,
                elevated: false
            };
        }
        
        function hasAdjacentLadder(gx, gy) {
            // Check all 4 adjacent cells for a ladder
            const adjacentCells = [
                {gx: gx - 1, gy: gy},
                {gx: gx + 1, gy: gy},
                {gx: gx, gy: gy - 1},
                {gx: gx, gy: gy + 1}
            ];
            
            for (let cell of adjacentCells) {
                const building = getBuildingAt(cell.gx, cell.gy);
                if (building && building.isLadder) {
                    return true;
                }
            }
            return false;
        }
        
        function hasAdjacentLadderOrGate(gx, gy) {
            // Check all 4 adjacent cells for a ladder or gate
            const adjacentCells = [
                {gx: gx - 1, gy: gy},
                {gx: gx + 1, gy: gy},
                {gx: gx, gy: gy - 1},
                {gx: gx, gy: gy + 1}
            ];
            
            for (let cell of adjacentCells) {
                const building = getBuildingAt(cell.gx, cell.gy);
                if (building && (building.isLadder || building.type === 'gate')) {
                    return true;
                }
            }
            return false;
        }
        
        function hasAdjacentExit(gx, gy) {
            // Check if this ground tile is adjacent to a ladder or gate (valid exit point)
            const adjacentCells = [
                {gx: gx - 1, gy: gy},
                {gx: gx + 1, gy: gy},
                {gx: gx, gy: gy - 1},
                {gx: gx, gy: gy + 1}
            ];
            
            for (let cell of adjacentCells) {
                const building = getBuildingAt(cell.gx, cell.gy);
                if (building && (building.isLadder || building.type === 'gate')) {
                    return true;
                }
            }
            return false;
        }
        
        function canClimbTo(gx, gy) {
            // Can climb to a wall/tower if there's an adjacent ladder or gate
            const building = getBuildingAt(gx, gy);
            if (!building || !building.climbable) return false;
            return hasAdjacentLadderOrGate(gx, gy);
        }
        
        function getAdjacentClimbable(gx, gy) {
            // Check if this ladder/gate is adjacent to a climbable building
            const adjacentCells = [
                {gx: gx - 1, gy: gy},
                {gx: gx + 1, gy: gy},
                {gx: gx, gy: gy - 1},
                {gx: gx, gy: gy + 1}
            ];
            
            for (let cell of adjacentCells) {
                const building = getBuildingAt(cell.gx, cell.gy);
                if (building && building.climbable) {
                    return building;
                }
            }
            return null;
        }
        
        function updateBuildingStatus() {
            const status = getPlayerBuildingStatus();
            const statusEl = document.getElementById('building-status');
            
            if (status.elevated && status.onWalls) {
                const text = ` On ${status.building.name}: +${Math.round((status.rangeBonus - 1) * 100)}% Range, +${Math.round((status.damageBonus - 1) * 100)}% Damage`;
                statusEl.textContent = text;
                statusEl.classList.remove('hidden');
                statusEl.classList.add('bonus');
            } else {
                statusEl.classList.add('hidden');
            }
        }
        
        function canEnemyPassThrough(gx, gy) {
            const building = getBuildingAt(gx, gy);
            if (!building) return true;
            if (building.blockEnemies) return false;
            return true;
        }
        
        function damageBuilding(building, damage) {
            building.health -= damage;
            
            // Damage particles
            for (let i = 0; i < 3; i++) {
                particles.push({
                    x: building.x + GRID_SIZE / 2 + (Math.random() - 0.5) * GRID_SIZE,
                    y: building.y + GRID_SIZE / 2 + (Math.random() - 0.5) * GRID_SIZE,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    life: 15,
                    color: '#8a7060',
                    radius: 2
                });
            }
            
            if (building.health <= 0) {
                // Destroy building
                const idx = buildings.indexOf(building);
                if (idx >= 0) {
                    // Also destroy any siege weapon on this building
                    const grid = worldToGrid(building.x, building.y);
                    const siege = getSiegeAt(grid.gx, grid.gy);
                    if (siege) {
                        const siegeIdx = siegeWeapons.indexOf(siege);
                        if (siegeIdx >= 0) {
                            siegeWeapons.splice(siegeIdx, 1);
                            
                            // Siege destruction particles
                            for (let i = 0; i < 10; i++) {
                                particles.push({
                                    x: siege.x,
                                    y: siege.y,
                                    vx: (Math.random() - 0.5) * 6,
                                    vy: (Math.random() - 0.5) * 6,
                                    life: 25,
                                    color: '#8b4513',
                                    radius: 3
                                });
                            }
                        }
                    }
                    
                    buildings.splice(idx, 1);
                    
                    // Destruction particles
                    for (let i = 0; i < 15; i++) {
                        particles.push({
                            x: building.x + GRID_SIZE / 2,
                            y: building.y + GRID_SIZE / 2,
                            vx: (Math.random() - 0.5) * 8,
                            vy: (Math.random() - 0.5) * 8,
                            life: 30,
                            color: '#5a4a3a',
                            radius: 4
                        });
                    }
                }
            }
        }
        
        // ========== TERRAIN DRAWING FUNCTIONS ==========
        
        function drawTerrainBehind() {
            // Draw terrain elements that should appear behind entities
            for (let elem of terrainElements) {
                // Only draw if on screen
                if (elem.x < camera.x - 100 || elem.x > camera.x + GAME_WIDTH + 100 ||
                    elem.y < camera.y - 100 || elem.y > camera.y + GAME_HEIGHT + 100) {
                    continue;
                }
                
                if (elem.type === 'grass_tuft') {
                    drawGrassTuft(elem);
                } else if (elem.type === 'flower') {
                    drawFlower(elem);
                }
            }
        }
        
        function drawTerrainFront() {
            // Draw terrain elements that should appear in front (trees, rocks, bushes)
            for (let elem of terrainElements) {
                // Only draw if on screen
                if (elem.x < camera.x - 100 || elem.x > camera.x + GAME_WIDTH + 100 ||
                    elem.y < camera.y - 100 || elem.y > camera.y + GAME_HEIGHT + 100) {
                    continue;
                }
                
                // Only draw elements that are "in front" of player based on Y position
                if (elem.type === 'tree') {
                    drawTree(elem);
                } else if (elem.type === 'rock') {
                    drawRock(elem);
                } else if (elem.type === 'bush') {
                    drawBush(elem);
                }
            }
        }
        
        function drawGrassTuft(elem) {
            ctx.save();
            ctx.translate(elem.x, elem.y);
            ctx.scale(elem.size, elem.size);
            
            // Wind sway
            const sway = Math.sin(Date.now() / 500 + elem.x * 0.1) * 0.1;
            
            ctx.fillStyle = '#2d5a1e';
            for (let i = -2; i <= 2; i++) {
                ctx.save();
                ctx.rotate(i * 0.2 + sway);
                ctx.beginPath();
                ctx.moveTo(-1, 0);
                ctx.quadraticCurveTo(0, -15, 1, 0);
                ctx.fill();
                ctx.restore();
            }
            ctx.restore();
        }
        
        function drawFlower(elem) {
            ctx.save();
            ctx.translate(elem.x, elem.y);
            
            // Stem
            ctx.strokeStyle = '#2d5a1e';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(0, -10);
            ctx.stroke();
            
            // Petals
            ctx.fillStyle = elem.color;
            for (let i = 0; i < 5; i++) {
                ctx.save();
                ctx.translate(0, -12);
                ctx.rotate(i * Math.PI * 2 / 5);
                ctx.beginPath();
                ctx.ellipse(0, -4, 3, 5, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
            
            // Center
            ctx.fillStyle = '#ffd700';
            ctx.beginPath();
            ctx.arc(0, -12, 3, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        function drawTree(elem) {
            ctx.save();
            ctx.translate(elem.x, elem.y);
            ctx.scale(elem.size, elem.size);
            
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.beginPath();
            ctx.ellipse(0, 5, 25, 10, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Trunk
            ctx.fillStyle = '#4a3728';
            ctx.fillRect(-8, -40, 16, 45);
            
            // Trunk detail
            ctx.fillStyle = '#3a2a1a';
            ctx.fillRect(-6, -35, 4, 35);
            
            // Foliage based on variant
            if (elem.variant === 0) {
                // Round tree
                ctx.fillStyle = '#2d5a1e';
                ctx.beginPath();
                ctx.arc(0, -60, 35, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#3d6a2e';
                ctx.beginPath();
                ctx.arc(-10, -65, 20, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#4d7a3e';
                ctx.beginPath();
                ctx.arc(8, -55, 15, 0, Math.PI * 2);
                ctx.fill();
            } else if (elem.variant === 1) {
                // Pine tree
                ctx.fillStyle = '#1e4a1e';
                ctx.beginPath();
                ctx.moveTo(0, -100);
                ctx.lineTo(-30, -40);
                ctx.lineTo(30, -40);
                ctx.closePath();
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(0, -80);
                ctx.lineTo(-35, -30);
                ctx.lineTo(35, -30);
                ctx.closePath();
                ctx.fill();
                ctx.fillStyle = '#2d5a2d';
                ctx.beginPath();
                ctx.moveTo(0, -60);
                ctx.lineTo(-40, -10);
                ctx.lineTo(40, -10);
                ctx.closePath();
                ctx.fill();
            } else {
                // Oak tree
                ctx.fillStyle = '#3d6a2e';
                ctx.beginPath();
                ctx.arc(-15, -55, 25, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(15, -55, 25, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(0, -70, 28, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#4d7a3e';
                ctx.beginPath();
                ctx.arc(-5, -75, 15, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
        }
        
        function drawRock(elem) {
            ctx.save();
            ctx.translate(elem.x, elem.y);
            ctx.scale(elem.size, elem.size);
            
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.beginPath();
            ctx.ellipse(0, 5, 15, 6, 0, 0, Math.PI * 2);
            ctx.fill();
            
            if (elem.variant === 0) {
                // Round boulder
                ctx.fillStyle = '#6a6a6a';
                ctx.beginPath();
                ctx.ellipse(0, -8, 14, 12, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#7a7a7a';
                ctx.beginPath();
                ctx.ellipse(-3, -10, 8, 6, -0.3, 0, Math.PI * 2);
                ctx.fill();
            } else if (elem.variant === 1) {
                // Jagged rock
                ctx.fillStyle = '#5a5a5a';
                ctx.beginPath();
                ctx.moveTo(-12, 0);
                ctx.lineTo(-15, -10);
                ctx.lineTo(-5, -18);
                ctx.lineTo(5, -15);
                ctx.lineTo(12, -20);
                ctx.lineTo(15, -8);
                ctx.lineTo(10, 0);
                ctx.closePath();
                ctx.fill();
                ctx.fillStyle = '#7a7a7a';
                ctx.beginPath();
                ctx.moveTo(-8, -5);
                ctx.lineTo(-5, -14);
                ctx.lineTo(3, -12);
                ctx.lineTo(5, -5);
                ctx.closePath();
                ctx.fill();
            } else {
                // Flat stone
                ctx.fillStyle = '#6a6a6a';
                ctx.beginPath();
                ctx.ellipse(0, -5, 18, 8, 0.2, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#8a8a8a';
                ctx.beginPath();
                ctx.ellipse(-2, -7, 10, 5, 0.2, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
        }
        
        function drawBush(elem) {
            ctx.save();
            ctx.translate(elem.x, elem.y);
            ctx.scale(elem.size, elem.size);
            
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.beginPath();
            ctx.ellipse(0, 3, 18, 6, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Bush body
            ctx.fillStyle = '#2d5a1e';
            ctx.beginPath();
            ctx.arc(-8, -8, 12, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(8, -8, 12, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(0, -12, 14, 0, Math.PI * 2);
            ctx.fill();
            
            // Highlights
            ctx.fillStyle = '#3d6a2e';
            ctx.beginPath();
            ctx.arc(-5, -14, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(6, -10, 5, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        function drawBuildings() {
            for (let b of buildings) {
                ctx.save();
                
                if (b.type === 'wall') {
                    drawWall(b);
                } else if (b.type === 'tower') {
                    drawTowerGrid(b);
                } else if (b.type === 'gate') {
                    drawGate(b);
                } else if (b.type === 'ladder') {
                    drawLadder(b);
                } else if (b.type === 'forge') {
                    drawForge(b);
                } else if (b.type === 'stable') {
                    drawStable(b);
                }
                
                // Always show health bar for buildings with HP
                if (b.maxHealth) {
                    const healthPct = b.health / b.maxHealth;
                    ctx.fillStyle = '#333';
                    ctx.fillRect(b.x + 4, b.y - 8, GRID_SIZE - 8, 4);
                    ctx.fillStyle = healthPct > 0.5 ? '#4ade80' : healthPct > 0.25 ? '#fbbf24' : '#ef4444';
                    ctx.fillRect(b.x + 4, b.y - 8, (GRID_SIZE - 8) * healthPct, 4);
                }
                
                ctx.restore();
            }
            
            // Draw build or repair preview during build phase
            if (buildPhase && mouseWorldPos) {
                const grid = worldToGrid(mouseWorldPos.x, mouseWorldPos.y);
                const worldPos = gridToWorld(grid.gx, grid.gy);
                const existingBuilding = getBuildingAt(grid.gx, grid.gy);
                
                if (repairMode) {
                    // Repair mode preview
                    if (existingBuilding && existingBuilding.health < existingBuilding.maxHealth) {
                        const repairCost = getRepairCost(existingBuilding);
                        const canRepair = bounty >= repairCost;
                        
                        ctx.globalAlpha = 0.6;
                        ctx.fillStyle = canRepair ? 'rgba(74, 222, 128, 0.4)' : 'rgba(239, 68, 68, 0.3)';
                        ctx.fillRect(worldPos.x, worldPos.y, GRID_SIZE, GRID_SIZE);
                        ctx.strokeStyle = canRepair ? '#4ade80' : '#ef4444';
                        ctx.lineWidth = 3;
                        ctx.strokeRect(worldPos.x, worldPos.y, GRID_SIZE, GRID_SIZE);
                        
                        // Show repair icon and cost
                        ctx.globalAlpha = 1;
                        ctx.font = '16px serif';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillStyle = '#fff';
                        ctx.fillText('', worldPos.x + GRID_SIZE/2, worldPos.y + GRID_SIZE/2);
                        
                        // Show damage percent and cost
                        const damagePercent = Math.round((1 - existingBuilding.health / existingBuilding.maxHealth) * 100);
                        ctx.font = 'bold 10px Arial';
                        ctx.fillStyle = '#ff6b6b';
                        ctx.fillText(`${damagePercent}% dmg`, worldPos.x + GRID_SIZE/2, worldPos.y - 5);
                        
                        ctx.font = 'bold 12px Arial';
                        ctx.fillStyle = canRepair ? '#fbbf24' : '#ef4444';
                        ctx.fillText(`-$${repairCost}`, worldPos.x + GRID_SIZE/2, worldPos.y + GRID_SIZE + 10);
                    }
                } else if (upgradeMode) {
                    // Upgrade mode preview
                    if (existingBuilding && (existingBuilding.type === 'wall' || existingBuilding.type === 'tower' || existingBuilding.type === 'gate')) {
                        const currentTier = existingBuilding.wallTier || 1;
                        const canUpgrade = currentTier < 3;
                        
                        // Get the right tier data
                        let tierData;
                        if (existingBuilding.type === 'wall') tierData = WALL_TIERS;
                        else if (existingBuilding.type === 'tower') tierData = TOWER_TIERS;
                        else tierData = GATE_TIERS;
                        
                        const currentTierData = tierData[currentTier];
                        const upgradeCost = currentTierData ? currentTierData.upgradeCost : null;
                        const canAfford = upgradeCost && bounty >= upgradeCost;
                        
                        ctx.globalAlpha = 0.6;
                        ctx.fillStyle = (canUpgrade && canAfford) ? 'rgba(100, 200, 255, 0.4)' : 'rgba(239, 68, 68, 0.3)';
                        ctx.fillRect(worldPos.x, worldPos.y, GRID_SIZE, GRID_SIZE);
                        ctx.strokeStyle = (canUpgrade && canAfford) ? '#64c8ff' : '#ef4444';
                        ctx.lineWidth = 3;
                        ctx.strokeRect(worldPos.x, worldPos.y, GRID_SIZE, GRID_SIZE);
                        
                        // Show upgrade icon and info
                        ctx.globalAlpha = 1;
                        ctx.font = '16px serif';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillStyle = '#fff';
                        ctx.fillText('', worldPos.x + GRID_SIZE/2, worldPos.y + GRID_SIZE/2);
                        
                        ctx.font = 'bold 10px Arial';
                        if (canUpgrade) {
                            const nextTier = tierData[currentTier + 1];
                            ctx.fillStyle = canAfford ? '#64c8ff' : '#ef4444';
                            ctx.fillText(` ${nextTier.name}`, worldPos.x + GRID_SIZE/2, worldPos.y - 5);
                            ctx.fillStyle = canAfford ? '#fbbf24' : '#ef4444';
                            ctx.fillText(`-$${upgradeCost}`, worldPos.x + GRID_SIZE/2, worldPos.y + GRID_SIZE + 10);
                        } else {
                            ctx.fillStyle = '#aaa';
                            ctx.fillText('MAX', worldPos.x + GRID_SIZE/2, worldPos.y + GRID_SIZE + 10);
                        }
                    }
                } else if (deleteMode) {
                    // Delete mode preview
                    if (existingBuilding) {
                        // Calculate refund
                        let baseCost = BUILDING_TYPES[existingBuilding.type] ? BUILDING_TYPES[existingBuilding.type].cost : 0;
                        let totalInvested = baseCost;
                        
                        if (existingBuilding.wallTier && existingBuilding.wallTier > 1) {
                            let tierData;
                            if (existingBuilding.type === 'wall') tierData = WALL_TIERS;
                            else if (existingBuilding.type === 'tower') tierData = TOWER_TIERS;
                            else if (existingBuilding.type === 'gate') tierData = GATE_TIERS;
                            
                            if (tierData) {
                                for (let t = 1; t < existingBuilding.wallTier; t++) {
                                    totalInvested += tierData[t].upgradeCost || 0;
                                }
                            }
                        }
                        
                        const refund = Math.floor(totalInvested * DELETE_REFUND);
                        
                        ctx.globalAlpha = 0.6;
                        ctx.fillStyle = 'rgba(239, 68, 68, 0.4)';
                        ctx.fillRect(worldPos.x, worldPos.y, GRID_SIZE, GRID_SIZE);
                        ctx.strokeStyle = '#ef4444';
                        ctx.lineWidth = 3;
                        ctx.strokeRect(worldPos.x, worldPos.y, GRID_SIZE, GRID_SIZE);
                        
                        // Show delete icon and refund
                        ctx.globalAlpha = 1;
                        ctx.font = '16px serif';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillStyle = '#fff';
                        ctx.fillText('', worldPos.x + GRID_SIZE/2, worldPos.y + GRID_SIZE/2);
                        
                        ctx.font = 'bold 10px Arial';
                        ctx.fillStyle = '#4ade80';
                        ctx.fillText(`+$${refund}`, worldPos.x + GRID_SIZE/2, worldPos.y + GRID_SIZE + 10);
                    }
                } else if (selectedBuildingType) {
                    // Build mode preview
                    const canPlace = !existingBuilding && 
                                    bounty >= BUILDING_TYPES[selectedBuildingType].cost;
                    
                    ctx.globalAlpha = 0.5;
                    ctx.fillStyle = canPlace ? 'rgba(74, 222, 128, 0.3)' : 'rgba(239, 68, 68, 0.3)';
                    ctx.fillRect(worldPos.x, worldPos.y, GRID_SIZE, GRID_SIZE);
                    ctx.strokeStyle = canPlace ? '#4ade80' : '#ef4444';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(worldPos.x, worldPos.y, GRID_SIZE, GRID_SIZE);
                
                    // Preview icon
                    ctx.globalAlpha = 0.7;
                    ctx.font = '20px serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = '#fff';
                    ctx.fillText(BUILDING_TYPES[selectedBuildingType].icon, worldPos.x + GRID_SIZE/2, worldPos.y + GRID_SIZE/2);
                    ctx.globalAlpha = 1;
                } else if (selectedSiegeType) {
                    // Siege weapon placement preview
                    const existingSiege = getSiegeAt(grid.gx, grid.gy);
                    const canPlaceOnBuilding = existingBuilding && existingBuilding.climbable;
                    const canPlace = !existingSiege && 
                                    (!existingBuilding || canPlaceOnBuilding) && 
                                    bounty >= SIEGE_TYPES[selectedSiegeType].cost;
                    
                    ctx.globalAlpha = 0.5;
                    ctx.fillStyle = canPlace ? 'rgba(255, 200, 100, 0.3)' : 'rgba(239, 68, 68, 0.3)';
                    ctx.fillRect(worldPos.x, worldPos.y, GRID_SIZE, GRID_SIZE);
                    ctx.strokeStyle = canPlace ? '#ffd700' : '#ef4444';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(worldPos.x, worldPos.y, GRID_SIZE, GRID_SIZE);
                    
                    // Show bonus indicator
                    if (canPlaceOnBuilding) {
                        const bonusText = existingBuilding.type === 'tower' ? '+50%' : '+25%';
                        ctx.globalAlpha = 1;
                        ctx.font = 'bold 10px Arial';
                        ctx.fillStyle = '#4ade80';
                        ctx.fillText(bonusText, worldPos.x + GRID_SIZE/2, worldPos.y - 2);
                    }
                    
                    // Preview icon
                    ctx.globalAlpha = 0.7;
                    ctx.font = '20px serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = '#fff';
                    ctx.fillText(SIEGE_TYPES[selectedSiegeType].icon, worldPos.x + GRID_SIZE/2, worldPos.y + GRID_SIZE/2);
                    ctx.globalAlpha = 1;
                }
            }
        }
        
        function drawSiegeWeapons() {
            for (let s of siegeWeapons) {
                ctx.save();
                ctx.translate(s.x, s.y);
                
                // Elevation offset if on wall/tower
                const elevOffset = s.placedOn !== 'ground' ? -15 : 0;
                ctx.translate(0, elevOffset);
                
                // Rotate to face target
                ctx.rotate(s.angle);
                
                if (s.type === 'scorpion') {
                    drawScorpion(s);
                } else if (s.type === 'catapult') {
                    drawCatapult(s);
                } else if (s.type === 'onager') {
                    drawOnager(s);
                } else if (s.type === 'trebuchet') {
                    drawTrebuchet(s);
                }
                
                ctx.restore();
                
                // Health bar
                if (s.health < s.maxHealth) {
                    const healthPct = s.health / s.maxHealth;
                    ctx.fillStyle = '#333';
                    ctx.fillRect(s.x - 15, s.y + elevOffset - 25, 30, 4);
                    ctx.fillStyle = healthPct > 0.5 ? '#4ade80' : healthPct > 0.25 ? '#fbbf24' : '#ef4444';
                    ctx.fillRect(s.x - 15, s.y + elevOffset - 25, 30 * healthPct, 4);
                }
                
                // Bonus indicator
                if (s.placedOn !== 'ground') {
                    ctx.font = 'bold 8px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillStyle = s.placedOn === 'tower' ? '#ffd700' : '#c0c0c0';
                    ctx.fillText(s.placedOn === 'tower' ? '' : '', s.x, s.y + elevOffset - 30);
                }
            }
        }
        
        function drawScorpion(s) {
            // Base
            ctx.fillStyle = '#5a4030';
            ctx.fillRect(-12, -6, 24, 12);
            
            // Bow arms
            ctx.strokeStyle = '#4a3020';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(-10, 0);
            ctx.quadraticCurveTo(-18, -8, -14, -14);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(-10, 0);
            ctx.quadraticCurveTo(-18, 8, -14, 14);
            ctx.stroke();
            
            // Bolt track
            ctx.fillStyle = '#3a2515';
            ctx.fillRect(-8, -2, 20, 4);
            
            // Bolt
            ctx.fillStyle = '#8b4513';
            ctx.fillRect(0, -1, 12, 2);
            ctx.fillStyle = '#c0c0c0';
            ctx.beginPath();
            ctx.moveTo(12, 0);
            ctx.lineTo(16, -2);
            ctx.lineTo(16, 2);
            ctx.fill();
        }
        
        function drawCatapult(s) {
            // Frame
            ctx.fillStyle = '#5a4020';
            ctx.fillRect(-14, -4, 28, 8);
            
            // Wheels
            ctx.fillStyle = '#3a2515';
            ctx.beginPath();
            ctx.arc(-10, 6, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(10, 6, 5, 0, Math.PI * 2);
            ctx.fill();
            
            // Arm
            ctx.fillStyle = '#6a5030';
            ctx.save();
            ctx.rotate(-0.3);
            ctx.fillRect(-4, -18, 4, 20);
            ctx.restore();
            
            // Bowl
            ctx.fillStyle = '#4a3a2a';
            ctx.beginPath();
            ctx.arc(-2, -16, 6, 0, Math.PI);
            ctx.fill();
            
            // Rock
            ctx.fillStyle = '#696969';
            ctx.beginPath();
            ctx.arc(-2, -18, 4, 0, Math.PI * 2);
            ctx.fill();
        }
        
        function drawOnager(s) {
            // Frame
            ctx.fillStyle = '#5a3020';
            ctx.fillRect(-12, -4, 24, 10);
            
            // Wheels  
            ctx.fillStyle = '#3a2010';
            ctx.beginPath();
            ctx.arc(-8, 8, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(8, 8, 4, 0, Math.PI * 2);
            ctx.fill();
            
            // Arm with sling
            ctx.strokeStyle = '#6a4020';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-5, -20);
            ctx.stroke();
            
            // Sling
            ctx.strokeStyle = '#8a6040';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-5, -20);
            ctx.quadraticCurveTo(-15, -18, -10, -12);
            ctx.stroke();
            
            // Fireball
            ctx.fillStyle = '#ff4500';
            ctx.beginPath();
            ctx.arc(-5, -22, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#ffff00';
            ctx.beginPath();
            ctx.arc(-5, -22, 3, 0, Math.PI * 2);
            ctx.fill();
        }
        
        function drawTrebuchet(s) {
            // Base frame
            ctx.fillStyle = '#4a3520';
            ctx.fillRect(-16, 2, 32, 8);
            
            // Support structure
            ctx.fillStyle = '#5a4530';
            ctx.beginPath();
            ctx.moveTo(-8, 2);
            ctx.lineTo(0, -10);
            ctx.lineTo(8, 2);
            ctx.fill();
            
            // Long arm
            ctx.fillStyle = '#6a5540';
            ctx.save();
            ctx.rotate(-0.4);
            ctx.fillRect(-6, -35, 5, 40);
            ctx.restore();
            
            // Counterweight
            ctx.fillStyle = '#3a3a3a';
            ctx.fillRect(4, -8, 10, 12);
            
            // Sling
            ctx.strokeStyle = '#8a7050';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-8, -30);
            ctx.quadraticCurveTo(-20, -28, -15, -20);
            ctx.stroke();
            
            // Boulder
            ctx.fillStyle = '#2f4f4f';
            ctx.beginPath();
            ctx.arc(-10, -32, 6, 0, Math.PI * 2);
            ctx.fill();
        }
        
        function drawLadder(b) {
            // Wooden ladder
            ctx.fillStyle = '#5a4020';
            
            // Side rails
            ctx.fillRect(b.x + 8, b.y + 2, 4, GRID_SIZE - 4);
            ctx.fillRect(b.x + GRID_SIZE - 12, b.y + 2, 4, GRID_SIZE - 4);
            
            // Rungs
            ctx.fillStyle = '#7a5a30';
            for (let i = 0; i < 5; i++) {
                const y = b.y + 6 + i * 7;
                ctx.fillRect(b.x + 10, y, GRID_SIZE - 20, 3);
            }
            
            // Highlight
            ctx.fillStyle = '#8a6a40';
            ctx.fillRect(b.x + 9, b.y + 2, 2, GRID_SIZE - 4);
        }
        
        function drawForge(b) {
            // Stone base
            const stoneGrad = ctx.createLinearGradient(b.x, b.y, b.x + GRID_SIZE, b.y);
            stoneGrad.addColorStop(0, '#4a4a4a');
            stoneGrad.addColorStop(0.5, '#6a6a6a');
            stoneGrad.addColorStop(1, '#4a4a4a');
            ctx.fillStyle = stoneGrad;
            ctx.fillRect(b.x + 2, b.y + 10, GRID_SIZE - 4, GRID_SIZE - 12);
            
            // Chimney
            ctx.fillStyle = '#5a5a5a';
            ctx.fillRect(b.x + GRID_SIZE/2 - 6, b.y - 10, 12, 22);
            
            // Fire opening
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(b.x + 8, b.y + 18, GRID_SIZE - 16, GRID_SIZE - 22);
            
            // Fire glow
            const fireTime = Date.now() / 200;
            const fireIntensity = 0.7 + Math.sin(fireTime) * 0.3;
            ctx.fillStyle = `rgba(255, ${100 + Math.sin(fireTime * 1.3) * 50}, 0, ${fireIntensity})`;
            ctx.beginPath();
            ctx.moveTo(b.x + 12, b.y + GRID_SIZE - 6);
            ctx.lineTo(b.x + GRID_SIZE/2, b.y + 20 + Math.sin(fireTime) * 3);
            ctx.lineTo(b.x + GRID_SIZE - 12, b.y + GRID_SIZE - 6);
            ctx.fill();
            
            // Embers
            ctx.fillStyle = `rgba(255, 200, 50, ${0.5 + Math.sin(fireTime * 2) * 0.3})`;
            ctx.beginPath();
            ctx.arc(b.x + GRID_SIZE/2 - 5, b.y + 28 + Math.sin(fireTime * 1.5) * 2, 2, 0, Math.PI * 2);
            ctx.arc(b.x + GRID_SIZE/2 + 5, b.y + 30 + Math.cos(fireTime * 1.2) * 2, 2, 0, Math.PI * 2);
            ctx.fill();
            
            // Anvil
            ctx.fillStyle = '#3a3a3a';
            ctx.fillRect(b.x + GRID_SIZE - 14, b.y + GRID_SIZE - 12, 10, 8);
            ctx.fillRect(b.x + GRID_SIZE - 16, b.y + GRID_SIZE - 8, 14, 4);
            
            // Smoke particles (visual only)
            ctx.fillStyle = 'rgba(100, 100, 100, 0.3)';
            for (let i = 0; i < 3; i++) {
                const smokeY = b.y - 15 - i * 8 - (Date.now() / 100 % 10);
                const smokeX = b.x + GRID_SIZE/2 + Math.sin(Date.now() / 300 + i) * 4;
                ctx.beginPath();
                ctx.arc(smokeX, smokeY, 3 + i, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        function drawStable(b) {
            // Wooden stable structure
            const woodGrad = ctx.createLinearGradient(b.x, b.y, b.x + GRID_SIZE, b.y);
            woodGrad.addColorStop(0, '#5a4a30');
            woodGrad.addColorStop(0.5, '#7a6a50');
            woodGrad.addColorStop(1, '#5a4a30');
            ctx.fillStyle = woodGrad;
            ctx.fillRect(b.x + 2, b.y + 8, GRID_SIZE - 4, GRID_SIZE - 10);
            
            // Roof
            ctx.fillStyle = '#4a3a20';
            ctx.beginPath();
            ctx.moveTo(b.x, b.y + 10);
            ctx.lineTo(b.x + GRID_SIZE/2, b.y - 8);
            ctx.lineTo(b.x + GRID_SIZE, b.y + 10);
            ctx.closePath();
            ctx.fill();
            
            // Roof highlight
            ctx.fillStyle = '#5a4a30';
            ctx.beginPath();
            ctx.moveTo(b.x + 4, b.y + 10);
            ctx.lineTo(b.x + GRID_SIZE/2, b.y - 4);
            ctx.lineTo(b.x + GRID_SIZE/2, b.y - 8);
            ctx.lineTo(b.x, b.y + 10);
            ctx.closePath();
            ctx.fill();
            
            // Door/opening
            ctx.fillStyle = '#2a1a10';
            ctx.fillRect(b.x + GRID_SIZE/2 - 8, b.y + 15, 16, GRID_SIZE - 17);
            
            // Hay
            ctx.fillStyle = '#c4a040';
            ctx.fillRect(b.x + 5, b.y + GRID_SIZE - 10, 10, 8);
            ctx.fillStyle = '#d4b050';
            ctx.fillRect(b.x + 6, b.y + GRID_SIZE - 12, 8, 4);
            
            // Horse silhouette inside (if player has horse from this stable)
            if (player && player.horse) {
                ctx.fillStyle = 'rgba(100, 80, 60, 0.6)';
                ctx.beginPath();
                ctx.ellipse(b.x + GRID_SIZE/2, b.y + 25, 8, 6, 0, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Fence posts
            ctx.fillStyle = '#6a5a40';
            ctx.fillRect(b.x + 3, b.y + 20, 3, GRID_SIZE - 22);
            ctx.fillRect(b.x + GRID_SIZE - 6, b.y + 20, 3, GRID_SIZE - 22);
        }
        
        function drawWall(b) {
            const tier = b.wallTier || 1;
            
            if (tier === 1) {
                // PALISADE - Wooden wall
                const woodGrad = ctx.createLinearGradient(b.x, b.y, b.x + GRID_SIZE, b.y);
                woodGrad.addColorStop(0, '#5c3d2e');
                woodGrad.addColorStop(0.5, '#8b5a2b');
                woodGrad.addColorStop(1, '#5c3d2e');
                ctx.fillStyle = woodGrad;
                ctx.fillRect(b.x + 2, b.y + 2, GRID_SIZE - 4, GRID_SIZE - 4);
                
                // Vertical wooden planks
                ctx.strokeStyle = '#3d2517';
                ctx.lineWidth = 1;
                for (let i = 0; i < 5; i++) {
                    const px = b.x + 4 + i * 8;
                    ctx.beginPath();
                    ctx.moveTo(px, b.y + 2);
                    ctx.lineTo(px, b.y + GRID_SIZE - 2);
                    ctx.stroke();
                }
                
                // Pointed tops (palisade style)
                ctx.fillStyle = '#6b4423';
                for (let i = 0; i < 4; i++) {
                    const px = b.x + 6 + i * 9;
                    ctx.beginPath();
                    ctx.moveTo(px, b.y);
                    ctx.lineTo(px + 4, b.y - 6);
                    ctx.lineTo(px + 8, b.y);
                    ctx.fill();
                }
                
                // Wood grain
                ctx.strokeStyle = '#4a3020';
                ctx.lineWidth = 0.5;
                ctx.beginPath();
                ctx.moveTo(b.x + 8, b.y + 10);
                ctx.quadraticCurveTo(b.x + 20, b.y + 15, b.x + 32, b.y + 12);
                ctx.stroke();
                
            } else if (tier === 2) {
                // STONE WALL
                const stoneGrad = ctx.createLinearGradient(b.x, b.y, b.x + GRID_SIZE, b.y + GRID_SIZE);
                stoneGrad.addColorStop(0, '#6a6a6a');
                stoneGrad.addColorStop(0.5, '#8a8a8a');
                stoneGrad.addColorStop(1, '#5a5a5a');
                ctx.fillStyle = stoneGrad;
                ctx.fillRect(b.x + 2, b.y + 2, GRID_SIZE - 4, GRID_SIZE - 4);
                
                // Brick pattern
                ctx.strokeStyle = '#4a4a4a';
                ctx.lineWidth = 1;
                ctx.strokeRect(b.x + 4, b.y + 4, GRID_SIZE/2 - 4, GRID_SIZE/2 - 4);
                ctx.strokeRect(b.x + GRID_SIZE/2, b.y + 4, GRID_SIZE/2 - 4, GRID_SIZE/2 - 4);
                ctx.strokeRect(b.x + 4, b.y + GRID_SIZE/2, GRID_SIZE/2 - 4, GRID_SIZE/2 - 4);
                ctx.strokeRect(b.x + GRID_SIZE/2, b.y + GRID_SIZE/2, GRID_SIZE/2 - 4, GRID_SIZE/2 - 4);
                
                // Top edge (battlements look)
                ctx.fillStyle = '#7a7a7a';
                ctx.fillRect(b.x + 2, b.y, 8, 4);
                ctx.fillRect(b.x + GRID_SIZE - 10, b.y, 8, 4);
                
            } else if (tier === 3) {
                // FORTIFIED WALL - Reinforced stone
                const fortGrad = ctx.createLinearGradient(b.x, b.y, b.x + GRID_SIZE, b.y + GRID_SIZE);
                fortGrad.addColorStop(0, '#505060');
                fortGrad.addColorStop(0.3, '#707080');
                fortGrad.addColorStop(0.7, '#707080');
                fortGrad.addColorStop(1, '#505060');
                ctx.fillStyle = fortGrad;
                ctx.fillRect(b.x + 1, b.y + 1, GRID_SIZE - 2, GRID_SIZE - 2);
                
                // Metal reinforcement bands
                ctx.fillStyle = '#4a4a5a';
                ctx.fillRect(b.x + 2, b.y + 8, GRID_SIZE - 4, 4);
                ctx.fillRect(b.x + 2, b.y + GRID_SIZE - 12, GRID_SIZE - 4, 4);
                
                // Rivets
                ctx.fillStyle = '#8a8a9a';
                for (let i = 0; i < 4; i++) {
                    ctx.beginPath();
                    ctx.arc(b.x + 8 + i * 8, b.y + 10, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(b.x + 8 + i * 8, b.y + GRID_SIZE - 10, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Large battlements
                ctx.fillStyle = '#606070';
                ctx.fillRect(b.x, b.y - 4, 10, 8);
                ctx.fillRect(b.x + GRID_SIZE - 10, b.y - 4, 10, 8);
                ctx.fillRect(b.x + GRID_SIZE/2 - 5, b.y - 4, 10, 8);
                
                // Crenellation tops
                ctx.fillStyle = '#707080';
                ctx.fillRect(b.x + 2, b.y - 6, 6, 3);
                ctx.fillRect(b.x + GRID_SIZE - 8, b.y - 6, 6, 3);
                ctx.fillRect(b.x + GRID_SIZE/2 - 3, b.y - 6, 6, 3);
            }
        }
        
        function drawTowerGrid(b) {
            const tier = b.wallTier || 1;
            const tierData = TOWER_TIERS[tier];
            const baseColor = tierData ? tierData.color : '#5a5a5a';
            
            // Tower base colors based on tier
            const colors = {
                1: { base: '#5a4a3a', mid: '#7a6a5a', top: '#8a7a6a' }, // Wood
                2: { base: '#5a5a5a', mid: '#7a7a7a', top: '#8a8a8a' }, // Stone
                3: { base: '#4a4a6a', mid: '#6a6a8a', top: '#8080a0' }  // Fortress
            };
            const c = colors[tier] || colors[1];
            
            // Tower base (larger/taller looking)
            const grad = ctx.createLinearGradient(b.x, b.y, b.x + GRID_SIZE, b.y);
            grad.addColorStop(0, c.base);
            grad.addColorStop(0.5, c.mid);
            grad.addColorStop(1, c.base);
            ctx.fillStyle = grad;
            ctx.fillRect(b.x + 1, b.y + 1, GRID_SIZE - 2, GRID_SIZE - 2);
            
            // Tower structure
            ctx.fillStyle = c.mid;
            ctx.fillRect(b.x + 4, b.y - 8, GRID_SIZE - 8, 12);
            
            // Battlements
            ctx.fillStyle = c.top;
            ctx.fillRect(b.x + 2, b.y - 12, 8, 6);
            ctx.fillRect(b.x + GRID_SIZE - 10, b.y - 12, 8, 6);
            ctx.fillRect(b.x + GRID_SIZE/2 - 4, b.y - 12, 8, 6);
            
            // Extra battlements for higher tiers
            if (tier >= 2) {
                ctx.fillRect(b.x + 12, b.y - 14, 6, 8);
                ctx.fillRect(b.x + GRID_SIZE - 18, b.y - 14, 6, 8);
            }
            
            // Flag color based on tier
            const flagColors = { 1: '#c41e3a', 2: '#1e8ac4', 3: '#ffd700' };
            ctx.fillStyle = flagColors[tier] || '#c41e3a';
            ctx.beginPath();
            ctx.moveTo(b.x + GRID_SIZE/2, b.y - 12);
            ctx.lineTo(b.x + GRID_SIZE/2, b.y - 28);
            ctx.lineTo(b.x + GRID_SIZE/2 + 12, b.y - 23);
            ctx.lineTo(b.x + GRID_SIZE/2, b.y - 18);
            ctx.fill();
            
            // Flagpole
            ctx.strokeStyle = '#4a3020';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(b.x + GRID_SIZE/2, b.y - 12);
            ctx.lineTo(b.x + GRID_SIZE/2, b.y - 30);
            ctx.stroke();
            
            // Window
            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(b.x + GRID_SIZE/2 - 4, b.y + GRID_SIZE/2 - 6, 8, 12);
            ctx.fillStyle = tier >= 3 ? '#6a5a20' : '#4a3a20';
            ctx.fillRect(b.x + GRID_SIZE/2 - 3, b.y + GRID_SIZE/2 - 5, 6, 10);
            
            // Glow effect for max tier
            if (tier >= 3) {
                ctx.shadowColor = '#ffd700';
                ctx.shadowBlur = 10;
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 1;
                ctx.strokeRect(b.x + 2, b.y - 12, GRID_SIZE - 4, GRID_SIZE + 10);
                ctx.shadowBlur = 0;
            }
        }
        
        function drawGate(b) {
            const tier = b.wallTier || 1;
            
            // Gate colors based on tier
            const colors = {
                1: { frame: '#5a4a3a', bars: '#3a3a3a', arch: '#6a5a4a' }, // Wood
                2: { frame: '#5a5a5a', bars: '#4a4a4a', arch: '#6a6a6a' }, // Reinforced
                3: { frame: '#505070', bars: '#606080', arch: '#707090' }  // Iron
            };
            const c = colors[tier] || colors[1];
            
            // Gate frame
            ctx.fillStyle = c.frame;
            ctx.fillRect(b.x + 2, b.y + 2, GRID_SIZE - 4, GRID_SIZE - 4);
            
            // Gate opening
            ctx.fillStyle = '#2d1810';
            ctx.fillRect(b.x + 6, b.y + 8, GRID_SIZE - 12, GRID_SIZE - 10);
            
            // Gate bars (portcullis style)
            ctx.strokeStyle = c.bars;
            ctx.lineWidth = tier >= 3 ? 3 : 2;
            for (let i = 0; i < 4; i++) {
                const x = b.x + 10 + i * 7;
                ctx.beginPath();
                ctx.moveTo(x, b.y + 8);
                ctx.lineTo(x, b.y + GRID_SIZE - 4);
                ctx.stroke();
            }
            // Horizontal bars
            ctx.beginPath();
            ctx.moveTo(b.x + 6, b.y + 15);
            ctx.lineTo(b.x + GRID_SIZE - 6, b.y + 15);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(b.x + 6, b.y + 28);
            ctx.lineTo(b.x + GRID_SIZE - 6, b.y + 28);
            ctx.stroke();
            
            // Extra bar for higher tiers
            if (tier >= 2) {
                ctx.beginPath();
                ctx.moveTo(b.x + 6, b.y + 21);
                ctx.lineTo(b.x + GRID_SIZE - 6, b.y + 21);
                ctx.stroke();
            }
            
            // Arch top
            ctx.fillStyle = c.arch;
            ctx.beginPath();
            ctx.arc(b.x + GRID_SIZE/2, b.y + 10, GRID_SIZE/2 - 6, Math.PI, 0);
            ctx.fill();
            ctx.fillStyle = '#2d1810';
            ctx.beginPath();
            ctx.arc(b.x + GRID_SIZE/2, b.y + 10, GRID_SIZE/2 - 10, Math.PI, 0);
            ctx.fill();
            
            // Decorations for higher tiers
            if (tier >= 2) {
                // Rivets
                ctx.fillStyle = tier >= 3 ? '#808090' : '#6a6a6a';
                ctx.beginPath();
                ctx.arc(b.x + 8, b.y + 6, 2, 0, Math.PI * 2);
                ctx.arc(b.x + GRID_SIZE - 8, b.y + 6, 2, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Glow effect for max tier
            if (tier >= 3) {
                ctx.shadowColor = '#8080ff';
                ctx.shadowBlur = 8;
                ctx.strokeStyle = '#8080ff';
                ctx.lineWidth = 1;
                ctx.strokeRect(b.x + 3, b.y + 3, GRID_SIZE - 6, GRID_SIZE - 6);
                ctx.shadowBlur = 0;
            }
        }
        
        // Track mouse position for build preview
        let mouseWorldPos = null;

        function takeDamage(amount) {
            // Player is immune when elevated on walls/towers
            if (playerElevated) {
                // Show blocked indicator
                particles.push({
                    x: player.x,
                    y: player.y - 30,
                    vx: 0,
                    vy: -1,
                    life: 30,
                    color: '#4a90d9',
                    radius: 6,
                    text: 'BLOCKED'
                });
                return;
            }
            
            // Apply building damage reduction
            const buildingStatus = getPlayerBuildingStatus();
            amount *= buildingStatus.damageReduction;
            
            // Horse absorbs damage first
            if (player.horse) {
                amount = damageHorse(amount);
                if (amount <= 0) return; // Horse absorbed all damage
            }
            
            // Armor absorbs remaining damage - distribute across armor pieces
            if (player.armor > 0) {
                const armorDamage = Math.min(player.armor, amount * 0.7);
                
                // Distribute damage across all armor pieces proportionally
                let remainingArmorDamage = armorDamage;
                const slots = ['head', 'body', 'arms', 'legs', 'feet', 'belt'];
                
                for (let slot of slots) {
                    const armor = player.armorSlots[slot];
                    if (armor && armor.currentArmor > 0 && remainingArmorDamage > 0) {
                        const pieceDamage = Math.min(armor.currentArmor, remainingArmorDamage / 2);
                        armor.currentArmor -= pieceDamage;
                        remainingArmorDamage -= pieceDamage;
                    }
                }
                
                // Recalculate total armor from pieces
                recalculateArmorStats();
                amount -= armorDamage;
            }
            
            player.health -= amount;
            
            // Damage particles
            for (let i = 0; i < 8; i++) {
                particles.push({
                    x: player.x,
                    y: player.y,
                    vx: (Math.random() - 0.5) * 6,
                    vy: (Math.random() - 0.5) * 6,
                    life: 20,
                    color: '#c41e3a',
                    radius: 4
                });
            }
            
            if (player.health <= 0) {
                gameOver();
            }
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vx *= 0.95;
                p.vy *= 0.95;
                p.life--;
                
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        function updateHUD() {
            // Safety check if player not initialized
            if (!player) return;
            
            // Fix NaN bounty
            if (isNaN(bounty) || bounty === undefined || bounty === null) {
                bounty = 0;
            }
            
            document.getElementById('health-bar').style.width = `${(player.health / player.maxHealth) * 100}%`;
            document.getElementById('armor-bar').style.width = `${(player.armor / player.maxArmor) * 100}%`;
            document.getElementById('xp-bar').style.width = `${(player.xp / player.xpToLevel) * 100}%`;
            document.getElementById('bounty-display').textContent = `$${Math.floor(bounty)}`;
            
            // Update horse health bar
            const horseBarContainer = document.getElementById('horse-bar-container');
            const horseBar = document.getElementById('horse-bar');
            if (player.horse) {
                horseBarContainer.classList.remove('hidden');
                horseBar.style.width = `${(player.horse.health / player.horse.maxHealth) * 100}%`;
            } else {
                horseBarContainer.classList.add('hidden');
            }
            
            // Update weapon display
            const meleeDisplay = document.getElementById('melee-weapon-display');
            const rangedDisplay = document.getElementById('ranged-weapon-display');
            
            if (meleeDisplay && rangedDisplay && player.meleeWeapon && player.rangedWeapon) {
                // Update active weapon highlight
                if (playerElevated) {
                    meleeDisplay.classList.remove('active');
                    rangedDisplay.classList.add('active');
                } else {
                    meleeDisplay.classList.add('active');
                    rangedDisplay.classList.remove('active');
                }
                
                // Update weapon info
                const melee = player.meleeWeapon;
                const ranged = player.rangedWeapon;
                
                document.getElementById('melee-weapon-name').textContent = melee.name;
                document.getElementById('melee-weapon-stats').textContent = `DMG: ${melee.damage} | RNG: ${melee.range}`;
                
                document.getElementById('ranged-weapon-name').textContent = ranged.name;
                document.getElementById('ranged-weapon-stats').textContent = `DMG: ${ranged.damage} | RNG: ${ranged.range}`;
            }
            
            // Update armor slot display
            const slots = ['head', 'body', 'arms', 'legs', 'feet', 'belt'];
            slots.forEach(slot => {
                const element = document.getElementById(`slot-${slot}`);
                if (element) {
                    const armor = player.armorSlots[slot];
                    element.classList.remove('equipped', 'grade-common', 'grade-uncommon', 'grade-rare', 'grade-epic', 'grade-legendary');
                    if (armor) {
                        element.classList.add('equipped', `grade-${armor.grade || 'common'}`);
                        element.textContent = armor.icon || element.textContent;
                        element.title = `${armor.name}\nArmor: ${armor.armor}`;
                    } else {
                        element.title = `${slot.charAt(0).toUpperCase() + slot.slice(1)}: Empty`;
                    }
                }
            });
        }

        function distance(a, b) {
            return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
        }

        function render() {
            // Clear with grass base color
            ctx.fillStyle = '#4a7c3f';
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            
            // Save context and apply camera transform
            ctx.save();
            ctx.translate(-camera.x, -camera.y);
            
            // Draw grass color variations (background layer)
            for (let patch of grassPatches) {
                if (patch.x > camera.x - 100 && patch.x < camera.x + GAME_WIDTH + 100 &&
                    patch.y > camera.y - 100 && patch.y < camera.y + GAME_HEIGHT + 100) {
                    ctx.beginPath();
                    ctx.arc(patch.x, patch.y, patch.radius, 0, Math.PI * 2);
                    ctx.fillStyle = patch.color;
                    ctx.fill();
                }
            }
            
            // Draw dirt patches
            ctx.fillStyle = '#8b7355';
            for (let dirt of dirtPatches) {
                if (dirt.x > camera.x - 150 && dirt.x < camera.x + GAME_WIDTH + 150 &&
                    dirt.y > camera.y - 100 && dirt.y < camera.y + GAME_HEIGHT + 100) {
                    ctx.save();
                    ctx.translate(dirt.x, dirt.y);
                    ctx.rotate(dirt.rotation);
                    ctx.beginPath();
                    ctx.ellipse(0, 0, dirt.radiusX, dirt.radiusY, 0, 0, Math.PI * 2);
                    ctx.fillStyle = '#8b7355';
                    ctx.fill();
                    // Darker edge
                    ctx.beginPath();
                    ctx.ellipse(0, 0, dirt.radiusX * 0.7, dirt.radiusY * 0.7, 0, 0, Math.PI * 2);
                    ctx.fillStyle = '#9c8465';
                    ctx.fill();
                    ctx.restore();
                }
            }
            
            // Draw subtle grid for building reference
            ctx.strokeStyle = 'rgba(0,0,0,0.05)';
            const startX = Math.floor(camera.x / GRID_SIZE) * GRID_SIZE;
            const startY = Math.floor(camera.y / GRID_SIZE) * GRID_SIZE;
            for (let i = startX; i < camera.x + GAME_WIDTH + GRID_SIZE; i += GRID_SIZE) {
                for (let j = startY; j < camera.y + GAME_HEIGHT + GRID_SIZE; j += GRID_SIZE) {
                    if (i >= 0 && i < WORLD_WIDTH && j >= 0 && j < WORLD_HEIGHT) {
                        ctx.strokeRect(i, j, GRID_SIZE, GRID_SIZE);
                    }
                }
            }
            
            // Draw world boundary (forest edge)
            ctx.strokeStyle = '#2d4a1c';
            ctx.lineWidth = 8;
            ctx.strokeRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);
            ctx.lineWidth = 1;
            
            // Draw terrain elements behind entities
            drawTerrainBehind();
            
            if (gameState !== 'playing') {
                ctx.restore();
                return;
            }
            
            // Draw buildings (behind everything else)
            drawBuildings();
            
            // Draw siege weapons (on top of buildings)
            drawSiegeWeapons();
            
            // Draw siege projectiles
            drawSiegeProjectiles();
            
            // Draw drops
            for (let drop of drops) {
                const pulse = Math.sin(Date.now() / 200) * 3;
                
                // Glow
                ctx.beginPath();
                ctx.arc(drop.x, drop.y, drop.radius + 10 + pulse, 0, Math.PI * 2);
                ctx.fillStyle = drop.color + '33';
                ctx.fill();
                
                // Base
                ctx.beginPath();
                ctx.arc(drop.x, drop.y, drop.radius, 0, Math.PI * 2);
                ctx.fillStyle = drop.color;
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Icon
                ctx.font = '16px serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#fff';
                ctx.fillText(drop.icon, drop.x, drop.y);
            }
            
            // Draw enemies
            for (let enemy of enemies) {
                ctx.save();
                ctx.translate(enemy.x, enemy.y);
                
                // Face toward player
                const angleToPlayer = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                const facing = Math.cos(angleToPlayer) > 0 ? 1 : -1;
                
                // Walking animation
                const walkCycle = (Date.now() / 150) % (Math.PI * 2);
                const legSwing = Math.sin(walkCycle) * 0.3;
                const armSwing = Math.sin(walkCycle + Math.PI) * 0.2;
                const bodyBob = Math.abs(Math.sin(walkCycle)) * 2;
                
                // Shadow
                ctx.beginPath();
                ctx.ellipse(0, enemy.radius, enemy.radius * 0.8, enemy.radius * 0.3, 0, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.fill();
                
                // Draw based on enemy type
                if (enemy.type === 'basic') {
                    // PEASANT CONSCRIPT - Simple villager with pitchfork
                    drawPeasantEnemy(ctx, facing, legSwing, armSwing, bodyBob, enemy.radius);
                } else if (enemy.type === 'fast') {
                    // GOBLIN SCOUT - Small, quick, green creature
                    drawGoblinEnemy(ctx, facing, legSwing, armSwing, bodyBob, enemy.radius);
                } else if (enemy.type === 'tank') {
                    // ARMORED KNIGHT - Heavy plate armor, shield
                    drawKnightEnemy(ctx, facing, legSwing, armSwing, bodyBob, enemy.radius);
                } else if (enemy.type === 'berserker') {
                    // BARBARIAN - Fur-clad, dual axes
                    drawBarbarianEnemy(ctx, facing, legSwing, armSwing, bodyBob, enemy.radius);
                } else if (enemy.type === 'elite') {
                    // DARK MAGE - Robed spellcaster
                    drawMageEnemy(ctx, facing, legSwing, armSwing, bodyBob, enemy.radius);
                } else if (enemy.type === 'brute') {
                    // OGRE - Large, club-wielding monster
                    drawOgreEnemy(ctx, facing, legSwing, armSwing, bodyBob, enemy.radius);
                } else if (enemy.type === 'boss') {
                    // DEMON LORD - Horned, armored demon
                    drawDemonEnemy(ctx, facing, legSwing, armSwing, bodyBob, enemy.radius);
                } else {
                    // Fallback to simple circle
                    ctx.beginPath();
                    ctx.arc(0, 0, enemy.radius, 0, Math.PI * 2);
                    ctx.fillStyle = enemy.color;
                    ctx.fill();
                }
                
                ctx.restore();
                
                // Health bar (draw after restore so it's not rotated)
                if (enemy.health < enemy.maxHealth) {
                    ctx.fillStyle = '#333';
                    ctx.fillRect(enemy.x - 15, enemy.y - enemy.radius - 15, 30, 5);
                    ctx.fillStyle = '#c41e3a';
                    ctx.fillRect(enemy.x - 15, enemy.y - enemy.radius - 15, 30 * (enemy.health / enemy.maxHealth), 5);
                }
            }
            
            // Draw projectiles
            for (let proj of projectiles) {
                ctx.beginPath();
                ctx.arc(proj.x, proj.y, proj.radius, 0, Math.PI * 2);
                ctx.fillStyle = proj.color;
                ctx.fill();
                
                // Trail
                ctx.beginPath();
                ctx.moveTo(proj.x, proj.y);
                ctx.lineTo(proj.x - proj.vx * 2, proj.y - proj.vy * 2);
                ctx.strokeStyle = proj.color + '88';
                ctx.lineWidth = 3;
                ctx.stroke();
            }
            
            // Draw particles
            for (let p of particles) {
                ctx.globalAlpha = p.life / 40;
                
                if (p.text) {
                    // Text particle (for CRIT!, BLOCKED, etc.)
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillStyle = p.textColor || p.color;
                    ctx.fillText(p.text, p.x, p.y);
                } else {
                    // Normal circular particle
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.radius * (p.life / 40), 0, Math.PI * 2);
                    ctx.fillStyle = p.color;
                    ctx.fill();
                }
            }
            ctx.globalAlpha = 1;
            
            // Draw melee swing effect
            drawMeleeSwing();
            
            // Draw player
            drawPlayer();
            
            // Draw forge interaction prompt
            if (buildPhase && checkForgeInteraction() && !forgeOpen) {
                // Find the forge
                for (let b of buildings) {
                    if (b.type === 'forge') {
                        const dist = distance(player, { x: b.x + GRID_SIZE/2, y: b.y + GRID_SIZE/2 });
                        if (dist < GRID_SIZE * 1.5) {
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                            ctx.fillRect(b.x - 10, b.y - 35, GRID_SIZE + 20, 25);
                            ctx.font = 'bold 12px Arial';
                            ctx.fillStyle = '#f97316';
                            ctx.textAlign = 'center';
                            ctx.fillText('Press F - Forge', b.x + GRID_SIZE/2, b.y - 18);
                            break;
                        }
                    }
                }
            }
            
            // Draw stable interaction prompt
            if (buildPhase && checkStableInteraction() && !stableOpen) {
                // Find the stable
                for (let b of buildings) {
                    if (b.type === 'stable') {
                        const dist = distance(player, { x: b.x + GRID_SIZE/2, y: b.y + GRID_SIZE/2 });
                        if (dist < GRID_SIZE * 1.5) {
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                            ctx.fillRect(b.x - 10, b.y - 35, GRID_SIZE + 20, 25);
                            ctx.font = 'bold 12px Arial';
                            ctx.fillStyle = '#84cc16';
                            ctx.textAlign = 'center';
                            ctx.fillText('Press H - Stable', b.x + GRID_SIZE/2, b.y - 18);
                            break;
                        }
                    }
                }
            }
            
            // Draw foreground terrain (trees, rocks, bushes in front of player based on Y)
            drawTerrainFront();
            
            // Restore camera transform
            ctx.restore();
        }
        
        function drawHorseMount(facing, isMoving, walkCycle) {
            const horseType = player.horse ? player.horse.type : 'stallion';
            const horseBob = isMoving ? Math.sin(walkCycle * 2) * 3 : 0;
            const legAnim = isMoving ? Math.sin(walkCycle * 2) * 0.5 : 0;
            
            ctx.save();
            ctx.scale(facing, 1);
            ctx.translate(0, horseBob);
            
            // Horse colors based on type
            const colors = {
                pony: { body: '#8B7355', mane: '#4a3728', accent: '#6B5344' },
                stallion: { body: '#8B4513', mane: '#3d2314', accent: '#6B3510' },
                warhorse: { body: '#2F2F2F', mane: '#1a1a1a', accent: '#4a4a4a' },
                destrier: { body: '#F5F5DC', mane: '#d4d4aa', accent: '#e5e5cc' }
            };
            const c = colors[horseType] || colors.stallion;
            
            // Shadow
            ctx.beginPath();
            ctx.ellipse(0, 28, 22, 6, 0, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fill();
            
            // Back legs
            ctx.save();
            ctx.translate(-12, 10);
            ctx.rotate(legAnim);
            ctx.fillStyle = c.body;
            ctx.fillRect(-3, 0, 6, 18);
            // Hoof
            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(-3, 15, 6, 5);
            ctx.restore();
            
            ctx.save();
            ctx.translate(-8, 10);
            ctx.rotate(-legAnim);
            ctx.fillStyle = c.accent;
            ctx.fillRect(-3, 0, 6, 18);
            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(-3, 15, 6, 5);
            ctx.restore();
            
            // Body
            ctx.fillStyle = c.body;
            ctx.beginPath();
            ctx.ellipse(0, 5, 20, 12, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Body highlight
            ctx.fillStyle = c.accent;
            ctx.beginPath();
            ctx.ellipse(-3, 2, 14, 8, -0.2, 0, Math.PI * 2);
            ctx.fill();
            
            // Front legs
            ctx.save();
            ctx.translate(10, 10);
            ctx.rotate(-legAnim);
            ctx.fillStyle = c.body;
            ctx.fillRect(-3, 0, 6, 18);
            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(-3, 15, 6, 5);
            ctx.restore();
            
            ctx.save();
            ctx.translate(14, 10);
            ctx.rotate(legAnim);
            ctx.fillStyle = c.accent;
            ctx.fillRect(-3, 0, 6, 18);
            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(-3, 15, 6, 5);
            ctx.restore();
            
            // Neck
            ctx.fillStyle = c.body;
            ctx.beginPath();
            ctx.moveTo(15, 0);
            ctx.quadraticCurveTo(25, -15, 28, -25);
            ctx.quadraticCurveTo(30, -15, 20, 5);
            ctx.closePath();
            ctx.fill();
            
            // Head
            ctx.fillStyle = c.body;
            ctx.beginPath();
            ctx.ellipse(30, -28, 10, 7, 0.3, 0, Math.PI * 2);
            ctx.fill();
            
            // Snout
            ctx.fillStyle = c.accent;
            ctx.beginPath();
            ctx.ellipse(38, -25, 6, 4, 0.2, 0, Math.PI * 2);
            ctx.fill();
            
            // Eye
            ctx.fillStyle = '#1a1a1a';
            ctx.beginPath();
            ctx.arc(28, -30, 2, 0, Math.PI * 2);
            ctx.fill();
            
            // Ear
            ctx.fillStyle = c.body;
            ctx.beginPath();
            ctx.moveTo(25, -33);
            ctx.lineTo(22, -42);
            ctx.lineTo(28, -35);
            ctx.closePath();
            ctx.fill();
            
            // Mane
            ctx.fillStyle = c.mane;
            ctx.beginPath();
            ctx.moveTo(22, -35);
            ctx.quadraticCurveTo(18, -25, 15, -10);
            ctx.quadraticCurveTo(12, -20, 20, -35);
            ctx.fill();
            
            // Tail
            ctx.fillStyle = c.mane;
            ctx.beginPath();
            ctx.moveTo(-18, 5);
            ctx.quadraticCurveTo(-30, 10 + Math.sin(walkCycle) * 5, -25, 20);
            ctx.quadraticCurveTo(-20, 15, -18, 8);
            ctx.fill();
            
            // Saddle
            ctx.fillStyle = '#5c3d2e';
            ctx.beginPath();
            ctx.ellipse(0, -2, 10, 6, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#8b5a3c';
            ctx.beginPath();
            ctx.ellipse(0, -4, 8, 4, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Saddle horn
            ctx.fillStyle = '#4a2a1a';
            ctx.fillRect(6, -10, 4, 8);
            
            // Reins
            ctx.strokeStyle = '#3d2314';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(5, -8);
            ctx.quadraticCurveTo(15, -15, 32, -22);
            ctx.stroke();
            
            // Armor for warhorse/destrier
            if (horseType === 'warhorse' || horseType === 'destrier') {
                ctx.fillStyle = horseType === 'destrier' ? '#c0c0c0' : '#4a4a4a';
                // Head armor
                ctx.beginPath();
                ctx.moveTo(25, -35);
                ctx.lineTo(35, -35);
                ctx.lineTo(40, -25);
                ctx.lineTo(30, -22);
                ctx.closePath();
                ctx.fill();
                
                // Body armor
                ctx.fillRect(-5, -5, 15, 10);
            }
            
            ctx.restore();
        }
        
        // ========== MEDIEVAL ENEMY DRAWING FUNCTIONS ==========
        
        function drawPeasantEnemy(ctx, facing, legSwing, armSwing, bodyBob, radius) {
            const scale = radius / 14;
            ctx.scale(scale, scale);
            ctx.scale(facing, 1);
            
            // Legs
            ctx.fillStyle = '#5c4033';
            ctx.save();
            ctx.translate(-3, 8);
            ctx.rotate(-legSwing);
            ctx.fillRect(-2, 0, 4, 12);
            ctx.restore();
            ctx.save();
            ctx.translate(3, 8);
            ctx.rotate(legSwing);
            ctx.fillRect(-2, 0, 4, 12);
            ctx.restore();
            
            // Feet
            ctx.fillStyle = '#3d2b1f';
            ctx.fillRect(-6, 18, 5, 3);
            ctx.fillRect(1, 18, 5, 3);
            
            // Body (tunic)
            ctx.fillStyle = '#8b7355';
            ctx.beginPath();
            ctx.moveTo(-8, -2 + bodyBob);
            ctx.lineTo(8, -2 + bodyBob);
            ctx.lineTo(6, 10);
            ctx.lineTo(-6, 10);
            ctx.closePath();
            ctx.fill();
            
            // Arms
            ctx.fillStyle = '#d4a574';
            ctx.save();
            ctx.translate(-8, 2 + bodyBob);
            ctx.rotate(-armSwing - 0.5);
            ctx.fillRect(-2, 0, 4, 10);
            ctx.restore();
            ctx.save();
            ctx.translate(8, 2 + bodyBob);
            ctx.rotate(armSwing - 0.8);
            ctx.fillRect(-2, 0, 4, 10);
            ctx.fillStyle = '#5a4030';
            ctx.fillRect(-1, 8, 2, 20);
            ctx.fillStyle = '#6a6a6a';
            ctx.fillRect(-4, 26, 2, 8);
            ctx.fillRect(-1, 26, 2, 8);
            ctx.fillRect(2, 26, 2, 8);
            ctx.restore();
            
            // Head
            ctx.fillStyle = '#d4a574';
            ctx.beginPath();
            ctx.arc(0, -8 + bodyBob, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#4a3728';
            ctx.beginPath();
            ctx.arc(0, -10 + bodyBob, 7, Math.PI, 0);
            ctx.fill();
            
            // Eyes
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(-3, -8 + bodyBob, 2, 0, Math.PI * 2);
            ctx.arc(3, -8 + bodyBob, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(-3, -8 + bodyBob, 1, 0, Math.PI * 2);
            ctx.arc(3, -8 + bodyBob, 1, 0, Math.PI * 2);
            ctx.fill();
        }
        
        function drawGoblinEnemy(ctx, facing, legSwing, armSwing, bodyBob, radius) {
            const scale = radius / 10;
            ctx.scale(scale, scale);
            ctx.scale(facing, 1);
            
            // Legs
            ctx.fillStyle = '#4a7c40';
            ctx.save();
            ctx.translate(-2, 5);
            ctx.rotate(-legSwing * 1.5);
            ctx.fillRect(-1.5, 0, 3, 10);
            ctx.restore();
            ctx.save();
            ctx.translate(2, 5);
            ctx.rotate(legSwing * 1.5);
            ctx.fillRect(-1.5, 0, 3, 10);
            ctx.restore();
            
            // Body
            ctx.fillStyle = '#5a8a50';
            ctx.beginPath();
            ctx.ellipse(0, 2 + bodyBob, 6, 7, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#4a3020';
            ctx.beginPath();
            ctx.moveTo(-5, -2 + bodyBob);
            ctx.lineTo(5, -2 + bodyBob);
            ctx.lineTo(4, 6 + bodyBob);
            ctx.lineTo(-4, 6 + bodyBob);
            ctx.closePath();
            ctx.fill();
            
            // Arms
            ctx.fillStyle = '#4a7c40';
            ctx.save();
            ctx.translate(-5, 0 + bodyBob);
            ctx.rotate(-armSwing - 0.3);
            ctx.fillRect(-2, 0, 3, 12);
            ctx.restore();
            ctx.save();
            ctx.translate(5, 0 + bodyBob);
            ctx.rotate(armSwing + 0.5);
            ctx.fillRect(-1, 0, 3, 12);
            ctx.fillStyle = '#8a8a8a';
            ctx.beginPath();
            ctx.moveTo(0, 14);
            ctx.lineTo(-2, 18);
            ctx.lineTo(0, 26);
            ctx.lineTo(2, 18);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
            
            // Head with pointy ears
            ctx.fillStyle = '#5a8a50';
            ctx.beginPath();
            ctx.ellipse(0, -6 + bodyBob, 7, 6, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(-6, -6 + bodyBob);
            ctx.lineTo(-14, -10 + bodyBob);
            ctx.lineTo(-7, -3 + bodyBob);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(6, -6 + bodyBob);
            ctx.lineTo(14, -10 + bodyBob);
            ctx.lineTo(7, -3 + bodyBob);
            ctx.closePath();
            ctx.fill();
            
            // Yellow eyes
            ctx.fillStyle = '#ffff00';
            ctx.beginPath();
            ctx.ellipse(-3, -6 + bodyBob, 3, 2.5, 0, 0, Math.PI * 2);
            ctx.ellipse(3, -6 + bodyBob, 3, 2.5, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.ellipse(-3, -6 + bodyBob, 1.5, 2, 0, 0, Math.PI * 2);
            ctx.ellipse(3, -6 + bodyBob, 1.5, 2, 0, 0, Math.PI * 2);
            ctx.fill();
        }
        
        function drawKnightEnemy(ctx, facing, legSwing, armSwing, bodyBob, radius) {
            const scale = radius / 22;
            ctx.scale(scale, scale);
            ctx.scale(facing, 1);
            
            // Armored legs
            ctx.fillStyle = '#4a4a5a';
            ctx.save();
            ctx.translate(-5, 12);
            ctx.rotate(-legSwing * 0.5);
            ctx.fillRect(-4, 0, 8, 16);
            ctx.restore();
            ctx.save();
            ctx.translate(5, 12);
            ctx.rotate(legSwing * 0.5);
            ctx.fillRect(-4, 0, 8, 16);
            ctx.restore();
            
            // Plate armor body
            ctx.fillStyle = '#5a5a6a';
            ctx.beginPath();
            ctx.moveTo(-12, -5 + bodyBob);
            ctx.lineTo(12, -5 + bodyBob);
            ctx.lineTo(10, 15);
            ctx.lineTo(-10, 15);
            ctx.closePath();
            ctx.fill();
            
            // Shield arm
            ctx.save();
            ctx.translate(-12, 2 + bodyBob);
            ctx.rotate(-armSwing * 0.3);
            ctx.fillStyle = '#4a4a5a';
            ctx.fillRect(-3, 3, 6, 14);
            ctx.fillStyle = '#8b0000';
            ctx.beginPath();
            ctx.moveTo(-8, 10);
            ctx.lineTo(8, 10);
            ctx.lineTo(8, 28);
            ctx.lineTo(0, 34);
            ctx.lineTo(-8, 28);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.restore();
            
            // Sword arm
            ctx.save();
            ctx.translate(12, 2 + bodyBob);
            ctx.rotate(armSwing * 0.3 + 0.5);
            ctx.fillStyle = '#4a4a5a';
            ctx.fillRect(-3, 3, 6, 14);
            ctx.fillStyle = '#c0c0c0';
            ctx.fillRect(-2, 20, 4, 30);
            ctx.fillStyle = '#ffd700';
            ctx.fillRect(-5, 18, 10, 4);
            ctx.restore();
            
            // Great helm
            ctx.fillStyle = '#4a4a5a';
            ctx.beginPath();
            ctx.moveTo(-10, -8 + bodyBob);
            ctx.lineTo(10, -8 + bodyBob);
            ctx.lineTo(10, -22 + bodyBob);
            ctx.quadraticCurveTo(0, -32 + bodyBob, -10, -22 + bodyBob);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(-8, -20 + bodyBob, 16, 3);
            ctx.fillRect(-7, -15 + bodyBob, 14, 2);
        }
        
        function drawBarbarianEnemy(ctx, facing, legSwing, armSwing, bodyBob, radius) {
            const scale = radius / 13;
            ctx.scale(scale, scale);
            ctx.scale(facing, 1);
            
            // Legs
            ctx.fillStyle = '#d4a574';
            ctx.save();
            ctx.translate(-4, 8);
            ctx.rotate(-legSwing);
            ctx.fillRect(-3, 0, 6, 14);
            ctx.fillStyle = '#5a4030';
            ctx.fillRect(-3.5, 8, 7, 6);
            ctx.restore();
            ctx.save();
            ctx.translate(4, 8);
            ctx.rotate(legSwing);
            ctx.fillRect(-3, 0, 6, 14);
            ctx.fillStyle = '#5a4030';
            ctx.fillRect(-3.5, 8, 7, 6);
            ctx.restore();
            
            // Muscular body
            ctx.fillStyle = '#d4a574';
            ctx.beginPath();
            ctx.moveTo(-10, -4 + bodyBob);
            ctx.lineTo(10, -4 + bodyBob);
            ctx.lineTo(8, 10);
            ctx.lineTo(-8, 10);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = '#5a4030';
            ctx.fillRect(-8, -2 + bodyBob, 6, 10);
            ctx.fillRect(2, -2 + bodyBob, 6, 10);
            
            // Arms with axes
            ctx.fillStyle = '#d4a574';
            ctx.save();
            ctx.translate(-10, 0 + bodyBob);
            ctx.rotate(-armSwing - 0.7);
            ctx.fillRect(-4, 0, 7, 14);
            ctx.fillStyle = '#5a4030';
            ctx.fillRect(-1, 12, 3, 20);
            ctx.fillStyle = '#6a6a6a';
            ctx.beginPath();
            ctx.moveTo(-1, 28);
            ctx.lineTo(-10, 24);
            ctx.quadraticCurveTo(-12, 30, -8, 36);
            ctx.lineTo(-1, 32);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
            ctx.save();
            ctx.translate(10, 0 + bodyBob);
            ctx.rotate(armSwing + 0.7);
            ctx.fillStyle = '#d4a574';
            ctx.fillRect(-3, 0, 7, 14);
            ctx.fillStyle = '#5a4030';
            ctx.fillRect(-1, 12, 3, 20);
            ctx.fillStyle = '#6a6a6a';
            ctx.beginPath();
            ctx.moveTo(2, 28);
            ctx.lineTo(11, 24);
            ctx.quadraticCurveTo(13, 30, 9, 36);
            ctx.lineTo(2, 32);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
            
            // Head with wild hair
            ctx.fillStyle = '#d4a574';
            ctx.beginPath();
            ctx.arc(0, -10 + bodyBob, 9, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#8b4513';
            ctx.beginPath();
            ctx.arc(0, -12 + bodyBob, 8, Math.PI, 0);
            ctx.fill();
            ctx.fillRect(-9, -12 + bodyBob, 4, 8);
            ctx.fillRect(5, -12 + bodyBob, 4, 8);
            ctx.fillStyle = '#c41e3a';
            ctx.fillRect(-7, -12 + bodyBob, 3, 8);
            ctx.fillRect(4, -12 + bodyBob, 3, 8);
            
            // Eyes
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(-3, -10 + bodyBob, 2.5, 0, Math.PI * 2);
            ctx.arc(3, -10 + bodyBob, 2.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#4a2a0a';
            ctx.beginPath();
            ctx.arc(-3, -10 + bodyBob, 1.2, 0, Math.PI * 2);
            ctx.arc(3, -10 + bodyBob, 1.2, 0, Math.PI * 2);
            ctx.fill();
        }
        
        function drawMageEnemy(ctx, facing, legSwing, armSwing, bodyBob, radius) {
            const scale = radius / 16;
            ctx.scale(scale, scale);
            ctx.scale(facing, 1);
            
            // Robe
            ctx.fillStyle = '#2a1a3a';
            ctx.beginPath();
            ctx.moveTo(-10, 5 + bodyBob);
            ctx.lineTo(10, 5 + bodyBob);
            ctx.quadraticCurveTo(12, 20, 8, 24);
            ctx.lineTo(-8, 24);
            ctx.quadraticCurveTo(-12, 20, -10, 5 + bodyBob);
            ctx.closePath();
            ctx.fill();
            
            // Body
            ctx.fillStyle = '#3a2a4a';
            ctx.beginPath();
            ctx.moveTo(-10, -8 + bodyBob);
            ctx.lineTo(10, -8 + bodyBob);
            ctx.lineTo(10, 8);
            ctx.lineTo(-10, 8);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#9b59b6';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(0, 0 + bodyBob, 4, 0, Math.PI * 2);
            ctx.stroke();
            
            // Staff arm
            ctx.save();
            ctx.translate(-10, -2 + bodyBob);
            ctx.rotate(-armSwing * 0.5);
            ctx.fillStyle = '#d4a574';
            ctx.fillRect(-2, 2, 4, 8);
            ctx.fillStyle = '#4a3020';
            ctx.fillRect(-1.5, 8, 3, 35);
            ctx.fillStyle = '#9b59b6';
            ctx.beginPath();
            ctx.arc(0, 6, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            
            // Casting arm
            ctx.save();
            ctx.translate(10, -2 + bodyBob);
            ctx.rotate(armSwing * 0.5);
            ctx.fillStyle = '#d4a574';
            ctx.fillRect(-2, 2, 4, 8);
            ctx.fillStyle = 'rgba(155, 89, 182, 0.6)';
            ctx.beginPath();
            ctx.arc(0, 14, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            
            // Hood
            ctx.fillStyle = '#2a1a3a';
            ctx.beginPath();
            ctx.moveTo(-12, -6 + bodyBob);
            ctx.quadraticCurveTo(-14, -20 + bodyBob, 0, -26 + bodyBob);
            ctx.quadraticCurveTo(14, -20 + bodyBob, 12, -6 + bodyBob);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = '#1a0a1a';
            ctx.beginPath();
            ctx.ellipse(0, -12 + bodyBob, 7, 8, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Glowing eyes
            ctx.fillStyle = '#9b59b6';
            ctx.beginPath();
            ctx.arc(-3, -13 + bodyBob, 2, 0, Math.PI * 2);
            ctx.arc(3, -13 + bodyBob, 2, 0, Math.PI * 2);
            ctx.fill();
        }
        
        function drawOgreEnemy(ctx, facing, legSwing, armSwing, bodyBob, radius) {
            const scale = radius / 26;
            ctx.scale(scale, scale);
            ctx.scale(facing, 1);
            
            // Thick legs
            ctx.fillStyle = '#4a6a3a';
            ctx.save();
            ctx.translate(-8, 15);
            ctx.rotate(-legSwing * 0.4);
            ctx.fillRect(-6, 0, 12, 20);
            ctx.restore();
            ctx.save();
            ctx.translate(8, 15);
            ctx.rotate(legSwing * 0.4);
            ctx.fillRect(-6, 0, 12, 20);
            ctx.restore();
            
            // Huge body
            ctx.fillStyle = '#5a7a4a';
            ctx.beginPath();
            ctx.ellipse(0, 5 + bodyBob, 18, 20, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#6a8a5a';
            ctx.beginPath();
            ctx.ellipse(0, 10 + bodyBob, 12, 12, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#5a4030';
            ctx.beginPath();
            ctx.moveTo(-12, 12 + bodyBob);
            ctx.lineTo(12, 12 + bodyBob);
            ctx.lineTo(10, 25);
            ctx.lineTo(-10, 25);
            ctx.closePath();
            ctx.fill();
            
            // Massive arms
            ctx.fillStyle = '#5a7a4a';
            ctx.save();
            ctx.translate(-18, 0 + bodyBob);
            ctx.rotate(-armSwing * 0.3);
            ctx.fillRect(-6, 0, 12, 25);
            ctx.fillStyle = '#4a6a3a';
            ctx.beginPath();
            ctx.arc(0, 28, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            ctx.save();
            ctx.translate(18, 0 + bodyBob);
            ctx.rotate(armSwing * 0.3 + 0.4);
            ctx.fillStyle = '#5a7a4a';
            ctx.fillRect(-6, 0, 12, 25);
            ctx.fillStyle = '#4a6a3a';
            ctx.beginPath();
            ctx.arc(0, 28, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#4a3020';
            ctx.fillRect(-4, 30, 8, 40);
            ctx.fillStyle = '#5a4030';
            ctx.beginPath();
            ctx.ellipse(0, 68, 12, 16, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            
            // Small head
            ctx.fillStyle = '#5a7a4a';
            ctx.beginPath();
            ctx.ellipse(0, -15 + bodyBob, 12, 10, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#ffff00';
            ctx.beginPath();
            ctx.arc(-4, -15 + bodyBob, 3, 0, Math.PI * 2);
            ctx.arc(4, -15 + bodyBob, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(-4, -15 + bodyBob, 1.5, 0, Math.PI * 2);
            ctx.arc(4, -15 + bodyBob, 1.5, 0, Math.PI * 2);
            ctx.fill();
            
            // Tusks
            ctx.fillStyle = '#e8e8d0';
            ctx.beginPath();
            ctx.moveTo(-6, -7 + bodyBob);
            ctx.lineTo(-8, -14 + bodyBob);
            ctx.lineTo(-4, -7 + bodyBob);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(6, -7 + bodyBob);
            ctx.lineTo(8, -14 + bodyBob);
            ctx.lineTo(4, -7 + bodyBob);
            ctx.closePath();
            ctx.fill();
        }
        
        function drawDemonEnemy(ctx, facing, legSwing, armSwing, bodyBob, radius) {
            const scale = radius / 35;
            ctx.scale(scale, scale);
            ctx.scale(facing, 1);
            
            // Hooved legs
            ctx.fillStyle = '#2a1a1a';
            ctx.save();
            ctx.translate(-10, 20);
            ctx.rotate(-legSwing * 0.3);
            ctx.fillRect(-6, 0, 12, 25);
            ctx.fillStyle = '#1a0a0a';
            ctx.beginPath();
            ctx.moveTo(-7, 25);
            ctx.lineTo(-8, 32);
            ctx.lineTo(8, 32);
            ctx.lineTo(7, 25);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
            ctx.save();
            ctx.translate(10, 20);
            ctx.rotate(legSwing * 0.3);
            ctx.fillStyle = '#2a1a1a';
            ctx.fillRect(-6, 0, 12, 25);
            ctx.fillStyle = '#1a0a0a';
            ctx.beginPath();
            ctx.moveTo(-7, 25);
            ctx.lineTo(-8, 32);
            ctx.lineTo(8, 32);
            ctx.lineTo(7, 25);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
            
            // Demonic body
            ctx.fillStyle = '#3a1a1a';
            ctx.beginPath();
            ctx.moveTo(-20, -10 + bodyBob);
            ctx.lineTo(20, -10 + bodyBob);
            ctx.lineTo(16, 25);
            ctx.lineTo(-16, 25);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#ff4444';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 8 + bodyBob, 6, 0, Math.PI * 2);
            ctx.stroke();
            
            // Wings
            ctx.fillStyle = '#2a1a1a';
            ctx.save();
            ctx.translate(-18, -5 + bodyBob);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.quadraticCurveTo(-30, -20, -25, 15);
            ctx.lineTo(0, 20);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
            ctx.save();
            ctx.translate(18, -5 + bodyBob);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.quadraticCurveTo(30, -20, 25, 15);
            ctx.lineTo(0, 20);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
            
            // Clawed arms
            ctx.fillStyle = '#3a1a1a';
            ctx.save();
            ctx.translate(-20, 0 + bodyBob);
            ctx.rotate(-armSwing - 0.5);
            ctx.fillRect(-5, 0, 10, 28);
            ctx.fillStyle = '#2a1a1a';
            ctx.beginPath();
            ctx.moveTo(-6, 28);
            ctx.lineTo(-10, 40);
            ctx.lineTo(0, 34);
            ctx.lineTo(10, 40);
            ctx.lineTo(6, 28);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
            ctx.save();
            ctx.translate(20, 0 + bodyBob);
            ctx.rotate(armSwing + 0.5);
            ctx.fillStyle = '#3a1a1a';
            ctx.fillRect(-5, 0, 10, 28);
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(-3, 35, 6, 50);
            ctx.strokeStyle = '#ff4444';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, 45);
            ctx.lineTo(0, 85);
            ctx.stroke();
            ctx.restore();
            
            // Head with horns
            ctx.fillStyle = '#3a1a1a';
            ctx.beginPath();
            ctx.ellipse(0, -18 + bodyBob, 14, 12, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#1a0a0a';
            ctx.beginPath();
            ctx.moveTo(-10, -22 + bodyBob);
            ctx.quadraticCurveTo(-20, -35 + bodyBob, -25, -45 + bodyBob);
            ctx.lineTo(-12, -25 + bodyBob);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(10, -22 + bodyBob);
            ctx.quadraticCurveTo(20, -35 + bodyBob, 25, -45 + bodyBob);
            ctx.lineTo(12, -25 + bodyBob);
            ctx.closePath();
            ctx.fill();
            
            // Glowing red eyes
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.ellipse(-5, -18 + bodyBob, 4, 3, 0, 0, Math.PI * 2);
            ctx.ellipse(5, -18 + bodyBob, 4, 3, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#ffff00';
            ctx.beginPath();
            ctx.arc(-5, -18 + bodyBob, 1.5, 0, Math.PI * 2);
            ctx.arc(5, -18 + bodyBob, 1.5, 0, Math.PI * 2);
            ctx.fill();
        }
        
        function drawPlayer() {
            if (!player) return;
            
            const p = player;
            const scale = 1;
            const facing = p.facingRight ? 1 : -1;
            const walkBob = p.isMoving ? Math.sin(p.walkCycle) * 2 : 0;
            const legSwing = p.isMoving ? Math.sin(p.walkCycle) * 0.4 : 0;
            
            // Elevation offset when on walls/towers
            const elevationOffset = playerElevated ? -20 : 0;
            
            ctx.save();
            ctx.translate(p.x, p.y + elevationOffset);
            
            // Draw horse if player has one
            if (p.horse && !playerElevated) {
                drawHorseMount(facing, p.isMoving, p.walkCycle);
            }
            
            // Draw elevated platform indicator if elevated
            if (playerElevated) {
                ctx.save();
                ctx.translate(0, -elevationOffset);
                // Shadow on ground level
                ctx.beginPath();
                ctx.ellipse(0, 22, 18, 7, 0, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0,0,0,0.2)';
                ctx.fill();
                ctx.restore();
                
                // Elevated glow/indicator
                ctx.beginPath();
                ctx.arc(0, 10, 25, 0, Math.PI * 2);
                const elevGlow = ctx.createRadialGradient(0, 10, 5, 0, 10, 30);
                elevGlow.addColorStop(0, 'rgba(255, 200, 100, 0.3)');
                elevGlow.addColorStop(1, 'rgba(255, 200, 100, 0)');
                ctx.fillStyle = elevGlow;
                ctx.fill();
            }
            
            // Shadow (smaller when elevated, skip when on horse)
            if (!p.horse || playerElevated) {
                ctx.beginPath();
                ctx.ellipse(0, 22, playerElevated ? 10 : 14, playerElevated ? 3 : 5, 0, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0,0,0,0.4)';
                ctx.fill();
            }
            
            // Offset player up when on horse
            const horseOffset = (p.horse && !playerElevated) ? -15 : 0;
            ctx.translate(0, horseOffset);
            
            // Armor glow effect
            if (p.armorVisual && p.armorVisual.glow) {
                ctx.beginPath();
                ctx.arc(0, 0, 28, 0, Math.PI * 2);
                const glow = ctx.createRadialGradient(0, 0, 15, 0, 0, 30);
                glow.addColorStop(0, 'rgba(255, 215, 0, 0.3)');
                glow.addColorStop(1, 'rgba(255, 215, 0, 0)');
                ctx.fillStyle = glow;
                ctx.fill();
            }
            
            // Legs (hidden when on horse)
            if (!p.horse || playerElevated) {
                ctx.save();
                
                // Check if legs armor is equipped
                const hasLegsArmor = p.armorSlots && p.armorSlots.legs;
                const hasFeetArmor = p.armorSlots && p.armorSlots.feet;
                const legSkinColor = '#d4a574';
                const underwearColor = '#8b6f5c'; // Brown underwear/shorts
                
                // Back leg
                ctx.save();
                ctx.translate(facing * -4, 10);
                ctx.rotate(-legSwing);
                
                if (hasLegsArmor) {
                    // Armored leg
                    ctx.fillStyle = '#4a4a4a';
                    ctx.fillRect(-3, 0, 6, 14);
                    ctx.fillStyle = '#5a5a5a';
                    ctx.fillRect(-2, 2, 4, 10);
                } else {
                    // Bare leg with underwear
                    ctx.fillStyle = underwearColor;
                    ctx.fillRect(-3, 0, 6, 5); // Underwear shorts
                    ctx.fillStyle = legSkinColor;
                    ctx.fillRect(-3, 5, 6, 9); // Bare leg
                }
                
                // Boot or bare foot
                if (hasFeetArmor) {
                    ctx.fillStyle = '#2a1a10';
                    ctx.fillRect(-4, 11, 8, 5);
                } else {
                    ctx.fillStyle = '#c49464'; // Bare foot
                    ctx.fillRect(-3, 12, 6, 4);
                }
                ctx.restore();
                
                // Front leg
                ctx.save();
                ctx.translate(facing * 4, 10);
                ctx.rotate(legSwing);
                
                if (hasLegsArmor) {
                    ctx.fillStyle = '#5a5a5a';
                    ctx.fillRect(-3, 0, 6, 14);
                    ctx.fillStyle = '#6a6a6a';
                    ctx.fillRect(-2, 2, 4, 10);
                } else {
                    ctx.fillStyle = underwearColor;
                    ctx.fillRect(-3, 0, 6, 5);
                    ctx.fillStyle = legSkinColor;
                    ctx.fillRect(-3, 5, 6, 9);
                }
                
                if (hasFeetArmor) {
                    ctx.fillStyle = '#2a1a10';
                    ctx.fillRect(-4, 11, 8, 5);
                } else {
                    ctx.fillStyle = '#c49464';
                    ctx.fillRect(-3, 12, 6, 4);
                }
                ctx.restore();
                ctx.restore();
            }
            
            // Body/Torso
            const hasBodyArmor = p.armorSlots && p.armorSlots.body;
            const hasArmsArmor = p.armorSlots && p.armorSlots.arms;
            const hasBeltArmor = p.armorSlots && p.armorSlots.belt;
            const bodySkinColor = '#d4a574';
            const bodySkinShadow = '#c49464';
            
            // Torso colors based on armor
            let torsoColor, torsoAccent;
            if (hasBodyArmor) {
                torsoColor = p.armorVisual ? p.armorVisual.torsoColor : '#6a6a6a';
                torsoAccent = p.armorVisual ? p.armorVisual.torsoAccent : '#5a5a5a';
            } else {
                torsoColor = bodySkinColor; // Bare chest
                torsoAccent = bodySkinShadow;
            }
            
            ctx.save();
            ctx.translate(0, walkBob);
            
            // Torso base
            ctx.fillStyle = torsoColor;
            ctx.beginPath();
            ctx.moveTo(-10, -5);
            ctx.lineTo(10, -5);
            ctx.lineTo(8, 12);
            ctx.lineTo(-8, 12);
            ctx.closePath();
            ctx.fill();
            
            // Torso shading/detail
            ctx.fillStyle = torsoAccent;
            ctx.fillRect(-8, 0, 4, 10);
            
            // If no body armor, draw chest details (pecs, abs hint)
            if (!hasBodyArmor) {
                ctx.strokeStyle = '#b8956a';
                ctx.lineWidth = 1;
                // Pec line
                ctx.beginPath();
                ctx.moveTo(-6, -2);
                ctx.quadraticCurveTo(0, 2, 6, -2);
                ctx.stroke();
                // Center line
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(0, 10);
                ctx.stroke();
            }
            
            // Armor pattern details (only if armored)
            if (hasBodyArmor && p.armorVisual) {
                if (p.armorVisual.pattern === 'chain') {
                    // Chain mail pattern
                    ctx.strokeStyle = '#5a6a7a';
                    ctx.lineWidth = 1;
                    for (let row = -3; row < 10; row += 4) {
                        for (let col = -6; col < 6; col += 4) {
                            ctx.beginPath();
                            ctx.arc(col, row, 2, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                    }
                } else if (p.armorVisual.pattern === 'plate') {
                    // Plate armor lines
                    ctx.strokeStyle = '#3a7ac9';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(0, -5);
                    ctx.lineTo(0, 10);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(-8, 2);
                    ctx.lineTo(8, 2);
                    ctx.stroke();
                } else if (p.armorVisual.pattern === 'ornate') {
                    // Golden ornate pattern
                    ctx.strokeStyle = '#daa520';
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.moveTo(0, -4);
                    ctx.quadraticCurveTo(6, 3, 0, 10);
                    ctx.quadraticCurveTo(-6, 3, 0, -4);
                    ctx.stroke();
                }
                
                // Shoulder pads (only with arms armor)
                if (hasArmsArmor && p.armorVisual.hasShoulders) {
                    ctx.fillStyle = p.armorVisual.shoulderColor || '#5a5a5a';
                    // Left shoulder
                    ctx.beginPath();
                    ctx.ellipse(-12, -3, 6, 4, 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    // Right shoulder
                    ctx.beginPath();
                    ctx.ellipse(12, -3, 6, 4, -0.3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Belt
            if (hasBeltArmor) {
                ctx.fillStyle = '#3d2b1f';
                ctx.fillRect(-9, 8, 18, 4);
                ctx.fillStyle = '#ffd700';
                ctx.fillRect(-2, 9, 4, 3); // Belt buckle
            } else {
                // Underwear waistband
                ctx.fillStyle = '#7a5f4c';
                ctx.fillRect(-9, 9, 18, 3);
            }
            
            ctx.restore();
            
            // Arms and weapon
            ctx.save();
            ctx.translate(0, walkBob);
            
            const currentWeapon = getCurrentWeapon();
            const weaponVisual = currentWeapon.visual;
            const aimAngle = p.aimAngle;
            
            // Arm holding weapon (front arm based on facing)
            ctx.save();
            const armOffsetX = facing * 8;
            ctx.translate(armOffsetX, -2);
            
            // Rotate arm toward aim direction
            const armAngle = facing > 0 ? aimAngle : aimAngle - Math.PI;
            ctx.rotate(armAngle * 0.5);
            
            // Upper arm
            const skinColor = '#d4a574';
            const skinShadow = '#c49464';
            ctx.fillStyle = skinColor;
            ctx.fillRect(-3, -2, 6, 12);
            
            // Forearm + weapon
            ctx.save();
            ctx.translate(0, 10);
            ctx.rotate(armAngle * 0.5);
            
            // Forearm
            ctx.fillStyle = skinShadow;
            ctx.fillRect(-2.5, 0, 5, 10);
            
            // Hand
            ctx.fillStyle = skinColor;
            ctx.beginPath();
            ctx.arc(0, 12, 4, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw weapon in hand
            if (weaponVisual) {
                ctx.save();
                ctx.translate(0, 14);
                
                if (weaponVisual.type === 'melee') {
                    // ===== MEDIEVAL MELEE WEAPONS =====
                    const weaponType = weaponVisual.weapon;
                    
                    if (weaponType === 'Dagger') {
                        // Dagger blade
                        const bladeGrad = ctx.createLinearGradient(-2, 0, 2, 0);
                        bladeGrad.addColorStop(0, '#a0a0a0');
                        bladeGrad.addColorStop(0.5, '#e0e0e0');
                        bladeGrad.addColorStop(1, '#a0a0a0');
                        ctx.fillStyle = bladeGrad;
                        ctx.beginPath();
                        ctx.moveTo(0, -25);
                        ctx.lineTo(-3, -8);
                        ctx.lineTo(3, -8);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Cross guard
                        ctx.fillStyle = '#8b4513';
                        ctx.fillRect(-6, -8, 12, 3);
                        
                        // Handle
                        ctx.fillStyle = '#5c3317';
                        ctx.fillRect(-2, -5, 4, 10);
                        
                        // Pommel
                        ctx.fillStyle = '#c0c0c0';
                        ctx.beginPath();
                        ctx.arc(0, 6, 3, 0, Math.PI * 2);
                        ctx.fill();
                        
                    } else if (weaponType === 'Sword') {
                        // Sword blade
                        const bladeGrad = ctx.createLinearGradient(-3, 0, 3, 0);
                        bladeGrad.addColorStop(0, '#b0b0b0');
                        bladeGrad.addColorStop(0.3, '#e8e8e8');
                        bladeGrad.addColorStop(0.7, '#e8e8e8');
                        bladeGrad.addColorStop(1, '#b0b0b0');
                        ctx.fillStyle = bladeGrad;
                        ctx.beginPath();
                        ctx.moveTo(0, -40);
                        ctx.lineTo(-4, -8);
                        ctx.lineTo(4, -8);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Blood groove (fuller)
                        ctx.strokeStyle = '#9a9a9a';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(0, -35);
                        ctx.lineTo(0, -12);
                        ctx.stroke();
                        
                        // Cross guard
                        ctx.fillStyle = '#ffd700';
                        ctx.fillRect(-10, -10, 20, 4);
                        ctx.fillStyle = '#daa520';
                        ctx.beginPath();
                        ctx.arc(-10, -8, 3, 0, Math.PI * 2);
                        ctx.arc(10, -8, 3, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Handle wrapped
                        ctx.fillStyle = '#4a2810';
                        ctx.fillRect(-3, -6, 6, 14);
                        ctx.strokeStyle = '#2a1805';
                        ctx.lineWidth = 1;
                        for (let i = -4; i < 6; i += 3) {
                            ctx.beginPath();
                            ctx.moveTo(-3, i);
                            ctx.lineTo(3, i + 2);
                            ctx.stroke();
                        }
                        
                        // Pommel
                        ctx.fillStyle = '#ffd700';
                        ctx.beginPath();
                        ctx.arc(0, 10, 4, 0, Math.PI * 2);
                        ctx.fill();
                        
                    } else if (weaponType === 'Axe') {
                        // Axe handle
                        ctx.fillStyle = '#6b4423';
                        ctx.fillRect(-2, -35, 4, 45);
                        
                        // Axe head
                        const axeGrad = ctx.createLinearGradient(-15, -30, 0, -30);
                        axeGrad.addColorStop(0, '#5a5a5a');
                        axeGrad.addColorStop(0.5, '#8a8a8a');
                        axeGrad.addColorStop(1, '#6a6a6a');
                        ctx.fillStyle = axeGrad;
                        ctx.beginPath();
                        ctx.moveTo(-2, -35);
                        ctx.lineTo(-15, -40);
                        ctx.quadraticCurveTo(-20, -30, -15, -20);
                        ctx.lineTo(-2, -25);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Axe edge highlight
                        ctx.strokeStyle = '#c0c0c0';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(-15, -40);
                        ctx.quadraticCurveTo(-20, -30, -15, -20);
                        ctx.stroke();
                        
                    } else if (weaponType === 'Mace') {
                        // Mace handle
                        ctx.fillStyle = '#5a4a3a';
                        ctx.fillRect(-2, -30, 4, 40);
                        
                        // Mace head
                        ctx.fillStyle = '#4a4a4a';
                        ctx.beginPath();
                        ctx.arc(0, -35, 10, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Flanges/spikes
                        ctx.fillStyle = '#5a5a5a';
                        for (let i = 0; i < 8; i++) {
                            const angle = (i / 8) * Math.PI * 2;
                            ctx.beginPath();
                            ctx.moveTo(Math.cos(angle) * 8, -35 + Math.sin(angle) * 8);
                            ctx.lineTo(Math.cos(angle) * 14, -35 + Math.sin(angle) * 14);
                            ctx.lineTo(Math.cos(angle + 0.2) * 8, -35 + Math.sin(angle + 0.2) * 8);
                            ctx.fill();
                        }
                        
                        // Mace head highlight
                        ctx.fillStyle = '#6a6a6a';
                        ctx.beginPath();
                        ctx.arc(-2, -37, 4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                } else if (weaponVisual.type === 'ranged') {
                    // ===== MEDIEVAL RANGED WEAPONS =====
                    const weaponType = weaponVisual.weapon;
                    
                    if (weaponType === 'Bow') {
                        // Bow held vertically (proper archery stance)
                        // The bow is held sideways in the hand, perpendicular to arm
                        ctx.save();
                        ctx.rotate(-Math.PI / 2); // Rotate 90 degrees so bow is vertical
                        
                        // Bow grip (center)
                        ctx.fillStyle = '#5a4030';
                        ctx.fillRect(-3, -4, 6, 8);
                        
                        // Bow limbs (top and bottom)
                        ctx.strokeStyle = '#8b4513';
                        ctx.lineWidth = 4;
                        // Top limb
                        ctx.beginPath();
                        ctx.moveTo(0, -4);
                        ctx.quadraticCurveTo(-12, -20, -6, -35);
                        ctx.stroke();
                        // Bottom limb
                        ctx.beginPath();
                        ctx.moveTo(0, 4);
                        ctx.quadraticCurveTo(-12, 20, -6, 35);
                        ctx.stroke();
                        
                        // Limb tips
                        ctx.fillStyle = '#6b4423';
                        ctx.beginPath();
                        ctx.arc(-6, -35, 2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(-6, 35, 2, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Bow string (pulled back)
                        ctx.strokeStyle = '#d4c4a4';
                        ctx.lineWidth = 1.5;
                        ctx.beginPath();
                        ctx.moveTo(-6, -35);
                        ctx.lineTo(8, 0); // String pulled back to hand
                        ctx.lineTo(-6, 35);
                        ctx.stroke();
                        
                        // Arrow nocked on string
                        ctx.fillStyle = '#5a4030';
                        ctx.save();
                        ctx.translate(8, 0);
                        // Arrow shaft
                        ctx.fillRect(-2, -1, 40, 2);
                        // Arrowhead
                        ctx.fillStyle = '#808080';
                        ctx.beginPath();
                        ctx.moveTo(40, 0);
                        ctx.lineTo(35, -3);
                        ctx.lineTo(35, 3);
                        ctx.closePath();
                        ctx.fill();
                        // Fletching
                        ctx.fillStyle = '#c41e3a';
                        ctx.beginPath();
                        ctx.moveTo(0, -1);
                        ctx.lineTo(-5, -5);
                        ctx.lineTo(-5, -1);
                        ctx.closePath();
                        ctx.fill();
                        ctx.beginPath();
                        ctx.moveTo(0, 1);
                        ctx.lineTo(-5, 5);
                        ctx.lineTo(-5, 1);
                        ctx.closePath();
                        ctx.fill();
                        ctx.restore();
                        
                        ctx.restore();
                        
                    } else if (weaponType === 'Crossbow') {
                        // Crossbow stock
                        ctx.fillStyle = '#654321';
                        ctx.fillRect(-3, -15, 6, 25);
                        
                        // Crossbow prod (bow part)
                        ctx.strokeStyle = '#4a4a4a';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(-20, -15);
                        ctx.quadraticCurveTo(0, -20, 20, -15);
                        ctx.stroke();
                        
                        // String
                        ctx.strokeStyle = '#d4c4a4';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(-18, -15);
                        ctx.lineTo(0, -12);
                        ctx.lineTo(18, -15);
                        ctx.stroke();
                        
                        // Bolt
                        ctx.fillStyle = '#5a4030';
                        ctx.fillRect(-1, -28, 2, 16);
                        ctx.fillStyle = '#808080';
                        ctx.beginPath();
                        ctx.moveTo(0, -32);
                        ctx.lineTo(-2, -28);
                        ctx.lineTo(2, -28);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Trigger mechanism
                        ctx.fillStyle = '#3a3a3a';
                        ctx.fillRect(-2, -5, 4, 8);
                        ctx.fillRect(0, 0, 3, 5);
                        
                    } else if (weaponType === 'Arbalest') {
                        // Heavy crossbow stock
                        ctx.fillStyle = '#4a3a2a';
                        ctx.beginPath();
                        ctx.moveTo(-4, -18);
                        ctx.lineTo(4, -18);
                        ctx.lineTo(5, 15);
                        ctx.lineTo(-5, 15);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Steel prod (heavier)
                        ctx.strokeStyle = '#3a3a3a';
                        ctx.lineWidth = 5;
                        ctx.beginPath();
                        ctx.moveTo(-25, -18);
                        ctx.quadraticCurveTo(0, -25, 25, -18);
                        ctx.stroke();
                        
                        // Steel highlight
                        ctx.strokeStyle = '#5a5a5a';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(-23, -19);
                        ctx.quadraticCurveTo(0, -26, 23, -19);
                        ctx.stroke();
                        
                        // String
                        ctx.strokeStyle = '#b4a494';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(-22, -17);
                        ctx.lineTo(0, -14);
                        ctx.lineTo(22, -17);
                        ctx.stroke();
                        
                        // Heavy bolt
                        ctx.fillStyle = '#3a3020';
                        ctx.fillRect(-1.5, -35, 3, 20);
                        ctx.fillStyle = '#2f4f4f';
                        ctx.beginPath();
                        ctx.moveTo(0, -42);
                        ctx.lineTo(-3, -35);
                        ctx.lineTo(3, -35);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Cranequin (winding mechanism)
                        ctx.fillStyle = '#5a5a5a';
                        ctx.fillRect(-6, -8, 12, 4);
                        ctx.beginPath();
                        ctx.arc(-6, -6, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                } else if (weaponVisual.type === 'pistol') {
                    // ===== COLT SINGLE ACTION ARMY REVOLVER =====
                    // Metal gradient for realism
                    const metalGrad = ctx.createLinearGradient(-3, -25, 3, -25);
                    metalGrad.addColorStop(0, '#5a5a5a');
                    metalGrad.addColorStop(0.3, '#7a7a7a');
                    metalGrad.addColorStop(0.5, '#8a8a8a');
                    metalGrad.addColorStop(0.7, '#6a6a6a');
                    metalGrad.addColorStop(1, '#4a4a4a');
                    
                    // Barrel - octagonal profile with detail
                    ctx.fillStyle = metalGrad;
                    ctx.beginPath();
                    ctx.moveTo(-2, -28);
                    ctx.lineTo(2, -28);
                    ctx.lineTo(2.5, -26);
                    ctx.lineTo(2.5, -12);
                    ctx.lineTo(-2.5, -12);
                    ctx.lineTo(-2.5, -26);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Barrel top flat (octagonal look)
                    ctx.fillStyle = '#8a8a8a';
                    ctx.fillRect(-1.5, -28, 3, 16);
                    
                    // Front sight - blade style
                    ctx.fillStyle = '#3a3a3a';
                    ctx.beginPath();
                    ctx.moveTo(0, -30);
                    ctx.lineTo(-1, -28);
                    ctx.lineTo(1, -28);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Ejector rod housing (under barrel)
                    ctx.fillStyle = '#4a4a4a';
                    ctx.fillRect(-0.8, -26, 1.6, 12);
                    ctx.beginPath();
                    ctx.arc(0, -26, 0.8, Math.PI, 0);
                    ctx.fill();
                    
                    // Cylinder - detailed with flutes
                    const cylGrad = ctx.createRadialGradient(0, -8, 0, 0, -8, 6);
                    cylGrad.addColorStop(0, '#7a7a7a');
                    cylGrad.addColorStop(0.7, '#5a5a5a');
                    cylGrad.addColorStop(1, '#3a3a3a');
                    ctx.fillStyle = cylGrad;
                    ctx.beginPath();
                    ctx.arc(0, -8, 6, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Cylinder flutes (indentations)
                    ctx.strokeStyle = '#4a4a4a';
                    ctx.lineWidth = 1;
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * Math.PI * 2 + Math.PI / 12;
                        const x1 = Math.cos(angle) * 3;
                        const y1 = -8 + Math.sin(angle) * 3;
                        const x2 = Math.cos(angle) * 5.5;
                        const y2 = -8 + Math.sin(angle) * 5.5;
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                    
                    // Chamber holes
                    ctx.fillStyle = '#1a1a1a';
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * Math.PI * 2;
                        ctx.beginPath();
                        ctx.arc(Math.cos(angle) * 3.5, -8 + Math.sin(angle) * 3.5, 1.3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    // Bullets visible in chambers
                    ctx.fillStyle = '#b87333';
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * Math.PI * 2;
                        ctx.beginPath();
                        ctx.arc(Math.cos(angle) * 3.5, -8 + Math.sin(angle) * 3.5, 0.8, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // Frame
                    ctx.fillStyle = '#5a5a5a';
                    ctx.beginPath();
                    ctx.moveTo(-3, -2);
                    ctx.lineTo(3, -2);
                    ctx.lineTo(3.5, -1);
                    ctx.lineTo(3.5, 2);
                    ctx.lineTo(-3.5, 2);
                    ctx.lineTo(-3.5, -1);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Hammer - cocked position
                    ctx.fillStyle = '#4a4a4a';
                    ctx.beginPath();
                    ctx.moveTo(-1, -3);
                    ctx.lineTo(1, -3);
                    ctx.lineTo(1.5, -7);
                    ctx.lineTo(0, -9);
                    ctx.lineTo(-1.5, -7);
                    ctx.closePath();
                    ctx.fill();
                    // Hammer spur
                    ctx.fillRect(-2, -8, 4, 1.5);
                    
                    // Trigger guard - brass
                    ctx.strokeStyle = '#b8860b';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-3, 1);
                    ctx.quadraticCurveTo(-4, 6, -1, 8);
                    ctx.quadraticCurveTo(1, 8, 3, 6);
                    ctx.quadraticCurveTo(4, 3, 3, 1);
                    ctx.stroke();
                    
                    // Trigger
                    ctx.fillStyle = '#3a3a3a';
                    ctx.beginPath();
                    ctx.moveTo(-0.5, 2);
                    ctx.lineTo(0.5, 2);
                    ctx.lineTo(0.3, 6);
                    ctx.lineTo(-0.3, 6);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Grip - one piece walnut style
                    const gripGrad = ctx.createLinearGradient(-4, 0, 4, 0);
                    gripGrad.addColorStop(0, '#5c3317');
                    gripGrad.addColorStop(0.3, '#8b4513');
                    gripGrad.addColorStop(0.5, '#a0522d');
                    gripGrad.addColorStop(0.7, '#8b4513');
                    gripGrad.addColorStop(1, '#5c3317');
                    
                    ctx.fillStyle = gripGrad;
                    ctx.beginPath();
                    ctx.moveTo(-3, 2);
                    ctx.quadraticCurveTo(-5, 6, -4.5, 12);
                    ctx.quadraticCurveTo(-4, 14, 0, 14);
                    ctx.quadraticCurveTo(4, 14, 4.5, 12);
                    ctx.quadraticCurveTo(5, 6, 3, 2);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Grip wood grain
                    ctx.strokeStyle = 'rgba(60, 30, 10, 0.3)';
                    ctx.lineWidth = 0.5;
                    for (let i = 0; i < 6; i++) {
                        ctx.beginPath();
                        ctx.moveTo(-3 + i * 1.2, 4);
                        ctx.quadraticCurveTo(-2 + i * 1.1, 9, -2.5 + i * 1.1, 13);
                        ctx.stroke();
                    }
                    
                    // Grip screw
                    ctx.fillStyle = '#b8860b';
                    ctx.beginPath();
                    ctx.arc(0, 8, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#8b6914';
                    ctx.lineWidth = 0.5;
                    ctx.beginPath();
                    ctx.moveTo(-1, 8);
                    ctx.lineTo(1, 8);
                    ctx.stroke();
                    
                } else if (weaponVisual.type === 'long' && p.weapon.baseName === 'Shotgun') {
                    // ===== DOUBLE BARREL SIDE-BY-SIDE SHOTGUN =====
                    
                    // Barrel metal gradient
                    const barrelGrad = ctx.createLinearGradient(-5, 0, 5, 0);
                    barrelGrad.addColorStop(0, '#2a2a2a');
                    barrelGrad.addColorStop(0.2, '#4a4a4a');
                    barrelGrad.addColorStop(0.5, '#3a3a3a');
                    barrelGrad.addColorStop(0.8, '#4a4a4a');
                    barrelGrad.addColorStop(1, '#2a2a2a');
                    
                    // Left barrel
                    ctx.fillStyle = barrelGrad;
                    ctx.beginPath();
                    ctx.roundRect(-5, -48, 4, 42, 1);
                    ctx.fill();
                    
                    // Right barrel  
                    ctx.beginPath();
                    ctx.roundRect(1, -48, 4, 42, 1);
                    ctx.fill();
                    
                    // Barrel rib (top between barrels)
                    ctx.fillStyle = '#5a5a5a';
                    ctx.fillRect(-0.5, -46, 1, 38);
                    
                    // Front bead sight
                    ctx.fillStyle = '#ffd700';
                    ctx.beginPath();
                    ctx.arc(0, -47, 1.2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Muzzle openings
                    ctx.fillStyle = '#0a0a0a';
                    ctx.beginPath();
                    ctx.ellipse(-3, -48, 1.8, 1, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(3, -48, 1.8, 1, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Barrel band
                    ctx.fillStyle = '#6a6a6a';
                    ctx.fillRect(-5.5, -30, 11, 2);
                    
                    // Forend (front wood piece)
                    const forend = ctx.createLinearGradient(-5, 0, 5, 0);
                    forend.addColorStop(0, '#6b3d11');
                    forend.addColorStop(0.5, '#a0522d');
                    forend.addColorStop(1, '#6b3d11');
                    ctx.fillStyle = forend;
                    ctx.beginPath();
                    ctx.roundRect(-5.5, -26, 11, 18, 2);
                    ctx.fill();
                    
                    // Forend checkering
                    ctx.strokeStyle = 'rgba(50, 25, 0, 0.4)';
                    ctx.lineWidth = 0.5;
                    for (let i = -4; i <= 4; i += 1.5) {
                        ctx.beginPath();
                        ctx.moveTo(i, -24);
                        ctx.lineTo(i + 2, -10);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(i, -10);
                        ctx.lineTo(i + 2, -24);
                        ctx.stroke();
                    }
                    
                    // Receiver (action body)
                    ctx.fillStyle = '#4a4a4a';
                    ctx.beginPath();
                    ctx.roundRect(-6, -10, 12, 14, 2);
                    ctx.fill();
                    
                    // Receiver engraving
                    ctx.strokeStyle = '#6a6a6a';
                    ctx.lineWidth = 0.5;
                    ctx.beginPath();
                    ctx.ellipse(0, -4, 4, 3, 0, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(-4, -6);
                    ctx.quadraticCurveTo(-5, -4, -4, -2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(4, -6);
                    ctx.quadraticCurveTo(5, -4, 4, -2);
                    ctx.stroke();
                    
                    // Break action hinge pin
                    ctx.fillStyle = '#7a7a7a';
                    ctx.beginPath();
                    ctx.arc(0, -7, 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Top lever
                    ctx.fillStyle = '#5a5a5a';
                    ctx.beginPath();
                    ctx.roundRect(-2, -10, 4, 3, 1);
                    ctx.fill();
                    
                    // Trigger guard
                    ctx.strokeStyle = '#5a5a5a';
                    ctx.lineWidth = 2.5;
                    ctx.beginPath();
                    ctx.moveTo(-4, 4);
                    ctx.quadraticCurveTo(-5, 10, 0, 12);
                    ctx.quadraticCurveTo(5, 10, 4, 4);
                    ctx.stroke();
                    
                    // Double triggers
                    ctx.fillStyle = '#3a3a3a';
                    ctx.fillRect(-2.5, 4, 2, 5);
                    ctx.fillRect(0.5, 4, 2, 5);
                    
                    // Stock
                    const stockGrad = ctx.createLinearGradient(-7, 0, 7, 0);
                    stockGrad.addColorStop(0, '#5c3317');
                    stockGrad.addColorStop(0.3, '#8b4513');
                    stockGrad.addColorStop(0.7, '#8b4513');
                    stockGrad.addColorStop(1, '#5c3317');
                    
                    ctx.fillStyle = stockGrad;
                    ctx.beginPath();
                    ctx.moveTo(-6, 4);
                    ctx.lineTo(-7, 14);
                    ctx.quadraticCurveTo(-8, 28, -4, 32);
                    ctx.lineTo(4, 32);
                    ctx.quadraticCurveTo(8, 28, 7, 14);
                    ctx.lineTo(6, 4);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Stock checkering
                    ctx.strokeStyle = 'rgba(50, 25, 0, 0.3)';
                    ctx.lineWidth = 0.5;
                    for (let i = -5; i <= 5; i += 2) {
                        ctx.beginPath();
                        ctx.moveTo(i, 16);
                        ctx.lineTo(i + 2, 28);
                        ctx.stroke();
                    }
                    
                    // Buttplate
                    ctx.fillStyle = '#2a2a2a';
                    ctx.beginPath();
                    ctx.moveTo(-4, 31);
                    ctx.quadraticCurveTo(0, 34, 4, 31);
                    ctx.lineTo(4, 32);
                    ctx.quadraticCurveTo(0, 35, -4, 32);
                    ctx.closePath();
                    ctx.fill();
                    
                } else if (weaponVisual.type === 'long' && p.weapon.baseName === 'Rifle') {
                    // ===== BOLT ACTION HUNTING RIFLE WITH SCOPE =====
                    
                    // Barrel - blued steel
                    const rifleBarrel = ctx.createLinearGradient(-3, 0, 3, 0);
                    rifleBarrel.addColorStop(0, '#1a1a2e');
                    rifleBarrel.addColorStop(0.5, '#2a2a3e');
                    rifleBarrel.addColorStop(1, '#1a1a2e');
                    
                    ctx.fillStyle = rifleBarrel;
                    ctx.beginPath();
                    ctx.roundRect(-2.5, -55, 5, 48, 1);
                    ctx.fill();
                    
                    // Muzzle crown
                    ctx.fillStyle = '#3a3a4a';
                    ctx.beginPath();
                    ctx.ellipse(0, -55, 2.5, 1.5, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#0a0a0a';
                    ctx.beginPath();
                    ctx.ellipse(0, -55, 1.5, 0.8, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Front sight base
                    ctx.fillStyle = '#2a2a2a';
                    ctx.fillRect(-3, -52, 6, 2);
                    // Front sight blade
                    ctx.fillStyle = '#ff4444';
                    ctx.beginPath();
                    ctx.moveTo(0, -54);
                    ctx.lineTo(-1, -52);
                    ctx.lineTo(1, -52);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Scope rings
                    ctx.fillStyle = '#3a3a3a';
                    ctx.beginPath();
                    ctx.roundRect(-4, -42, 8, 4, 1);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.roundRect(-4, -24, 8, 4, 1);
                    ctx.fill();
                    
                    // Scope body
                    const scopeGrad = ctx.createLinearGradient(-4, 0, 4, 0);
                    scopeGrad.addColorStop(0, '#1a1a1a');
                    scopeGrad.addColorStop(0.3, '#3a3a3a');
                    scopeGrad.addColorStop(0.7, '#3a3a3a');
                    scopeGrad.addColorStop(1, '#1a1a1a');
                    
                    ctx.fillStyle = scopeGrad;
                    ctx.beginPath();
                    ctx.roundRect(-3.5, -40, 7, 20, 3);
                    ctx.fill();
                    
                    // Scope objective lens (front)
                    ctx.fillStyle = '#2a2a3a';
                    ctx.beginPath();
                    ctx.ellipse(0, -40, 3.5, 2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Lens reflection
                    ctx.fillStyle = 'rgba(78, 205, 196, 0.6)';
                    ctx.beginPath();
                    ctx.ellipse(0, -40, 2.5, 1.5, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.beginPath();
                    ctx.ellipse(-1, -41, 1, 0.5, -0.3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Scope eyepiece
                    ctx.fillStyle = '#2a2a2a';
                    ctx.beginPath();
                    ctx.ellipse(0, -20, 3, 1.5, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Scope turrets (adjustment knobs)
                    ctx.fillStyle = '#4a4a4a';
                    ctx.beginPath();
                    ctx.roundRect(4, -34, 4, 6, 1);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.roundRect(-8, -34, 4, 6, 1);
                    ctx.fill();
                    // Turret lines
                    ctx.strokeStyle = '#2a2a2a';
                    ctx.lineWidth = 0.5;
                    for (let i = 0; i < 4; i++) {
                        ctx.beginPath();
                        ctx.moveTo(5, -33 + i * 1.5);
                        ctx.lineTo(7, -33 + i * 1.5);
                        ctx.stroke();
                    }
                    
                    // Receiver
                    ctx.fillStyle = '#2a2a3a';
                    ctx.beginPath();
                    ctx.roundRect(-4, -12, 8, 16, 2);
                    ctx.fill();
                    
                    // Bolt handle
                    ctx.fillStyle = '#4a4a5a';
                    ctx.beginPath();
                    ctx.moveTo(4, -8);
                    ctx.lineTo(10, -8);
                    ctx.lineTo(10, -4);
                    ctx.lineTo(4, -4);
                    ctx.closePath();
                    ctx.fill();
                    // Bolt knob
                    ctx.beginPath();
                    ctx.arc(10, -6, 2.5, 0, Math.PI * 2);
                    ctx.fill();
                    // Bolt knob checkering
                    ctx.strokeStyle = '#3a3a4a';
                    ctx.lineWidth = 0.5;
                    for (let i = 0; i < 5; i++) {
                        ctx.beginPath();
                        ctx.arc(10, -6, 1 + i * 0.4, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    
                    // Trigger guard
                    ctx.strokeStyle = '#3a3a4a';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-3, 4);
                    ctx.quadraticCurveTo(-4, 10, 0, 12);
                    ctx.quadraticCurveTo(4, 10, 3, 4);
                    ctx.stroke();
                    
                    // Trigger
                    ctx.fillStyle = '#3a3a3a';
                    ctx.fillRect(-0.8, 4, 1.6, 5);
                    
                    // Stock
                    const rifleStock = ctx.createLinearGradient(-6, 0, 6, 0);
                    rifleStock.addColorStop(0, '#3d2112');
                    rifleStock.addColorStop(0.5, '#654321');
                    rifleStock.addColorStop(1, '#3d2112');
                    
                    ctx.fillStyle = rifleStock;
                    ctx.beginPath();
                    ctx.moveTo(-5, 4);
                    ctx.lineTo(-6, 18);
                    ctx.quadraticCurveTo(-7, 34, -3, 38);
                    ctx.lineTo(3, 38);
                    ctx.quadraticCurveTo(7, 34, 6, 18);
                    ctx.lineTo(5, 4);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Cheek piece
                    ctx.fillStyle = '#5a3d21';
                    ctx.beginPath();
                    ctx.ellipse(-3, 18, 3, 8, 0.2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Stock checkering
                    ctx.strokeStyle = 'rgba(30, 15, 0, 0.3)';
                    ctx.lineWidth = 0.5;
                    for (let i = -4; i <= 4; i += 1.5) {
                        ctx.beginPath();
                        ctx.moveTo(i, 24);
                        ctx.lineTo(i + 1, 34);
                        ctx.stroke();
                    }
                    
                    // Buttpad
                    ctx.fillStyle = '#1a1a1a';
                    ctx.beginPath();
                    ctx.moveTo(-3, 37);
                    ctx.quadraticCurveTo(0, 40, 3, 37);
                    ctx.lineTo(3, 38);
                    ctx.quadraticCurveTo(0, 41, -3, 38);
                    ctx.closePath();
                    ctx.fill();
                    
                } else if (weaponVisual.type === 'long' && p.weapon.baseName === 'Repeater') {
                    // ===== WINCHESTER 1873 LEVER ACTION =====
                    
                    // Barrel
                    const winBarrel = ctx.createLinearGradient(-2, 0, 2, 0);
                    winBarrel.addColorStop(0, '#2a2a2a');
                    winBarrel.addColorStop(0.5, '#4a4a4a');
                    winBarrel.addColorStop(1, '#2a2a2a');
                    
                    ctx.fillStyle = winBarrel;
                    ctx.beginPath();
                    ctx.roundRect(-2, -50, 4, 44, 1);
                    ctx.fill();
                    
                    // Magazine tube (under barrel)
                    ctx.fillStyle = '#3a3a3a';
                    ctx.beginPath();
                    ctx.roundRect(-1.5, -46, 3, 38, 1);
                    ctx.fill();
                    
                    // Barrel band
                    ctx.fillStyle = '#b8860b';
                    ctx.fillRect(-3, -36, 6, 2);
                    ctx.fillRect(-3, -24, 6, 2);
                    
                    // Front sight
                    ctx.fillStyle = '#2a2a2a';
                    ctx.beginPath();
                    ctx.moveTo(0, -52);
                    ctx.lineTo(-1.5, -50);
                    ctx.lineTo(1.5, -50);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Receiver - iconic brass/bronze color
                    const brassGrad = ctx.createLinearGradient(-5, 0, 5, 0);
                    brassGrad.addColorStop(0, '#8b6914');
                    brassGrad.addColorStop(0.3, '#d4a84b');
                    brassGrad.addColorStop(0.5, '#e8c252');
                    brassGrad.addColorStop(0.7, '#d4a84b');
                    brassGrad.addColorStop(1, '#8b6914');
                    
                    ctx.fillStyle = brassGrad;
                    ctx.beginPath();
                    ctx.moveTo(-5, -10);
                    ctx.lineTo(5, -10);
                    ctx.lineTo(5, 6);
                    ctx.lineTo(-5, 6);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Receiver engraving details
                    ctx.strokeStyle = '#8b6914';
                    ctx.lineWidth = 0.8;
                    // Scrollwork pattern
                    ctx.beginPath();
                    ctx.moveTo(-3, -8);
                    ctx.quadraticCurveTo(-4, -4, -2, -2);
                    ctx.quadraticCurveTo(0, 0, 2, -2);
                    ctx.quadraticCurveTo(4, -4, 3, -8);
                    ctx.stroke();
                    // Side plate lines
                    ctx.beginPath();
                    ctx.moveTo(-4, -9);
                    ctx.lineTo(-4, 5);
                    ctx.moveTo(4, -9);
                    ctx.lineTo(4, 5);
                    ctx.stroke();
                    
                    // Loading gate
                    ctx.fillStyle = '#c4942f';
                    ctx.beginPath();
                    ctx.roundRect(5, -6, 2, 8, 0.5);
                    ctx.fill();
                    
                    // Hammer
                    ctx.fillStyle = '#5a5a5a';
                    ctx.beginPath();
                    ctx.moveTo(-1, -10);
                    ctx.lineTo(1, -10);
                    ctx.lineTo(1.5, -14);
                    ctx.lineTo(0, -16);
                    ctx.lineTo(-1.5, -14);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Lever - the iconic part
                    ctx.fillStyle = brassGrad;
                    ctx.strokeStyle = '#8b6914';
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.moveTo(-4, 6);
                    ctx.quadraticCurveTo(-7, 14, -3, 20);
                    ctx.quadraticCurveTo(0, 22, 3, 20);
                    ctx.quadraticCurveTo(7, 14, 4, 6);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    
                    // Lever loop opening
                    ctx.fillStyle = 'rgba(0,0,0,0.3)';
                    ctx.beginPath();
                    ctx.ellipse(0, 14, 3, 4, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Trigger
                    ctx.fillStyle = '#3a3a3a';
                    ctx.fillRect(-0.5, 6, 1, 4);
                    
                    // Forend wood
                    const forend2 = ctx.createLinearGradient(-4, 0, 4, 0);
                    forend2.addColorStop(0, '#5c3317');
                    forend2.addColorStop(0.5, '#8b4513');
                    forend2.addColorStop(1, '#5c3317');
                    
                    ctx.fillStyle = forend2;
                    ctx.beginPath();
                    ctx.roundRect(-4, -34, 8, 22, 2);
                    ctx.fill();
                    
                    // Forend checkering
                    ctx.strokeStyle = 'rgba(50, 25, 0, 0.3)';
                    ctx.lineWidth = 0.5;
                    for (let i = -2; i <= 2; i += 1.5) {
                        ctx.beginPath();
                        ctx.moveTo(i, -32);
                        ctx.lineTo(i + 1, -14);
                        ctx.stroke();
                    }
                    
                    // Stock
                    const winStock = ctx.createLinearGradient(-6, 0, 6, 0);
                    winStock.addColorStop(0, '#5c3317');
                    winStock.addColorStop(0.5, '#8b4513');
                    winStock.addColorStop(1, '#5c3317');
                    
                    ctx.fillStyle = winStock;
                    ctx.beginPath();
                    ctx.moveTo(-5, 6);
                    ctx.lineTo(-6, 16);
                    ctx.quadraticCurveTo(-6, 30, -3, 34);
                    ctx.lineTo(3, 34);
                    ctx.quadraticCurveTo(6, 30, 6, 16);
                    ctx.lineTo(5, 6);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Crescent buttplate
                    ctx.fillStyle = '#b8860b';
                    ctx.beginPath();
                    ctx.moveTo(-3, 33);
                    ctx.quadraticCurveTo(0, 38, 3, 33);
                    ctx.quadraticCurveTo(4, 34, 3, 35);
                    ctx.quadraticCurveTo(0, 40, -3, 35);
                    ctx.quadraticCurveTo(-4, 34, -3, 33);
                    ctx.closePath();
                    ctx.fill();
                    
                } else if (weaponVisual.type === 'dual') {
                    // ===== COLT 1911 SEMI-AUTOMATIC PISTOL =====
                    
                    // Slide
                    const slideGrad = ctx.createLinearGradient(-3, 0, 3, 0);
                    slideGrad.addColorStop(0, '#8a8a8a');
                    slideGrad.addColorStop(0.2, '#c0c0c0');
                    slideGrad.addColorStop(0.5, '#d8d8d8');
                    slideGrad.addColorStop(0.8, '#c0c0c0');
                    slideGrad.addColorStop(1, '#8a8a8a');
                    
                    ctx.fillStyle = slideGrad;
                    ctx.beginPath();
                    ctx.moveTo(-2.5, -22);
                    ctx.lineTo(2.5, -22);
                    ctx.lineTo(2.5, -4);
                    ctx.lineTo(-2.5, -4);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Slide serrations (rear)
                    ctx.strokeStyle = '#7a7a7a';
                    ctx.lineWidth = 0.8;
                    for (let i = 0; i < 8; i++) {
                        ctx.beginPath();
                        ctx.moveTo(-2.5, -18 + i * 1.5);
                        ctx.lineTo(2.5, -18 + i * 1.5);
                        ctx.stroke();
                    }
                    
                    // Ejection port
                    ctx.fillStyle = '#4a4a4a';
                    ctx.fillRect(0.5, -16, 2, 5);
                    
                    // Front sight
                    ctx.fillStyle = '#3a3a3a';
                    ctx.beginPath();
                    ctx.moveTo(0, -24);
                    ctx.lineTo(-1, -22);
                    ctx.lineTo(1, -22);
                    ctx.closePath();
                    ctx.fill();
                    // Fiber optic front sight
                    ctx.fillStyle = '#ff3333';
                    ctx.beginPath();
                    ctx.arc(0, -23, 0.8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Rear sight
                    ctx.fillStyle = '#3a3a3a';
                    ctx.fillRect(-2, -6, 1.5, 2);
                    ctx.fillRect(0.5, -6, 1.5, 2);
                    
                    // Frame
                    ctx.fillStyle = '#9a9a9a';
                    ctx.beginPath();
                    ctx.moveTo(-3, -4);
                    ctx.lineTo(3, -4);
                    ctx.lineTo(3.5, -2);
                    ctx.lineTo(3.5, 2);
                    ctx.lineTo(-3.5, 2);
                    ctx.lineTo(-3.5, -2);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Trigger guard
                    ctx.strokeStyle = '#8a8a8a';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-3, 1);
                    ctx.quadraticCurveTo(-4, 6, -1, 9);
                    ctx.lineTo(1, 9);
                    ctx.quadraticCurveTo(4, 6, 3, 1);
                    ctx.stroke();
                    
                    // Trigger
                    ctx.fillStyle = '#4a4a4a';
                    ctx.beginPath();
                    ctx.moveTo(-0.5, 2);
                    ctx.lineTo(0.5, 2);
                    ctx.lineTo(0.3, 7);
                    ctx.lineTo(-0.3, 7);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Beaver tail grip safety
                    ctx.fillStyle = '#8a8a8a';
                    ctx.beginPath();
                    ctx.moveTo(-3, -3);
                    ctx.quadraticCurveTo(-5, 0, -4, 3);
                    ctx.lineTo(-3.5, 2);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Grip panels (textured)
                    const gripGrad2 = ctx.createLinearGradient(-4, 0, 4, 0);
                    gripGrad2.addColorStop(0, '#1a1a1a');
                    gripGrad2.addColorStop(0.3, '#2a2a2a');
                    gripGrad2.addColorStop(0.7, '#2a2a2a');
                    gripGrad2.addColorStop(1, '#1a1a1a');
                    
                    ctx.fillStyle = gripGrad2;
                    ctx.beginPath();
                    ctx.moveTo(-3.5, 2);
                    ctx.lineTo(-4, 12);
                    ctx.lineTo(4, 12);
                    ctx.lineTo(3.5, 2);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Grip texture (dots pattern)
                    ctx.fillStyle = '#3a3a3a';
                    for (let row = 0; row < 4; row++) {
                        for (let col = 0; col < 4; col++) {
                            ctx.beginPath();
                            ctx.arc(-2.5 + col * 1.7, 4 + row * 2, 0.5, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                    
                    // Magazine baseplate
                    ctx.fillStyle = '#7a7a7a';
                    ctx.fillRect(-3, 11, 6, 2);
                    
                    // Slide release
                    ctx.fillStyle = '#6a6a6a';
                    ctx.beginPath();
                    ctx.ellipse(-3.5, -10, 1, 2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Safety
                    ctx.fillStyle = '#5a5a5a';
                    ctx.fillRect(-4.5, -4, 1.5, 2);
                }
                ctx.restore();
            }
            
            ctx.restore();
            ctx.restore();
            
            // Other arm (for dual pistols or idle)
            ctx.save();
            ctx.translate(-armOffsetX, -2);
            
            if (weaponVisual && weaponVisual.type === 'dual') {
                // Second pistol arm
                ctx.rotate(-armAngle * 0.5);
                ctx.fillStyle = skinColor;
                ctx.fillRect(-3, -2, 6, 12);
                ctx.save();
                ctx.translate(0, 10);
                ctx.rotate(-armAngle * 0.5);
                ctx.fillStyle = skinShadow;
                ctx.fillRect(-2.5, 0, 5, 10);
                ctx.fillStyle = skinColor;
                ctx.beginPath();
                ctx.arc(0, 12, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Second 1911 pistol (matching the first)
                ctx.translate(0, 14);
                
                // Slide with gradient
                const slideGrad2 = ctx.createLinearGradient(-3, 0, 3, 0);
                slideGrad2.addColorStop(0, '#8a8a8a');
                slideGrad2.addColorStop(0.2, '#c0c0c0');
                slideGrad2.addColorStop(0.5, '#d8d8d8');
                slideGrad2.addColorStop(0.8, '#c0c0c0');
                slideGrad2.addColorStop(1, '#8a8a8a');
                
                ctx.fillStyle = slideGrad2;
                ctx.beginPath();
                ctx.moveTo(-2.5, -22);
                ctx.lineTo(2.5, -22);
                ctx.lineTo(2.5, -4);
                ctx.lineTo(-2.5, -4);
                ctx.closePath();
                ctx.fill();
                
                // Slide serrations
                ctx.strokeStyle = '#7a7a7a';
                ctx.lineWidth = 0.8;
                for (let i = 0; i < 8; i++) {
                    ctx.beginPath();
                    ctx.moveTo(-2.5, -18 + i * 1.5);
                    ctx.lineTo(2.5, -18 + i * 1.5);
                    ctx.stroke();
                }
                
                // Front sight with fiber optic
                ctx.fillStyle = '#3a3a3a';
                ctx.beginPath();
                ctx.moveTo(0, -24);
                ctx.lineTo(-1, -22);
                ctx.lineTo(1, -22);
                ctx.closePath();
                ctx.fill();
                ctx.fillStyle = '#ff3333';
                ctx.beginPath();
                ctx.arc(0, -23, 0.8, 0, Math.PI * 2);
                ctx.fill();
                
                // Frame
                ctx.fillStyle = '#9a9a9a';
                ctx.beginPath();
                ctx.moveTo(-3, -4);
                ctx.lineTo(3, -4);
                ctx.lineTo(3.5, -2);
                ctx.lineTo(3.5, 2);
                ctx.lineTo(-3.5, 2);
                ctx.lineTo(-3.5, -2);
                ctx.closePath();
                ctx.fill();
                
                // Trigger guard
                ctx.strokeStyle = '#8a8a8a';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-3, 1);
                ctx.quadraticCurveTo(-4, 6, -1, 9);
                ctx.lineTo(1, 9);
                ctx.quadraticCurveTo(4, 6, 3, 1);
                ctx.stroke();
                
                // Trigger
                ctx.fillStyle = '#4a4a4a';
                ctx.beginPath();
                ctx.moveTo(-0.5, 2);
                ctx.lineTo(0.5, 2);
                ctx.lineTo(0.3, 7);
                ctx.lineTo(-0.3, 7);
                ctx.closePath();
                ctx.fill();
                
                // Grip panels
                const gripGrad3 = ctx.createLinearGradient(-4, 0, 4, 0);
                gripGrad3.addColorStop(0, '#1a1a1a');
                gripGrad3.addColorStop(0.3, '#2a2a2a');
                gripGrad3.addColorStop(0.7, '#2a2a2a');
                gripGrad3.addColorStop(1, '#1a1a1a');
                
                ctx.fillStyle = gripGrad3;
                ctx.beginPath();
                ctx.moveTo(-3.5, 2);
                ctx.lineTo(-4, 12);
                ctx.lineTo(4, 12);
                ctx.lineTo(3.5, 2);
                ctx.closePath();
                ctx.fill();
                
                // Grip texture
                ctx.fillStyle = '#3a3a3a';
                for (let row = 0; row < 4; row++) {
                    for (let col = 0; col < 4; col++) {
                        ctx.beginPath();
                        ctx.arc(-2.5 + col * 1.7, 4 + row * 2, 0.5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                // Magazine baseplate
                ctx.fillStyle = '#7a7a7a';
                ctx.fillRect(-3, 11, 6, 2);
                
                ctx.restore();
            } else {
                // Idle arm
                const idleSwing = p.isMoving ? Math.sin(p.walkCycle + Math.PI) * 0.2 : 0;
                ctx.rotate(idleSwing);
                ctx.fillStyle = skinColor;
                ctx.fillRect(-3, -2, 6, 12);
                ctx.fillStyle = skinShadow;
                ctx.fillRect(-2.5, 10, 5, 8);
                ctx.fillStyle = skinColor;
                ctx.beginPath();
                ctx.arc(0, 20, 4, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
            
            ctx.restore();
            
            // Head with helmet or bare
            ctx.save();
            ctx.translate(0, -12 + walkBob);
            
            const hasHeadArmor = p.armorSlots && p.armorSlots.head;
            const skinColor2 = '#d4a574';
            
            if (hasHeadArmor) {
                // Neck with gorget (neck armor)
                ctx.fillStyle = '#5a5a5a';
                ctx.fillRect(-6, 2, 12, 8);
                ctx.fillStyle = '#6a6a6a';
                ctx.fillRect(-5, 4, 10, 4);
                
                // Helmet base
                const helmetGrad = ctx.createLinearGradient(-12, 0, 12, 0);
                helmetGrad.addColorStop(0, '#4a4a4a');
                helmetGrad.addColorStop(0.3, '#6a6a6a');
                helmetGrad.addColorStop(0.5, '#7a7a7a');
                helmetGrad.addColorStop(0.7, '#6a6a6a');
                helmetGrad.addColorStop(1, '#4a4a4a');
                
                ctx.fillStyle = helmetGrad;
                ctx.beginPath();
                ctx.ellipse(0, 0, 12, 13, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Helmet top crest/ridge
                ctx.fillStyle = '#5a5a5a';
                ctx.beginPath();
                ctx.moveTo(0, -13);
                ctx.lineTo(-2, -8);
                ctx.lineTo(2, -8);
                ctx.closePath();
                ctx.fill();
                ctx.fillRect(-1.5, -13, 3, 6);
                
                // Face guard / visor
                ctx.save();
                ctx.scale(facing, 1);
                
                // Visor (face opening)
                ctx.fillStyle = '#1a1a1a';
                ctx.beginPath();
                ctx.moveTo(-8, -3);
                ctx.lineTo(-6, 4);
                ctx.lineTo(6, 4);
                ctx.lineTo(8, -3);
                ctx.lineTo(4, -4);
                ctx.lineTo(-4, -4);
                ctx.closePath();
                ctx.fill();
                
                // Visor bars/slits
                ctx.fillStyle = '#3a3a3a';
                ctx.fillRect(-6, -2, 12, 1.5);
                ctx.fillRect(-5, 1, 10, 1.5);
                
                // Eyes visible through visor
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.ellipse(-3, -1, 2, 1.5, 0, 0, Math.PI * 2);
                ctx.ellipse(3, -1, 2, 1.5, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Pupils
                const pupilOffset = Math.min(1, Math.abs(aimAngle)) * 1;
                ctx.fillStyle = '#2a2a2a';
                ctx.beginPath();
                ctx.arc(-3 + pupilOffset * Math.cos(aimAngle), -1, 1, 0, Math.PI * 2);
                ctx.arc(3 + pupilOffset * Math.cos(aimAngle), -1, 1, 0, Math.PI * 2);
                ctx.fill();
                
                // Nose guard
                ctx.fillStyle = '#5a5a5a';
                ctx.beginPath();
                ctx.moveTo(0, -4);
                ctx.lineTo(-2, 3);
                ctx.lineTo(2, 3);
                ctx.closePath();
                ctx.fill();
                
                ctx.restore();
            } else {
                // Bare neck
                ctx.fillStyle = skinColor2;
                ctx.fillRect(-5, 2, 10, 8);
                
                // Bare head
                ctx.fillStyle = skinColor2;
                ctx.beginPath();
                ctx.ellipse(0, 0, 10, 11, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Hair (brown)
                ctx.fillStyle = '#4a3020';
                ctx.beginPath();
                ctx.ellipse(0, -4, 9, 7, 0, Math.PI, 0);
                ctx.fill();
                // Hair sides
                ctx.fillRect(-9, -4, 3, 6);
                ctx.fillRect(6, -4, 3, 6);
                
                // Face
                ctx.save();
                ctx.scale(facing, 1);
                
                // Eyes
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.ellipse(-3, -1, 2.5, 2, 0, 0, Math.PI * 2);
                ctx.ellipse(3, -1, 2.5, 2, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Pupils
                const pupilOffset = Math.min(1, Math.abs(aimAngle)) * 1;
                ctx.fillStyle = '#3a2a1a';
                ctx.beginPath();
                ctx.arc(-3 + pupilOffset * Math.cos(aimAngle), -1, 1.2, 0, Math.PI * 2);
                ctx.arc(3 + pupilOffset * Math.cos(aimAngle), -1, 1.2, 0, Math.PI * 2);
                ctx.fill();
                
                // Eyebrows
                ctx.strokeStyle = '#3a2515';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(-5, -4);
                ctx.lineTo(-1, -3.5);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(5, -4);
                ctx.lineTo(1, -3.5);
                ctx.stroke();
                
                // Nose
                ctx.fillStyle = '#c49464';
                ctx.beginPath();
                ctx.moveTo(0, -1);
                ctx.lineTo(-1.5, 3);
                ctx.lineTo(1.5, 3);
                ctx.closePath();
                ctx.fill();
                
                // Mouth
                ctx.strokeStyle = '#8a6a5a';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(-3, 5);
                ctx.quadraticCurveTo(0, 6, 3, 5);
                ctx.stroke();
                
                // Stubble/beard shadow
                ctx.fillStyle = 'rgba(60, 40, 30, 0.2)';
                ctx.beginPath();
                ctx.ellipse(0, 6, 5, 4, 0, 0, Math.PI);
                ctx.fill();
                
                ctx.restore();
            }
            
            ctx.restore();
            
            ctx.restore();
        }

        // PWA Installation
        let deferredPrompt;
        
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            document.getElementById('install-btn').style.display = 'block';
        });

        document.getElementById('install-btn').addEventListener('click', async () => {
            if (deferredPrompt) {
                deferredPrompt.prompt();
                const { outcome } = await deferredPrompt.userChoice;
                deferredPrompt = null;
                document.getElementById('install-btn').style.display = 'none';
            }
        });

        // Register service worker
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js').catch(() => {});
        }

        // Start
        init();
    </script>
</body>
</html>
